<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8" /><guide><reference type="toc" title="Table of Contents" filepos=0000814478 /></guide></head><body><p height="1em" width="0pt">Т У , Д О Х О А Н Г</p><p height="1em" width="0pt">ОПЕРАЦИОННЫЕ СИСТЕМЫ :</p><p height="1em" width="0pt">Ф Р О М 0 К О 1</p><p height="1em" width="0pt"> <a id="filepos301" />Содержание</p><p height="1em" width="0pt"><a href="#filepos19159"> <i>Предисловие</i></a></p><p height="1em" width="0pt">я</p><p height="1em" width="0pt"><a href="#filepos32544"> <i>я</i></a></p><p height="1em" width="0pt"><a href="#filepos32544"> <i>Предварительный</i></a></p><p height="1em" width="0pt">1</p><p height="1em" width="0pt"><b>1</b></p><p height="1em" width="0pt"><a href="#filepos32647"><b>Документы домена</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt"><b>3</b></p><p height="1em" width="0pt"> <i>1.1</i><a href="#filepos32647"><i>Проблемные области</i></a> <i>. . . . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>3</i></p><p height="1em" width="0pt"> <i>1,2</i><a href="#filepos39218"><i>Документы для реализации проблемной области</i></a> <i>. . . .</i></p><p height="1em" width="0pt"> <i>6</i></p><p height="1em" width="0pt"> <i>1,3</i><a href="#filepos46844"><i>Документы для написания операционной системы x86.</i></a> <i>. . .</i></p><p height="1em" width="0pt"> <i>9</i></p><p height="1em" width="0pt"><b>2</b></p><p height="1em" width="0pt"><a href="#filepos49797"><b>От аппаратного обеспечения к программному обеспечению: уровни абстракции</b></a></p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt"><b>11</b></p><p height="1em" width="0pt"> <i>2.1</i><a href="#filepos49797"><i>Физическая реализация немного</i></a> <i>. . . . . . . .</i></p><p height="1em" width="0pt"> <i>11</i></p><p height="1em" width="0pt"> <i>2.2</i><a href="#filepos51195"><i>Помимо транзисторов: цифровые логические вентили</i></a> <i>. . . . . . .</i></p><p height="1em" width="0pt"> <i>12</i></p><p height="1em" width="0pt"> <i>2.3</i><a href="#filepos67491"><i>Помимо логических ворот: машинный язык</i></a> <i>. . . . . .</i></p><p height="1em" width="0pt"> <i>17</i></p><p height="1em" width="0pt"> <i>2,4</i><a href="#filepos96782"><i>Абстракция</i></a> <i>. . . . . . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>26</i></p><p height="1em" width="0pt"><b>3</b></p><p height="1em" width="0pt"><a href="#filepos108871"><b>Компьютерная архитектура</b></a></p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt"><b>33</b></p><p height="1em" width="0pt"> <i>3.1</i><a href="#filepos108871"><i>Что такое компьютер?</i></a> <i>. . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>33</i></p><p height="1em" width="0pt"> <i>3.2</i><a href="#filepos127840"><i>Компьютерная архитектура</i></a> <i>. . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>39</i></p><p height="1em" width="0pt"> <i>3.3</i><a href="#filepos140936"><i>архитектура x86</i></a> <i>. . . . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>44</i></p><p height="1em" width="0pt"> <i>3.4</i><a href="#filepos147832"><i>Чипсет Intel Q35</i></a> <i>. . . . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>47</i></p><p height="1em" width="0pt"> <i>3,5</i><a href="#filepos147832"><i>Среда выполнения x86</i></a> <i>. . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>47</i></p><p height="1em" width="0pt">II</p><p height="1em" width="0pt">ту, до хоанг</p><p height="1em" width="0pt"><b>4</b></p><p height="1em" width="0pt"><a href="#filepos149943"><b>x86 ассемблер и C</b></a></p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt"><b>49</b></p><p height="1em" width="0pt"> <i>4.1</i><a href="#filepos151594"><i>objdump</i></a> <i>. . . . . . . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>50</i></p><p height="1em" width="0pt"> <i>4.2</i><a href="#filepos153494"><i>Чтение вывода</i></a> <i>. . . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>51</i></p><p height="1em" width="0pt"> <i>4.3</i><a href="#filepos157688"><i>Руководства Intel</i></a> <i>. . . . . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>53</i></p><p height="1em" width="0pt"> <i>4.4</i><a href="#filepos160699"><i>Поэкспериментируйте с ассемблерным кодом.</i></a> <i>. . . . . . . . .</i></p><p height="1em" width="0pt"> <i>54</i></p><p height="1em" width="0pt"> <i>4,5</i><a href="#filepos166809"><i>Анатомия инструкции по сборке</i></a> <i>. . . . . . . .</i></p><p height="1em" width="0pt"> <i>56</i></p><p height="1em" width="0pt"> <i>4.6</i><a href="#filepos225809"><i>Подробно изучить инструкцию</i></a> <i>. . . . . . . .</i></p><p height="1em" width="0pt"> <i>66</i></p><p height="1em" width="0pt"> <i>4.7</i><a href="#filepos233869"><i>Пример: инструкция jmp</i></a> <i>. . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>69</i></p><p height="1em" width="0pt"> <i>4,8</i><a href="#filepos245992"><i>Изучите скомпилированные данные</i></a> <i>. . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>72</i></p><p height="1em" width="0pt"> <i>4.9</i><a href="#filepos283477"><i>Изучите скомпилированный код</i></a> <i>. . . . . . . . . . . . .</i></p><p height="1em" width="0pt"> <i>86</i></p><p height="1em" width="0pt"><b>5</b></p><p height="1em" width="0pt"><a href="#filepos344661"><b>Анатомия программы</b></a></p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>107</b></p><p height="1em" width="0pt"> <i>5.1</i><a href="#filepos348998"><i>Справочные документы:</i></a> <i>. . . . . . . . . . . . . 109</i></p><p height="1em" width="0pt"> <i>5.2</i><a href="#filepos348998"><i>заголовок ELF</i></a> <i>. . . . . . . . . . . . . . . . . 109</i></p><p height="1em" width="0pt"> <i>5.3</i><a href="#filepos360914"><i>Таблица заголовка раздела</i></a> <i>. . . . . . . . . . . . . . 114</i></p><p height="1em" width="0pt"> <i>5.4</i><a href="#filepos384929"><i>Подробно разобраться в разделе</i></a> <i>. . . . . . . . . . . 121</i></p><p height="1em" width="0pt"> <i>5,5</i><a href="#filepos444786"><i>Таблица заголовка программы</i></a> <i>. . . . . . . . . . . . . 141</i></p><p height="1em" width="0pt"> <i>5.6</i><a href="#filepos454498"><i>Сегменты против разделов.</i></a> <i>. . . . . . . . . . . . . 144</i></p><p height="1em" width="0pt"><b>6</b></p><p height="1em" width="0pt"><a href="#filepos481111"><b>Проверка и отладка во время выполнения</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>151</b></p><p height="1em" width="0pt"> <i>6.1</i><a href="#filepos481111"><i>Пример программы</i></a> <i>. . . . . . . . . . . . . . 151</i></p><p height="1em" width="0pt"> <i>6.2</i><a href="#filepos482462"><i>Статическая проверка программы</i></a> <i>. . . . . . . . . . 152</i></p><p height="1em" width="0pt"> <i>6.3</i><a href="#filepos510333"><i>Проверка программы во время выполнения</i></a> <i>. . . . . . . . . 163</i></p><p height="1em" width="0pt"> <i>6.4</i><a href="#filepos540659"><i>Как работают отладчики: краткое введение</i></a> <i>. . . . . . 179</i></p><p height="1em" width="0pt"><a href="#filepos574709"> <i>II</i></a></p><p height="1em" width="0pt"><a href="#filepos574709"> <i>Фундамент</i></a></p><p height="1em" width="0pt">191</p><p height="1em" width="0pt"><b>7</b></p><p height="1em" width="0pt"><a href="#filepos574833"><b>Загрузчик</b></a></p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>193</b></p><p height="1em" width="0pt"> <i>7.1</i><a href="#filepos574833"><i>Процесс загрузки x86</i></a> <i>. . . . . . . . . . . . . . . 193</i></p><p height="1em" width="0pt"> <i>7.2</i><a href="#filepos576886"><i>Использование служб БИОС</i></a> <i>. . . . . . . . . . . . . . 194</i></p><p height="1em" width="0pt"> <i>7.3</i><a href="#filepos579975"><i>Процесс загрузки.</i></a> <i>. . . . . . . . . . . . . . . . 195</i></p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">III</p><p height="1em" width="0pt"> <i>7.4</i><a href="#filepos579975"><i>Пример загрузчика</i></a> <i>. . . . . . . . . . . . . . 195</i></p><p height="1em" width="0pt"> <i>7,5</i><a href="#filepos582270"><i>Скомпилируйте и загрузите</i></a> <i>. . . . . . . . . . . . . . . 196</i></p><p height="1em" width="0pt"> <i>7.6</i><a href="#filepos592594"><i>Загрузка программы из загрузчика</i></a> <i>. . . . . . . . 201</i></p><p height="1em" width="0pt"> <i>7.7</i><a href="#filepos604179"><i>Повысьте производительность с помощью скриптов</i></a> <i>. . . . . . . . . 205</i></p><p height="1em" width="0pt"><b>8</b></p><p height="1em" width="0pt"><a href="#filepos635813"><b>Связывание и загрузка на голое железо</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>217</b></p><p height="1em" width="0pt"> <i>8.1</i><a href="#filepos637501"><i>Понимание переездов с readelf</i></a> <i>. . . . . . . . 218</i></p><p height="1em" width="0pt"> <i>8.2</i><a href="#filepos672464"><i>Создание двоичного файла ELF с помощью скриптов компоновщика</i></a> <i>. . . . . . . 227</i></p><p height="1em" width="0pt"> <i>8.3</i><a href="#filepos723613"><i>Среда выполнения C: размещенная или отдельно стоящая</i></a> <i>. . . . . . . . 248</i></p><p height="1em" width="0pt"> <i>8.4</i><a href="#filepos726092"><i>Отлаживаемый загрузчик на голом железе</i></a> <i>. . . . . . . . 249</i></p><p height="1em" width="0pt"> <i>8,5</i><a href="#filepos730559"><i>Отлаживаемая программа на голом железе</i></a> <i>. . . . . . . . . 251</i></p><p height="1em" width="0pt"><a href="#filepos780273"> <i>III</i></a></p><p height="1em" width="0pt"><a href="#filepos780273"> <i>Программирование ядра</i></a></p><p height="1em" width="0pt">275</p><p height="1em" width="0pt"><b>9</b></p><p height="1em" width="0pt"><a href="#filepos780385"><b>x86-дескрипторы</b>.</a></p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>277</b></p><p height="1em" width="0pt"> <i>9.1</i><a href="#filepos780385"><i>Основные понятия операционной системы</i></a> <i>. . . . . . . . . 277</i></p><p height="1em" width="0pt"> <i>9.2</i><a href="#filepos784047"><i>Драйверы</i></a> <i>. . . . . . . . . . . . . . . . . . 279</i></p><p height="1em" width="0pt"> <i>9.3</i><a href="#filepos784047"><i>Пользовательское пространство и пространство ядра</i></a> <i>. . . . . . . . . . . 279</i></p><p height="1em" width="0pt"> <i>9.4</i><a href="#filepos786399"><i>Сегмент памяти</i></a> <i>. . . . . . . . . . . . . . . 280</i></p><p height="1em" width="0pt"> <i>9,5</i><a href="#filepos786399"><i>Дескриптор сегмента</i></a> <i>. . . . . . . . . . . . . . 280</i></p><p height="1em" width="0pt"> <i>9,6</i><a href="#filepos786399"><i>Типы дескрипторов сегментов</i></a> <i>. . . . . . . . . . 280</i></p><p height="1em" width="0pt"> <i>9,7</i><a href="#filepos786399"><i>Область дескриптора</i></a> <i>. . . . . . . . . . . . . . . 280</i></p><p height="1em" width="0pt"> <i>9,8</i><a href="#filepos786399"><i>Выбор сегмента</i></a> <i>. . . . . . . . . . . . . . . 280</i></p><p height="1em" width="0pt"> <i>9,9</i><a href="#filepos786399"><i>Улучшение: загрузчик с дескрипторами</i></a> <i>. . . . . . 280</i></p><p height="1em" width="0pt"><b>10</b><a href="#filepos787560"><b>Процесс</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>281</b></p><p height="1em" width="0pt"> <i>10.1</i><a href="#filepos787560"><i>Концепции</i></a> <i>. . . . . . . . . . . . . . . . . . 281</i></p><p height="1em" width="0pt"> <i>10.2</i><a href="#filepos787560"><i>Процесс</i></a> <i>. . . . . . . . . . . . . . . . . . 281</i></p><p height="1em" width="0pt"> <i>10.3</i><a href="#filepos791371"><i>Потоки</i></a> <i>. . . . . . . . . . . . . . . . . . 283</i></p><p height="1em" width="0pt"> <i>10.4</i><a href="#filepos793483"><i>Задача: x86 концепция процесса</i></a> <i>. . . . . . . . . . 284</i></p><p height="1em" width="0pt"> <i>10,5</i><a href="#filepos793483"><i>Структура данных задачи</i></a> <i>. . . . . . . . . . . . . . 284</i></p><p height="1em" width="0pt">IV</p><p height="1em" width="0pt">ту, до хоанг</p><p height="1em" width="0pt"> <i>10,6</i><a href="#filepos793483"><i>Реализация процесса</i></a> <i>. . . . . . . . . . . . 284</i></p><p height="1em" width="0pt"> <i>10,7</i><a href="#filepos795678"><i>Веха: рефакторинг кода</i></a> <i>. . . . . . . . . . . . 285</i></p><p height="1em" width="0pt"><b>11</b><a href="#filepos796642"><b>Прерывать</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>287</b></p><p height="1em" width="0pt"><b>12</b><a href="#filepos796732"><b>Управление памятью</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>289</b></p><p height="1em" width="0pt"><b>13</b><a href="#filepos799414"><b>Файловая система</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>291</b></p><p height="1em" width="0pt"><a href="#filepos800899"><b>Индекс</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>293</b></p><p height="1em" width="0pt"><a href="#filepos805320"><b>Библиография</b></a>.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">.<b>295</b></p><a id="filepos19159" /><p height="1em" width="0pt">Предисловие</p><p height="1em" width="0pt">Привет!</p><p height="1em" width="0pt">Вы, наверное, хотя бы раз спрашивали себя, как операционная система пишется с нуля. У вас может быть даже многолетний опыт программирования за плечами, но ваше понимание операционных систем может по-прежнему быть набором абстрактных концепций, не основанных на реальной реализации. Тем, кто никогда ее не создавал, операционная система может показаться волшебством: загадочной вещью, которая может управлять оборудованием, одновременно обрабатывая запросы программиста через API их любимого языка программирования. Изучение того, как создать операционную систему, кажется пугающим и трудным; независимо от того, сколько вы узнаете, никогда не будет казаться, что вы знаете достаточно. Вы, вероятно, читаете эту книгу прямо сейчас, чтобы лучше понять операционные системы, чтобы стать лучшим инженером-программистом.</p><p height="1em" width="0pt">Если это так, то эта книга для вас. Прочитав эту книгу, вы сможете найти недостающие части, которые необходимы и позволят вам реализовать свою собственную операционную систему с нуля! Да, с нуля, не проходя через какой-либо существующий слой операционной системы, чтобы доказать себе, что вы разработчик операционной системы. Вы можете спросить: «Разве не практичнее изучить внутренности Linux?».</p><p height="1em" width="0pt">Да...</p><p height="1em" width="0pt">и нет.</p><p height="1em" width="0pt">Изучение Linux может помочь вашему рабочему процессу на вашей повседневной работе. Однако, если вы пойдете по этому пути, вы все равно не достигнете конечной цели — написания настоящей операционной системы. Написав свою собственную операционную систему, вы получите знания, которые не сможете почерпнуть из простого обучения.</p><p height="1em" width="0pt">II</p><p height="1em" width="0pt">ту, до хоанг</p><p height="1em" width="0pt">в Linux.</p><p height="1em" width="0pt">Вот список некоторых преимуществ написания собственной ОС: вы узнаете, как компьютер работает на аппаратном уровне, и вы научитесь писать программное обеспечение для непосредственного управления этим оборудованием.</p><p height="1em" width="0pt">Вы изучите основы операционных систем, что позволит вам адаптироваться к любой операционной системе, а не только к Linux.</p><p height="1em" width="0pt">Чтобы правильно взломать внутренности Linux, вам нужно написать хотя бы одну операционную систему самостоятельно. Это как с программированием приложений: чтобы написать большое приложение, нужно начинать с простых.</p><p height="1em" width="0pt">Вы откроете пути к различным областям низкоуровневого программирования, таким как обратный инжиниринг, эксплойты, создание виртуальных машин, эмуляция игровой консоли и многое другое. Язык ассемблера станет одним из ваших самых незаменимых инструментов для низкоуровневого анализа. (Но это не значит, что вы должны писать свою операционную систему на ассемблере!) Написание операционной системы — это весело!</p><p height="1em" width="0pt"> <i><b>Зачем еще одна книга по операционным системам?</b></i></p><p height="1em" width="0pt">Уже существует множество книг и курсов по этой теме, написанных известными профессорами и экспертами. Кто я такой, чтобы писать книгу на такую ​​сложную тему? Хотя действительно существует много качественных ресурсов, мне кажется, что их не хватает. Показывает ли кто-нибудь из них, как компилировать ваш код C и библиотеку времени выполнения C независимо от существующей операционной системы?</p><p height="1em" width="0pt">В большинстве книг по проектированию и внедрению операционных систем обсуждается только программная сторона; то, как операционная система взаимодействует с оборудованием, пропускается. Важные сведения об оборудовании пропускаются, а самообучающемуся сложно найти соответствующие ресурсы в Интернете. Цель этой книги — восполнить этот пробел: вы не только научитесь программировать аппаратное обеспечение напрямую, но и узнаете, как читать официальные документы от поставщиков аппаратного обеспечения, чтобы программировать его. Вам больше не нужно искать ресурсы, чтобы помочь себе интерпретировать руководства и документацию по оборудованию: вы можете сделать это самостоятельно. Наконец, я написал эту книгу с точки зрения самоучки. Я сделал эту книгу как можно более независимой, чтобы вы могли потратить больше</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">III</p><p height="1em" width="0pt">время на обучение и меньше времени на догадки или поиск информации в Интернете.</p><p height="1em" width="0pt">Одной из основных целей этой книги является руководство по процессу чтения официальной документации от поставщиков для реализации вашего программного обеспечения. Официальные документы от поставщиков аппаратного обеспечения, таких как Intel, имеют решающее значение для внедрения операционной системы или любого другого программного обеспечения, непосредственно управляющего аппаратным обеспечением. Как минимум, разработчик операционной системы должен уметь понимать эти документы и реализовывать программное обеспечение на основе набора требований к оборудованию. Таким образом, первая глава посвящена обсуждению соответствующих документов и их важности.</p><p height="1em" width="0pt">Еще одной отличительной чертой этой книги является то, что она ориентирована на «Hello World». Большинство примеров вращаются вокруг вариантов программы «Hello World», которая познакомит вас с основными понятиями. Эти концепции необходимо изучить перед попыткой написать операционную систему. Все, что выходит за рамки простого примера «Hello World», мешает обучению концепциям, тем самым увеличивая время, затрачиваемое на начало написания операционной системы.</p><p height="1em" width="0pt">Давайте углубимся. В этой книге я надеюсь предоставить достаточно фундаментальных знаний, которые откроют вам двери для понимания других ресурсов.</p><p height="1em" width="0pt">Эта книга будет полезна студентам, которые только что закончили свой первый курс C/C++. Представьте, как здорово было бы показать потенциальным работодателям, что вы уже создали операционную систему.</p><p height="1em" width="0pt"> <i><b>Предпосылки</b></i></p><p height="1em" width="0pt">Базовые знания о схемах</p><p height="1em" width="0pt"><b>–</b>Основные понятия электричества: атомы, электроны, протоны, нейтроны, ток.</p><p height="1em" width="0pt"><b>–</b>Закон Ома</p><p height="1em" width="0pt">Если вы не знакомы с этими понятиями, вы можете быстро изучить их здесь:<a href="http://www.allaboutcircuits.com/textbook/">http://www.allaboutcircuits.com/textbook/,</a>прочитав главу 1 и главу 2.</p><p height="1em" width="0pt">Программирование на С. В частности:</p><p height="1em" width="0pt">IV</p><p height="1em" width="0pt">ту, до хоанг</p><p height="1em" width="0pt"><b>–</b>Объявления/определения переменных и функций</p><p height="1em" width="0pt"><b>–</b>Пока и для циклов</p><p height="1em" width="0pt"><b>–</b>Указатели и указатели функций</p><p height="1em" width="0pt"><b>–</b>Основные алгоритмы и структуры данных в C</p><p height="1em" width="0pt">Основы Линукса:</p><p height="1em" width="0pt"><b>–</b>Знать, как перемещаться по каталогу с помощью командной строки</p><p height="1em" width="0pt"><b>–</b>Знать, как вызывать команду с параметрами</p><p height="1em" width="0pt"><b>–</b>Знать, как передать вывод в другую программу</p><p height="1em" width="0pt">Сенсорный ввод. Так как мы собираемся использовать Linux, нам поможет слепая печать. Я знаю, что скорость печати не имеет отношения к решению проблем, но, по крайней мере, ваша скорость печати должна быть достаточно высокой, чтобы она не мешала и не ухудшала процесс обучения.</p><p height="1em" width="0pt">В общем, я предполагаю, что читатель обладает базовыми знаниями в области программирования на C и может использовать IDE для сборки и запуска программы.</p><p height="1em" width="0pt"> <i><b>Что вы узнаете из этой книги</b></i></p><p height="1em" width="0pt">Как написать операционную систему с нуля, читая спецификации оборудования. В реальном мире вы не сможете проконсультироваться с Google для быстрого ответа.</p><p height="1em" width="0pt">Пишите код самостоятельно. Бессмысленно копировать и вставлять код. Настоящее обучение происходит, когда вы решаете проблемы самостоятельно. Некоторые примеры приведены для того, чтобы помочь вам начать работу, но большинство проблем предстоит решить вам. Тем не менее, решения доступны в Интернете для вас после хорошей попытки.</p><p height="1em" width="0pt">Общая картина того, как каждый уровень компьютера связан друг с другом, от аппаратного до программного обеспечения.</p><p height="1em" width="0pt">Как использовать Linux в качестве среды разработки и общие инструменты для низкоуровневого программирования.</p><p height="1em" width="0pt">Как устроена программа, чтобы операционная система могла работать.</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">в</p><p height="1em" width="0pt">Как отладить программу, работающую непосредственно на оборудовании, с помощью gdb и QEMU.</p><p height="1em" width="0pt">Связывание и загрузка на голом железе x86_64, на чистом C. Нет стандартной библиотеки. Нет накладных расходов во время выполнения.</p><p height="1em" width="0pt"> <i><b>О чем эта книга не</b></i></p><p height="1em" width="0pt">Электротехника: в книге обсуждаются некоторые концепции электроники и электротехники только в той мере, в какой программное обеспечение работает на «голом железе».</p><p height="1em" width="0pt">Книги о том, как использовать Linux или другие типы ОС. Хотя Linux используется как среда разработки и как среда для демонстрации концепций операционной системы высокого уровня, эта книга не посвящена ей.</p><p height="1em" width="0pt">Разработка ядра Linux. На эту тему уже опубликовано много качественных книг.</p><p height="1em" width="0pt">Книги по операционным системам, посвященные алгоритмам: это</p><p height="1em" width="0pt">Книга больше фокусируется на реальной аппаратной платформе - Intel x86_64 - и на том, как написать ОС, которая использует поддержку ОС аппаратной платформы.</p><p height="1em" width="0pt"><b>Организация книги</b></p><p height="1em" width="0pt"> <i>Часть 1</i>обеспечивает основу для изучения операционной системы.</p><p height="1em" width="0pt">Глава 1 кратко объясняет важность документов предметной области.</p><p height="1em" width="0pt">Документы имеют решающее значение для обучения, поэтому они заслуживают отдельной главы.</p><p height="1em" width="0pt">В главе 2 объясняются уровни абстракции от аппаратного до программного обеспечения. Идея состоит в том, чтобы дать представление о том, как код работает физически.</p><p height="1em" width="0pt">В главе 3 представлена ​​общая архитектура компьютера, а затем представлена ​​модель компьютера, которую вы будете использовать для написания операционной системы.</p><p height="1em" width="0pt">ви</p><p height="1em" width="0pt">ту, до хоанг</p><p height="1em" width="0pt">Глава 4 знакомит с языком ассемблера x86 с помощью руководств Intel, а также часто используемых инструкций. В этой главе приведены подробные примеры того, как высокоуровневый синтаксис соответствует низкоуровневому ассемблеру, что позволяет удобно читать сгенерированный ассемблерный код. При отладке операционной системы необходимо читать ассемблерный код.</p><p height="1em" width="0pt">Глава 5 подробно анализирует ELF. Только поняв, как устроена программа на бинарном уровне, можно построить программу, работающую на «голом железе».</p><p height="1em" width="0pt">В главе 6 представлен отладчик gdb с подробными примерами часто используемых команд. После ознакомления читателя с gdb он дает представление о том, как работает отладчик. Эти знания необходимы для создания отлаживаемой программы на «голом железе».</p><p height="1em" width="0pt"> <i>Часть 2</i>представляет, как написать загрузчик для начальной загрузки ядра. Отсюда и название<i>«Основы»</i>. Освоив эту часть, читатель может перейти к следующей части, которая представляет собой руководство по написанию операционной системы. Однако, если читателю не нравится презентация, он или она может поискать в другом месте, например, на OSDev Wiki:<a href="http://wiki.osdev.org/">http://wiki.osdev.org/.</a></p><p height="1em" width="0pt">В главе 7 рассказывается, что такое загрузчик, как написать его на ассемблере и как загрузить его в аппаратный эмулятор QEMU. Этот процесс включает в себя ввод повторяющихся и длинных команд, поэтому GNU Make применяется для повышения производительности за счет автоматизации повторяющихся частей и упрощения взаимодействия с проектом. В этой главе также демонстрируется использование GNU Make в контексте.</p><p height="1em" width="0pt">Глава 8 знакомит с компоновкой, объясняя процесс перемещения при объединении объектных файлов. В дополнение к загрузчику и операционной системе, написанной на C, это последняя часть головоломки, необходимая для создания отлаживаемых программ на «голом железе», включая загрузчик, написанный на ассемблере, и операционную систему, написанную на C.</p><p height="1em" width="0pt"> <i>Часть 3</i>содержит руководство по написанию операционной системы, поскольку вы должны реализовать операционную систему самостоятельно и гордиться своим творением. Руководство состоит из более простых и последовательных объяснений необходимых концепций, от аппаратного до программного обеспечения, для реализации</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">VII</p><p height="1em" width="0pt">особенности операционной системы. Без такого руководства вы потратите время на сбор информации, разбросанной по разным документам и Интернету. Затем он предоставляет план того, как сопоставить концепции с кодом.</p><p height="1em" width="0pt"> <i><b>Благодарности</b></i></p><p height="1em" width="0pt">Спасибо, моя любимая семья. Спасибо, соавторы.</p><p height="1em" width="0pt"> <a id="filepos32544" /><b>Часть I</b></p><p height="1em" width="0pt"><b>Предварительный</b></p><p height="1em" width="0pt"> <a id="filepos32647" /><b>1</b></p><p height="1em" width="0pt">Документы домена</p><p height="1em" width="0pt"><b>1.1</b></p><p height="1em" width="0pt"><b>Проблемные области</b></p><p height="1em" width="0pt">В реальном мире разработка программного обеспечения сосредоточена не только на программном обеспечении, но и на проблемной области, которую она пытается решить.</p><p height="1em" width="0pt">А<i>проблемный домен</i>является<i>часть света</i>где компьютер для pro-</p><p height="1em" width="0pt"> <i><b>проблемный домен</b></i></p><p height="1em" width="0pt">производить эффекты вместе со средствами, доступными для их производства, прямо или косвенно.<a href="#filepos805320">(Ковиц, 1999)</a></p><p height="1em" width="0pt">А<i>проблемный домен</i>это что-то помимо программирования, что инженер-программист должен понимать, чтобы создавать правильный код, который может достичь желаемых результатов. «Непосредственно» означает, что оно включает в себя все, чем может управлять программное обеспечение для получения желаемых эффектов, например. клавиатуры, принтеры, мониторы, другое программное обеспечение и т. д. «Косвенно» означает все, что не является частью программного обеспечения, но имеет отношение к проблемной области, например. соответствующие люди, которых программное обеспечение информирует о том, что происходит какое-либо событие, учащиеся, которые переходят в правильные классы в соответствии с расписанием, созданным программным обеспечением. Чтобы написать финансовое приложение, инженеру-программисту необходимо изучить достаточное количество финансовых концепций, чтобы понять<i>требования</i>клиента<b>требования</b></p><p height="1em" width="0pt">и реализовать такие требования правильно.</p><p height="1em" width="0pt">Требования — это эффекты, которые машина должна оказывать в проблемной области в силу своего программирования.</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Программирование само по себе не слишком сложно; программирования для решения проблемной области, это 1. Не только инженер-программист должен понимать, как 1 Мы ссылаемся на концепцию «программирования» здесь как на человека,</p><p height="1em" width="0pt">для реализации программного обеспечения, но и проблемная область, которую он пытается закодировать на языке, но не обязательно</p><p height="1em" width="0pt">знать любую или всю программную инженерию</p><p height="1em" width="0pt">решить, что может потребовать глубоких экспертных знаний. Программное обеспечение en-knowledge.</p><p height="1em" width="0pt">Инженер также должен выбрать правильные методы программирования, применимые к проблемной области, которую он пытается решить, потому что многие методы, которые эффективны в одной области, могут быть неэффективны в другой. Например, многие типы приложений не требуют написания кода с высокой производительностью, а требуют короткого времени для выхода на рынок. В этом случае интерпретируемые языки пользуются широкой популярностью, поскольку могут удовлетворить такую ​​потребность. Однако для написания огромных 3D-игр или операционной системы компилируемые языки являются доминирующими, поскольку они могут генерировать наиболее эффективный код, необходимый для таких приложений.</p><p height="1em" width="0pt">Часто инженеру-программисту слишком сложно изучать нетривиальные области (для понимания предметных областей может потребоваться степень бакалавра или выше). Кроме того, легче для<i>эксперт по предметной области</i>изучить программирование в достаточной степени, чтобы разбить проблемную область на части, достаточно мелкие, чтобы инженеры-программисты могли их реализовать. Иногда эксперты в предметной области сами внедряют программное обеспечение.</p><p height="1em" width="0pt"><b>Рисунок 1.1.1:</b>Проблема</p><p height="1em" width="0pt">домены:</p><p height="1em" width="0pt">Программное и непрограммное.</p><p height="1em" width="0pt">Приложение</p><p height="1em" width="0pt">Непрограммный</p><p height="1em" width="0pt">Программный домен</p><p height="1em" width="0pt">Домен</p><p height="1em" width="0pt">Домены</p><p height="1em" width="0pt">Одним из примеров такого сценария является домен, представленный в этой книге:<i>Операционная система</i>. Для реализации операционной системы требуется определенный объем знаний в области электротехники (EE). Если учебная программа по компьютерным наукам (CS) не включает минимальные курсы EE, учащиеся учебной программы имеют мало шансов внедрить работающую операционную систему. Даже если они могут его реализовать, им либо нужно потратить значительное количество времени на самостоятельное изучение, либо они заполняют код заранее.</p><p height="1em" width="0pt">доменные документы</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">определенная структура только для понимания алгоритмов высокого уровня. По этой причине студентам EE легче внедрить ОС, поскольку им нужно изучить только несколько основных курсов CS. На самом деле, только<i>«Программирование на Си»</i>и</p><p height="1em" width="0pt"> <i>«Алгоритмы и структуры данных»</i>классов обычно достаточно, чтобы начать писать код для драйверов устройств, а затем обобщить его в<i>Операционная система.</i></p><p height="1em" width="0pt"><b>Рисунок 1.1.2:</b>Операционная система</p><p height="1em" width="0pt">домен.</p><p height="1em" width="0pt">Структура данных</p><p height="1em" width="0pt">Операционная</p><p height="1em" width="0pt">Электрический</p><p height="1em" width="0pt">и алгоритмы</p><p height="1em" width="0pt">Система</p><p height="1em" width="0pt">Инжиниринг</p><p height="1em" width="0pt">Следует отметить, что программное обеспечение — это отдельная проблемная область. Проблемная область не обязательно делится между программным обеспечением и самой собой. Компиляторы, 3D-графика, игры, криптография, искусственный интеллект и т. д. являются частью областей разработки программного обеспечения (на самом деле это скорее область компьютерных наук, чем область разработки программного обеспечения). Как правило, программно-эксклюзивный домен создает программное обеспечение, которое будет использоваться другим программным обеспечением. Операционная система также является доменом, но перекрывается с другими доменами, такими как электротехника. Чтобы эффективно внедрить операционную систему, необходимо достаточно изучить внешний домен. Сколько обучения достаточно для инженера-программиста? Как минимум, инженер-программист должен быть достаточно осведомлен, чтобы понимать документы, подготовленные инженерами-железщиками для использования (т.е. программирования) своих устройств.</p><p height="1em" width="0pt">Изучение языка программирования, даже C или ассемблера, не означает, что инженер-программист может автоматически хорошо разбираться в аппаратном программировании или в любых связанных областях низкоуровневого программирования. Можно потратить 10, 20 лет или всю свою жизнь на написание кода на C/C++, и он все равно не сможет написать операционную систему просто из-за незнания соответствующих предметных областей. Так же, как изучение английского языка не означает, что человек автоматически станет хорошо читать книги по математике, написанные на английском языке. Много</p><a id="filepos39218" /><p height="1em" width="0pt">6</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">больше, чем это необходимо. Знания одного-двух языков программирования недостаточно. Если программист зарабатывает на жизнь написанием программного обеспечения, ему лучше специализироваться в одной или двух проблемных областях вне программного обеспечения, если он не хочет, чтобы его работу занимали специалисты в предметной области, изучающие программирование в свободное время.</p><p height="1em" width="0pt"><b>1,2</b></p><p height="1em" width="0pt"><b>Документы для реализации задачи</b></p><p height="1em" width="0pt"><b>основной</b></p><p height="1em" width="0pt">Документы необходимы для изучения проблемной области (и вообще чего угодно), поскольку информацию можно передавать надежным способом. Очевидно, что этот письменный текст использовался на протяжении тысячелетий для передачи знаний из поколения в поколение. Документы являются неотъемлемой частью нетривиальных проектов. Без документов: новым людям будет намного сложнее присоединиться к проекту.</p><p height="1em" width="0pt">Поддерживать проект сложнее, потому что люди могут забыть о важных нерешенных ошибках или странностях в своей системе.</p><p height="1em" width="0pt">Клиентам сложно понять продукт, который они собираются использовать. Однако документы не обязательно должны быть написаны в формате книги. Это может быть что угодно, от формата HTML до формата базы данных, который будет отображаться в графическом пользовательском интерфейсе. Важная информация должна храниться в надежном и легкодоступном месте.</p><p height="1em" width="0pt">Существует много видов документов. Однако для облегчения понимания проблемной области необходимо написать эти два документа:<i>документ с требованиями к программному обеспечению</i>и<i>спецификация программного обеспечения</i>.</p><p height="1em" width="0pt"> <i>1.2.1 Документ с требованиями к программному обеспечению</i></p><p height="1em" width="0pt"> <i>Документ с требованиями к программному обеспечению</i>включает в себя как список требований, так и</p><p height="1em" width="0pt"> <i><b>Требования к программному обеспечению</b></i></p><p height="1em" width="0pt">описание проблемной области<a href="#filepos805320">(Ковиц, 1999).</a></p><p height="1em" width="0pt">Программное обеспечение решает бизнес-задачу. Но, какие проблемы решать, запрашивает заказчик. Многие из этих запросов составляют список требований, которым должно соответствовать наше программное обеспечение. Однако перечисленный список функций редко полезен при поставке программного обеспечения. Как указано в</p><p height="1em" width="0pt">доменные документы</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">В предыдущем разделе сложная часть заключается не только в программировании, но и в программировании в соответствии с проблемной областью. Большая часть разработки и реализации программного обеспечения зависит от знания предметной области. Чем лучше изучена область, тем более качественным может быть программное обеспечение. Например, строительство дома практикуется тысячи лет и хорошо изучено, а построить качественный дом несложно; программное обеспечение ничем не отличается. Трудный для понимания код обычно возникает из-за незнания автором проблемной области. В контексте этой книги мы стремимся понять низкоуровневую работу различных аппаратных устройств.</p><p height="1em" width="0pt">Поскольку качество программного обеспечения зависит от понимания проблемной области, объем документа с требованиями к программному обеспечению должен состоять из описания проблемной области.</p><p height="1em" width="0pt">Имейте в виду, что требования к программному обеспечению не являются:</p><p height="1em" width="0pt"> <i>Что против Как</i>«что» и «как» — неопределенные термины. Что такое «что»?</p><p height="1em" width="0pt">Это только существительные? Если да, то что, если клиент требует, чтобы его программное обеспечение выполняло определенные операции, например процедуру покупки для клиента на веб-сайте. Включает ли он теперь «глаголы»? Однако разве «как» не должно быть пошаговыми операциями? Что угодно может быть «что», и что угодно может быть «как».</p><p height="1em" width="0pt"> <i>Эскизы</i>Документ с требованиями к программному обеспечению полностью посвящен предметной области. Это не должно быть высокоуровневым описанием реализации.</p><p height="1em" width="0pt">Некоторые проблемы могут показаться простыми, если их непосредственно отобразить из описания предметной области в структуру реализации. Например:</p><p height="1em" width="0pt">Пользователям предоставляется список книг в<i><b>выпадающее меню</b></i>выбирать.</p><p height="1em" width="0pt">Книги хранятся в<i><b>связанный список</b></i>».</p><p height="1em" width="0pt">и т. д.</p><p height="1em" width="0pt">В будущем вместо выпадающего меню все книги будут перечислены прямо на странице в миниатюрах. Книги могут быть повторно реализованы в виде графа, и каждый узел представляет собой книгу для поиска связанных книг, так как в следующей версии будет добавлен рекомендатель. Документ с требованиями требует повторного обновления, чтобы удалить все устаревшие детали реализации, поэтому потребовались дополнительные усилия для поддержки документации с требованиями.</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">менте, и когда усилий по синхронизации с реализацией становится слишком много, разработчики отказываются от документации, и все начинают разглагольствовать о бесполезности документации.</p><p height="1em" width="0pt">Чаще всего нет прямого однозначного сопоставления.</p><p height="1em" width="0pt">Например, обычный пользователь компьютера ожидает, что ОС будет чем-то, что запускает какую-то программу с графическим интерфейсом или его любимые компьютерные игры.</p><p height="1em" width="0pt">Но для таких требований операционная система реализована в виде нескольких уровней, каждый из которых скрывает детали от более высоких уровней. Для внедрения операционной системы требуется большой объем знаний из нескольких областей, особенно если операционная система работает не на ПК.</p><p height="1em" width="0pt">устройства.</p><p height="1em" width="0pt">Лучше всего включить информацию, относящуюся к проблемной области, в документ с требованиями. Хороший способ проверить качество документа с требованиями — предоставить его эксперту в предметной области для проверки, чтобы убедиться, что он полностью понимает материал. Документ с требованиями также полезен в качестве справочного документа позже или для более простого написания.</p><p height="1em" width="0pt"> <i>1.2.2 Спецификация программного обеспечения</i></p><p height="1em" width="0pt"> <i>Спецификация программного обеспечения</i>документ устанавливает правила, касающиеся желаемого поведения</p><p height="1em" width="0pt"> <i><b>Спецификация программного обеспечения</b></i></p><p height="1em" width="0pt">устройств вывода ко всему возможному поведению устройств ввода, а также любым правилам, которым должны подчиняться другие части проблемной области.<a href="#filepos805320">.Ковиц</a></p><p height="1em" width="0pt"><a href="#filepos805320">(1999)</a></p><p height="1em" width="0pt">Проще говоря, спецификация программного обеспечения — это дизайн интерфейса с ограничениями для проблемной области, например. программное обеспечение может принимать определенные типы ввода, например, программное обеспечение предназначено для приема английского языка, но не другого языка. Для аппаратного устройства всегда необходима спецификация, поскольку программное обеспечение зависит от его аппаратно запрограммированного поведения. И на самом деле, в большинстве случаев спецификации оборудования четко определены с мельчайшими деталями. Так и должно быть, потому что после того, как оборудование будет физически изготовлено, пути назад уже не будет, а наличие дефектов нанесет компании сокрушительный ущерб как финансам, так и репутации.</p><p height="1em" width="0pt">Обратите внимание, что, как и документ с требованиями, спецификация касается только дизайна интерфейса. Если детали реализации просачиваются, это бремя</p><a id="filepos46844" /><p height="1em" width="0pt">доменные документы</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">для синхронизации между фактической реализацией и спецификацией, и вскоре от нее откажутся.</p><p height="1em" width="0pt">Еще одно важное замечание заключается в том, что, хотя документ спецификации важен, его не обязательно создавать.<i>до</i>реализация.</p><p height="1em" width="0pt">Его можно готовить в любом порядке: до или после полной реализации; либо одновременно с реализацией, когда какая-то часть сделана, и интерфейс готов к записи в спецификацию. Независимо от методов, важна полная спецификация в конце.</p><p height="1em" width="0pt"><b>1,3</b></p><p height="1em" width="0pt"><b>Документы для написания операционной системы x86</b></p><p height="1em" width="0pt">Когда проблемная область отличается от области программного обеспечения, документ требований и спецификация обычно разделены. Однако, если проблемная область находится внутри программного обеспечения, спецификация чаще всего включает и то, и другое, и содержание обоих может смешиваться друг с другом. Как показано в предыдущих разделах, важность документов для реализации ОС нам потребуется собрать соответствующие документы, чтобы получить достаточные знания предметной области.</p><p height="1em" width="0pt">Эти документы следующие:</p><p height="1em" width="0pt">Руководство разработчика программного обеспечения для архитектур Intel® 64 и IA-32 (том 1, 2, 3)</p><p height="1em" width="0pt">Техническое описание семейства наборов микросхем Intel® серии 3 Express</p><p height="1em" width="0pt">Двоичный интерфейс приложения System V</p><p height="1em" width="0pt">Помимо официального веб-сайта Intel, на веб-сайте этой книги для удобства также размещены документы2.</p><p height="1em" width="0pt">2 Intel может изменить ссылки на документацию.</p><p height="1em" width="0pt">менты, когда они обновляют свой веб-сайт,</p><p height="1em" width="0pt">Документы Intel четко разделяют разделы требований и спецификаций, поэтому эта книга не содержит ссылок.</p><p height="1em" width="0pt">к документам, чтобы избежать путаницы</p><p height="1em" width="0pt">но называйте разделы разными именами. Соответствующие читателю refor.</p><p height="1em" width="0pt">документ требования представляет собой раздел, называемый<i>"Функциональное описание"</i>, который состоит в основном из описания домена; для спецификации,<i>«Описание регистра»</i></p><p height="1em" width="0pt">раздел описывает все программные интерфейсы. Оба документа не содержат ненужных деталей реализации3. Документы Intel также великолепны ex-3 Как и должно быть, эти детали</p><p height="1em" width="0pt">Коммерческая тайна.</p><p height="1em" width="0pt">примеры того, как правильно писать требования/спецификации, как описано в этой главе.</p><p height="1em" width="0pt">Помимо документов Intel, другие документы будут представлены в соответствующих главах.</p><p height="1em" width="0pt"> <a id="filepos49797" /><b>2</b></p><p height="1em" width="0pt">От железа к софту:</p><p height="1em" width="0pt">Слои абстракции</p><p height="1em" width="0pt">В этой главе дается интуитивное представление о том, как аппаратное и программное обеспечение связаны друг с другом и как программное обеспечение представлено физически.</p><p height="1em" width="0pt"><b>2.1</b></p><p height="1em" width="0pt"><b>Физическая реализация немного</b></p><p height="1em" width="0pt">Все электронные устройства, от простых до сложных, манипулируют этим потоком для достижения желаемых эффектов в реальном мире. Компьютеры не исключение. Когда<b>Рисунок 2.1.1:</b>Лампочка</p><p height="1em" width="0pt">мы пишем программное обеспечение, мы косвенно манипулируем электрическим током на физическом уровне таким образом, чтобы основная машина производила желаемые эффекты. Чтобы понять процесс, рассмотрим простую лампочку. Лампочка может периодически менять два состояния между включенным и выключенным с помощью переключателя: выключенное означает число 0, а включенное означает 1.</p><p height="1em" width="0pt">Однако одна проблема заключается в том, что такой переключатель требует ручного вмешательства человека. Что требуется, так это автоматический переключатель в зависимости от уровня напряжения, как описано выше. Чтобы включить автоматическое переключение электрических сигналов, устройство, называемое<i>транзистор</i>, изобретенный Уильямом Шокли, Джоном Бардином и Уолтером Браттейном. С этого изобретения началась вся компьютерная индустрия.</p><a id="filepos51195" /><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00229.jpeg" width="422"></img></p><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00237.jpeg" width="422"></img></p><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00215.jpeg" width="422"></img></p><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00213.jpeg" width="422"></img></p><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00207.jpeg" width="422"></img></p><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00241.jpeg" width="422"></img></p><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00232.jpeg" width="422"></img></p><p height="1em" width="0pt"><img align="baseline" height="469" src="Images/image00224.jpeg" width="422"></img></p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">По сути, а<i>транзистор</i>это просто резистор, значения которого могут варьироваться в зависимости от</p><p height="1em" width="0pt"> <i><b>транзистор</b></i></p><p height="1em" width="0pt">на значение входного напряжения.</p><p height="1em" width="0pt"><b>Рисунок 2.1.2:</b>Современный транзистор</p><p height="1em" width="0pt">Благодаря этому свойству транзистор можно использовать в качестве усилителя тока (большее напряжение, меньшее сопротивление) или включать и выключать электрические сигналы (блокировать и разблокировать поток электронов) в зависимости от уровня напряжения. При 0 В ток не может проходить через транзистор, поэтому он действует как цепь с разомкнутым выключателем (лампочка выключена), потому что номинала резистора достаточно, чтобы заблокировать электрический поток. Аналогично при +3,5 В ток может протекать через транзистор be-1 2 3</p><p height="1em" width="0pt">потому что значение резистора уменьшается, эффективно обеспечивает поток электронов, таким образом, действует как цепь с замкнутым переключателем.</p><p height="1em" width="0pt">Если вы хотите глубже</p><p height="1em" width="0pt">объяснение-</p><p height="1em" width="0pt">транзисторы напр.</p><p height="1em" width="0pt">Бит имеет два состояния: 0 и 1, что является строительным блоком всех цифр.</p><p height="1em" width="0pt">электро-</p><p height="1em" width="0pt">из</p><p height="1em" width="0pt">как</p><p height="1em" width="0pt">тальные системы и программное обеспечение. Подобно лампочке, которую можно включить при движении тронов, вы должны посмотреть на</p><p height="1em" width="0pt">и выключается, из этого электрического потока от источника питания делаются биты: видео «Как полупроводники</p><p height="1em" width="0pt">Бит 0 представлен 0 В (нет потока электронов), а бит 1 соответствует +3,5 В для работы» на Youtube, Бен Итер.</p><p height="1em" width="0pt">+5 В (поток электронов). Транзистор реализован немного корректно, так как может регулировать поток электронов в зависимости от уровня напряжения.</p><p height="1em" width="0pt"> <i>2.1.1 МОП-транзисторы</i></p><p height="1em" width="0pt">Изобретенные классические транзисторы открывают совершенно новый мир микроцифровых устройств. До изобретения вакуумные лампы, которые представляют собой просто более причудливые лампочки, использовались для представления 0 и 1, и требовалось, чтобы человек включал и выключал их.<i>МОП-транзистор</i>, или<i><b>М</b></i><i>и другие-</i><i><b>О</b></i><i>ксид–</i><i><b>С</b></i><i>полупроводник</i><i><b>Ф</b></i><i>поле-</i><i><b>Е</b></i><i>оказывать воздействие</i></p><p height="1em" width="0pt"> <i><b>МОП-транзистор</b></i></p><p height="1em" width="0pt"> <i><b>Т</b></i><i>транзистор</i>, изобретенный в 1959 году Давоном Кангом и Мартином М. (Джоном) Аталла в Bell Labs, представляет собой улучшенную версию классических транзисторов, которая больше подходит для цифровых устройств, так как требует более короткого времени переключения между двумя состояниями 0 и 1, более стабильной, потребляет меньше энергии и проще в производстве.</p><p height="1em" width="0pt">Также существует два типа полевых МОП-транзисторов, аналогичных двум типам транзисторов: n-MOSFET и p-MOSFET. n-MOSFET и p-MOSFET также называются транзисторами NMOS и PMOS для краткости.</p><p height="1em" width="0pt"><b>2.2</b></p><p height="1em" width="0pt"><b>Помимо транзисторов: цифровые логические вентили</b></p><p height="1em" width="0pt">Все цифровые устройства имеют логические вентили. А<i>логический вентиль</i>это устройство</p><p height="1em" width="0pt"> <i><b>логический вентиль</b></i></p><p height="1em" width="0pt">который реализует логическую функцию. Каждый логический элемент включает в себя число</p><p height="1em" width="0pt">от аппаратного к программному: уровни абстракции 13</p><p height="1em" width="0pt">входов и выходов. Все компьютерные операции строятся из ком-Рисунок 2.2.1: Пример:</p><p height="1em" width="0pt">И-НЕ</p><p height="1em" width="0pt">бинации логических вентилей, которые представляют собой просто комбинации логических функций.</p><p height="1em" width="0pt">ворота</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt"> <i>2.2.1 Теория логических вентилей</i></p><p height="1em" width="0pt">Б</p><p height="1em" width="0pt">вне</p><p height="1em" width="0pt">Логические вентили принимают только бинарные входы1 и производят бинарные выходы. На входе 1 это либо 0, либо 1.</p><p height="1em" width="0pt">Другими словами, логические вентили — это функции, преобразующие двоичные значения. К счастью, уже существовала область математики, занимающаяся исключительно двоичными значениями.<i>Булева алгебра</i>, разработанный в 19 веке Джорджем Булем.</p><p height="1em" width="0pt">На основе прочной математической теории были созданы логические элементы.<i>.</i>Поскольку логические вентили реализуют булевы функции, набор булевых функций<i>функционально полный</i>, если этот набор может построить все остальные булевы</p><p height="1em" width="0pt"> <i><b>функционально полный</b></i></p><p height="1em" width="0pt">функции могут быть построены из. Позже Чарльз Сандерс Пирс (1880–1881) доказал, что либо булева функция NOR, либо NAND</p><p height="1em" width="0pt">одного достаточно, чтобы создать все остальные функции логической логики. Таким образом, НИ</p><p height="1em" width="0pt">и вентили И-НЕ функционально завершены<a href="#filepos805320">Пирс (1933).</a>Вентиляторы — это просто реализации функций логической логики, поэтому для реализации достаточно вентилей И-НЕ или ИЛИ-НЕ.<i><b>все</b></i>другие логические элементы. Простейшие вентили CMOS-схемы, которые могут быть реализованы, - это инверторы (НЕ вентили), а из инверторов получаются вентили И-НЕ. С вентилями NAND мы уверены, что сможем реализовать все остальное. Вот почему изобретения транзисторов, а затем КМОП-схем произвели революцию в компьютерной индустрии.</p><p height="1em" width="0pt">Если</p><p height="1em" width="0pt">вы хотите</p><p height="1em" width="0pt">понимать</p><p height="1em" width="0pt">почему</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">как</p><p height="1em" width="0pt">из NAND</p><p height="1em" width="0pt">Мы должны осознать и оценить, насколько мощными являются логические функции, через которые мы можем создать все</p><p height="1em" width="0pt">логический</p><p height="1em" width="0pt">доступны на всех языках программирования.</p><p height="1em" width="0pt">функции и</p><p height="1em" width="0pt">компьютер,</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt">предлагать</p><p height="1em" width="0pt">курс<i>Строить</i></p><p height="1em" width="0pt"> <i>а</i></p><p height="1em" width="0pt"> <i>2.2.2 Реализация логического элемента: КМОП-схема</i></p><p height="1em" width="0pt"> <i>СовременныйКомпьютер</i></p><p height="1em" width="0pt"> <i>из первого</i></p><p height="1em" width="0pt">В основе каждого логического элемента лежит схема, называемая<i><b>КМОП</b></i>-<i><b>С</b></i><i>дополнительный</i> <i>Принципы:</i></p><p height="1em" width="0pt"> <i>к</i></p><p height="1em" width="0pt"> <i>От</i></p><p height="1em" width="0pt"> <i>Нанд</i></p><p height="1em" width="0pt"> <i><b>МОС</b></i><i>полевой транзистор</i>. КМОП состоит из двух комплементарных транзисторов,<i>NMOS</i></p><p height="1em" width="0pt"> <i>тетрис</i>доступен на</p><p height="1em" width="0pt">Курсера:</p><p height="1em" width="0pt">и<i>ПМОС.</i>Простейшая КМОП-схема представляет собой инвертор или<i>НЕТ</i>ворота:</p><p height="1em" width="0pt"><a href="https://www.coursera.org/learn/build-a-computer">https://www.coursera.org/</a></p><p height="1em" width="0pt"><a href="https://www.coursera.org/learn/build-a-computer">Изучай/собирай-компьютер.</a></p><p height="1em" width="0pt">Идти</p><p height="1em" width="0pt">Еще больше,</p><p height="1em" width="0pt">после курса,</p><p height="1em" width="0pt">ты</p><p height="1em" width="0pt">должен</p><p height="1em" width="0pt">возьми сериал</p><p height="1em" width="0pt"> <i>Вычислительный</i></p><p height="1em" width="0pt"> <i>Структуры</i>на</p><p height="1em" width="0pt">Эдкс.</p><p height="1em" width="0pt"> <i><b>КМОП</b></i></p><p height="1em" width="0pt"><img align="baseline" height="282" src="Images/image00235.jpeg" width="329"></img></p><p height="1em" width="0pt"><img align="baseline" height="282" src="Images/image00240.jpeg" width="329"></img></p><p height="1em" width="0pt"><img align="baseline" height="348" src="Images/image00210.jpeg" width="400"></img></p><p height="1em" width="0pt"><img align="baseline" height="348" src="Images/image00214.jpeg" width="400"></img></p><p height="1em" width="0pt"><img align="baseline" height="348" src="Images/image00231.jpeg" width="400"></img></p><p height="1em" width="0pt"><img align="baseline" height="348" src="Images/image00212.jpeg" width="400"></img></p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Рисунок 2.2.2:</b>Электронные потоки</p><p height="1em" width="0pt">инвертор.</p><p height="1em" width="0pt">Вход</p><p height="1em" width="0pt">находится слева</p><p height="1em" width="0pt">сторона</p><p height="1em" width="0pt">и вывод с правой стороны.</p><p height="1em" width="0pt">верхний компонент представляет собой PMOS и</p><p height="1em" width="0pt">Нижний</p><p height="1em" width="0pt">компонент представляет собой NMOS,</p><p height="1em" width="0pt">оба подключаются к входу и выходу</p><p height="1em" width="0pt">помещать.</p><p height="1em" width="0pt">(Источник:</p><p height="1em" width="0pt"><a href="http://www.falstad.com/circuit/">Созданный</a></p><p height="1em" width="0pt"><a href="http://www.falstad.com/circuit/">с</a></p><p height="1em" width="0pt"><a href="http://www.falstad.com/circuit/">http:</a></p><p height="1em" width="0pt"><a href="http://www.falstad.com/circuit/">//www.falstad.com/схема/)</a></p><p height="1em" width="0pt"><b>(а)</b>Когда вход низкий</p><p height="1em" width="0pt"><b>(б)</b>Когда вход высокий</p><p height="1em" width="0pt">Из вентиля НЕ можно создать вентиль И-НЕ:</p><p height="1em" width="0pt"><b>Рисунок 2.2.3:</b>Электронные потоки</p><p height="1em" width="0pt">а</p><p height="1em" width="0pt">Ворота И-НЕ.</p><p height="1em" width="0pt"><b>(а)</b>Вход = 00, Выход = 1</p><p height="1em" width="0pt"><b>(б)</b>Вход = 01, Выход = 1</p><p height="1em" width="0pt"><b>(с)</b>Вход = 10, Выход = 1</p><p height="1em" width="0pt"><b>(г)</b>Вход = 11, Выход = 0</p><p height="1em" width="0pt">От ворот И-НЕ у нас есть все остальные ворота. Как показано, такая простая схема выполняет логические операторы в повседневных языках программирования, например. Оператор НЕ ~ выполняется непосредственно схемой инвертора, а оператор & выполняется схемой И и так далее. Код не работает на волшебном черном ящике. В отличие от этого, выполнение кода точное и прозрачное, часто такое же простое, как запуск какой-либо аппаратной схемы. Когда</p><p height="1em" width="0pt"><img align="baseline" height="248" src="Images/image00220.jpeg" width="282"></img></p><p height="1em" width="0pt">от аппаратного к программному: уровни абстракции</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">мы пишем программное обеспечение, мы просто манипулируем электрическим током на физическом уровне, чтобы запускать соответствующие схемы и получать желаемые результаты. Однако весь этот процесс как-то не связан ни с какой мыслью, связанной с электрическим током. Это настоящая магия, и она скоро будет объяснена.</p><p height="1em" width="0pt">Одним интересным свойством CMOS является то, что<i><b>k-входной вентиль использует k PMOS</b></i></p><p height="1em" width="0pt"> <i><b>и k транзисторов NMOS</b></i><a href="#filepos805320">(Уокерли, 1999).</a>Все логические вентили состоят из пар транзисторов NMOS и PMOS, а вентили являются строительными блоками всех цифровых устройств, от простых до сложных, включая любой компьютер. Благодаря этому шаблону можно разделить реальную физическую реализацию схемы и логическую реализацию. Цифровые проекты создаются с помощью логических вентилей, а затем «компилируются» в физические схемы. На самом деле позже мы увидим, что логические вентили становятся языком, описывающим работу схем. Понимание того, как работает CMOS, важно для понимания того, как устроен компьютер и, как следствие, как он работает2.</p><p height="1em" width="0pt">2 Опять же, если вы хотите понять, как</p><p height="1em" width="0pt">логические вентили составляют компьютер, рассмотрим</p><p height="1em" width="0pt">Наконец, реализованная схема с ее проводами и транзисторами хранится в предлагаемых курсах на Coursera и</p><p height="1em" width="0pt">Эдкс ранее.</p><p height="1em" width="0pt">физически в пакете, называемом<i>чип</i>. А<i>чип</i>подложка, на которую вытравливается интегральная схема. Однако чип также относится к полностью<b>Рисунок 2.2.4:</b>Физический вид чипа 74HC00</p><p height="1em" width="0pt">упакованная интегральная схема на потребительском рынке. В зависимости от контекста это понимается по-разному.</p><p height="1em" width="0pt"><b>Пример 2.2.1.</b>74HC00 — это микросхема с четырьмя вентилями И-НЕ с двумя входами. Микросхема имеет 8 входных контактов и 4 выходных контакта, 1 контакт для подключения к источнику напряжения и 1 контакт для подключения к земле. Это устройство является физической реализацией вентилей И-НЕ, к которым мы можем физически прикасаться и использовать. Но вместо одного вентиля в чипе есть 4 вентиля, которые можно комбинировать. Каждая комбинация включает другую логическую функцию, эффективно создавая другие логические элементы. Именно эта особенность делает чип популярным.</p><p height="1em" width="0pt">Каждый из приведенных выше вентилей представляет собой простую схему И-НЕ с электронными потоками, как было продемонстрировано ранее. Тем не менее, из множества этих микросхем NAND-gate можно построить простой компьютер. Программное обеспечение на физическом уровне — это просто потоки электронов.</p><p height="1em" width="0pt"><img align="baseline" height="187" src="Images/image00216.jpeg" width="153"></img></p><p height="1em" width="0pt"><img align="baseline" height="104" src="Images/image00218.jpeg" width="240"></img></p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Рисунок 2.2.5:</b>логика 74HC00</p><p height="1em" width="0pt">диа-</p><p height="1em" width="0pt">грамм (Источник: техническое описание 74HC00,</p><p height="1em" width="0pt"><a href="http://www.scrpdf.com/pdf/Semiconductors_new/Logic/74HCT/74HC_HCT00.pdf">http://www.scrpdf.com/pdf/</a></p><p height="1em" width="0pt"><a href="http://www.scrpdf.com/pdf/Semiconductors_new/Logic/74HCT/74HC_HCT00.pdf">Полупроводники_new/Логика/</a></p><p height="1em" width="0pt"><a href="http://www.scrpdf.com/pdf/Semiconductors_new/Logic/74HCT/74HC_HCT00.pdf">74HCT/74HC_HCT00.pdf)</a></p><p height="1em" width="0pt"><b>(а)</b>Логическая схема 74HC00</p><p height="1em" width="0pt"><b>(б)</b>Логическая схема одного вентиля И-НЕ</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt"><b>Рисунок 2.2.6:</b>Ворота построены</p><p height="1em" width="0pt">от</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">вентили И-НЕ,</p><p height="1em" width="0pt">каждый принимает 2 в-</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">Б</p><p height="1em" width="0pt">ставить сигналы и генерировать 1 выход</p><p height="1em" width="0pt">сигнал.</p><p height="1em" width="0pt"><b>(а)</b>НЕ ворота</p><p height="1em" width="0pt"><b>(б)</b>И ворота</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Б</p><p height="1em" width="0pt">Б</p><p height="1em" width="0pt">Б</p><p height="1em" width="0pt">Б</p><p height="1em" width="0pt"><b>(с)</b>ИЛИ ворота</p><p height="1em" width="0pt"><b>(г)</b>ворота ИЛИ</p><a id="filepos67491" /><p height="1em" width="0pt">от аппаратного к программному: уровни абстракции 17</p><p height="1em" width="0pt">Как можно создать вышеуказанные ворота с помощью 74HC00? Это просто: так как каждый вентиль имеет 2 входных контакта и 1 выходной контакт, мы можем записать выход 1 вентиля И-НЕ на вход другого вентиля И-НЕ, тем самым объединив И-НЕ.</p><p height="1em" width="0pt">ворота вместе, чтобы получить диаграммы, как указано выше.</p><p height="1em" width="0pt"><b>2.3</b></p><p height="1em" width="0pt"><b>Помимо логических ворот: машинный язык</b></p><p height="1em" width="0pt"> <i>2.3.1 Машинный язык</i></p><p height="1em" width="0pt">Будучи построенным на воротах, поскольку ворота принимают только последовательность 0 и 1, аппаратное устройство понимает только 0 и 1. Однако устройство принимает только 0</p><p height="1em" width="0pt">и 1 систематически.<i>Машинный язык</i>представляет собой набор уникальных</p><p height="1em" width="0pt"> <i><b>Машинный язык</b></i></p><p height="1em" width="0pt">битовые шаблоны, которые устройство может идентифицировать и выполнять соответствующее действие. А<i>машинная инструкция</i>представляет собой уникальный битовый шаблон, который может идентифицировать устройство. В компьютерной системе устройство с его языком называется<i><b>Процессор</b></i><i>-</i></p><p height="1em" width="0pt"> <i><b>С</b></i><i>энтеральный</i><i><b>п</b></i><i>обработка</i><i><b>U</b></i><i>гнида</i>, который контролирует все действия внутри компьютера. Например, в архитектуре x86 шаблон 10100000 означает указание ЦП добавить два числа или 000000101 для остановки компьютера. На заре компьютеров людям приходилось писать полностью в двоичном формате.</p><p height="1em" width="0pt">Почему такой битовый шаблон заставляет устройство что-то делать? Причина в том, что в основе каждой инструкции лежит небольшая схема, реализующая инструкцию. Подобно тому, как функция/подпрограмма в компьютерной программе вызывается по имени, битовый шаблон — это имя небольшой функции внутри ЦП, которая выполняется, когда ЦП находит ее.</p><p height="1em" width="0pt">Обратите внимание, что ЦП — не единственное устройство со своим языком. ЦП — это просто имя для обозначения аппаратного устройства, которое управляет компьютерной системой.</p><p height="1em" width="0pt">Аппаратное устройство может не быть ЦП, но все же иметь свой язык. Устройство со своим машинным языком — это<i>программируемое устройство</i>, так как пользователь может использовать язык, чтобы заставить устройство выполнять различные действия.</p><p height="1em" width="0pt">Например, у принтера есть свой набор команд для указания ему, как печатать страницу.</p><a id="filepos69986" /><p height="1em" width="0pt">18</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Пример 2.3.1.</b>Пользователь может пользоваться чипом 74HC00, не зная его внутреннего устройства, а только интерфейс для работы с устройством. Во-первых, нам нужно знать его структуру:</p><p height="1em" width="0pt">1А 1</p><p height="1em" width="0pt">14 В</p><p height="1em" width="0pt"><b>Рисунок 2.3.1:</b>74HC00 Пин</p><p height="1em" width="0pt">копия</p><p height="1em" width="0pt">Компоновка (Источник: техническое описание 74HC00,</p><p height="1em" width="0pt">1Б 2</p><p height="1em" width="0pt">13 4Б</p><p height="1em" width="0pt"><a href="http://www.nxp.com/documents/data_sheet/74HC_HCT00.pdf">http://www.nxp.com/documents/</a></p><p height="1em" width="0pt">1 год 3</p><p height="1em" width="0pt">12 4А</p><p height="1em" width="0pt"><a href="http://www.nxp.com/documents/data_sheet/74HC_HCT00.pdf">data_sheet/74HC_HCT00.pdf)</a></p><p height="1em" width="0pt">2А 4</p><p height="1em" width="0pt">11 4 года</p><p height="1em" width="0pt">2Б 5</p><p height="1em" width="0pt">10 3Б</p><p height="1em" width="0pt">2г 6</p><p height="1em" width="0pt">9 3А</p><p height="1em" width="0pt">Земля 7</p><p height="1em" width="0pt">8 3 года</p><p height="1em" width="0pt">Затем функциональность каждого контакта:</p><p height="1em" width="0pt"><b>Символ</b></p><p height="1em" width="0pt"><b>Приколоть</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt"><b>Таблица 2.3.1:</b>Приколоть</p><p height="1em" width="0pt">Описание</p><p height="1em" width="0pt">от 1А до 4А</p><p height="1em" width="0pt">1, 4, 9, 12</p><p height="1em" width="0pt">ввод данных</p><p height="1em" width="0pt">(Источник:</p><p height="1em" width="0pt">74HC00 даташит,</p><p height="1em" width="0pt">от 1Б до 4Б</p><p height="1em" width="0pt">2, 5, 10, 13</p><p height="1em" width="0pt">ввод данных</p><p height="1em" width="0pt"><a href="http://www.nxp.com/documents/data_sheet/74HC_HCT00.pdf">http://www.nxp.com/documents/</a></p><p height="1em" width="0pt">от 1 до 4 лет</p><p height="1em" width="0pt">3, 6, 8, 11</p><p height="1em" width="0pt">вывод данных</p><p height="1em" width="0pt"><a href="http://www.nxp.com/documents/data_sheet/74HC_HCT00.pdf">data_sheet/74HC_HCT00.pdf)</a></p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">земля (0 В)</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">напряжение питания</p><p height="1em" width="0pt">Наконец, как использовать булавки:</p><p height="1em" width="0pt"><b>Вход</b></p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt"><b>Таблица 2.3.2:</b>Функциональный</p><p height="1em" width="0pt"><b>нА</b></p><p height="1em" width="0pt"><b>нБ</b></p><p height="1em" width="0pt"><b>Нью-Йорк</b></p><p height="1em" width="0pt">Описание</p><p height="1em" width="0pt">л</p><p height="1em" width="0pt">л</p><p height="1em" width="0pt">ЧАС</p><p height="1em" width="0pt">л</p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">ЧАС</p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">л</p><p height="1em" width="0pt">ЧАС</p><p height="1em" width="0pt">ЧАС</p><p height="1em" width="0pt">ЧАС</p><p height="1em" width="0pt">л</p><p height="1em" width="0pt">n - число, либо 1, 2, 3,</p><p height="1em" width="0pt">Функциональное описание предоставляет таблицу истинности со всеми возможными выводами или 4</p><p height="1em" width="0pt">входы и выходы, которые также описывают использование всех контактов на уровне напряжения de-H = HIGH; Л =</p><p height="1em" width="0pt">порок. Пользователю нужно знать не реализацию, а на такой таблице НИЗКИЙ уровень напряжения; Х = нет</p><p height="1em" width="0pt">использовать устройство. Можно сказать, что приведенная выше таблица истинности — это уход за машиной.</p><p height="1em" width="0pt">язык устройства. Поскольку устройство цифровое, его язык представляет собой набор двоичных строк:</p><p height="1em" width="0pt">Устройство имеет 8 входных контактов, а это означает, что оно принимает двоичные строки из 8 бит.</p><p height="1em" width="0pt">от аппаратного к программному: уровни абстракции 19</p><p height="1em" width="0pt">Устройство имеет 4 выходных контакта, а это означает, что оно производит двоичные строки из 4 бит из 8-битных входов.</p><p height="1em" width="0pt">Количество входных строк — это то, что понимает устройство, а количество выходных строк — это то, что устройство может произнести. Вместе они составляют язык устройства. Несмотря на то, что это устройство простое, язык, который он может принять, содержит довольно много двоичных строк: 28 + 24 = 272.</p><p height="1em" width="0pt">Тем не менее, это число является крошечной долей сложного устройства, такого как ЦП, с сотнями контактов.</p><p height="1em" width="0pt">Если оставить как есть, 74HC00 будет просто устройством NAND с двумя 4-битными входами3.</p><p height="1em" width="0pt">3 Или просто 4-битный логический элемент И-НЕ, поскольку он может</p><p height="1em" width="0pt">принимать только 4 бита ввода на макси-</p><p height="1em" width="0pt">Вход</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">мама.</p><p height="1em" width="0pt"><b>Приколоть</b></p><p height="1em" width="0pt"><b>1А</b></p><p height="1em" width="0pt"><b>1Б</b></p><p height="1em" width="0pt"><b>2А</b></p><p height="1em" width="0pt"><b>2Б</b></p><p height="1em" width="0pt"><b>3А</b></p><p height="1em" width="0pt"><b>3Б</b></p><p height="1em" width="0pt"><b>4А</b></p><p height="1em" width="0pt"><b>4Б</b></p><p height="1em" width="0pt"><b>1 год</b></p><p height="1em" width="0pt"><b>2 года</b></p><p height="1em" width="0pt"><b>3 года</b></p><p height="1em" width="0pt"><b>4 года</b></p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Входы и выходы, представленные визуально:</p><p height="1em" width="0pt">1А 1</p><p height="1em" width="0pt">В</p><p height="1em" width="0pt"><b>Рисунок 2.3.2:</b>Пины при получении</p><p height="1em" width="0pt">копия</p><p height="1em" width="0pt">цифровые сигналы, соответствующие</p><p height="1em" width="0pt">1Б 1</p><p height="1em" width="0pt">0 4Б</p><p height="1em" width="0pt">бинарная строка.</p><p height="1em" width="0pt">Зеленые сигналы</p><p height="1em" width="0pt">1Г 0</p><p height="1em" width="0pt">0 4А</p><p height="1em" width="0pt">входы; синие сигналы являются выходами.</p><p height="1em" width="0pt">2А 0</p><p height="1em" width="0pt">1 4 года</p><p height="1em" width="0pt">2Б 0</p><p height="1em" width="0pt">1 3Б</p><p height="1em" width="0pt">2 года 1</p><p height="1em" width="0pt">1 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">0 3 года</p><p height="1em" width="0pt">С другой стороны, если реализован вентиль ИЛИ, мы можем построить вентиль ИЛИ с 2 входами только из 74HC00, так как для этого требуется 3 вентиля И-НЕ: 2 входа И-НЕ</p><p height="1em" width="0pt">вентили и 1 выходной вентиль И-НЕ. Каждый входной вентиль И-НЕ представляет собой только 1-битный вход вентиля ИЛИ. На следующем рисунке выводы каждого входного элемента И-НЕ всегда имеют одинаковые значения (либо оба входа имеют значение A, либо оба входа имеют значение B), чтобы представить однобитовый ввод для окончательного элемента ИЛИ:</p><a id="filepos77431" /><p height="1em" width="0pt">20</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">1А А</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">1Б А</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">С</p><p height="1em" width="0pt">И-НЕ1</p><p height="1em" width="0pt">1Г С</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">2А Б</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">NAND3</p><p height="1em" width="0pt">2Б Б</p><p height="1em" width="0pt">С 3Б</p><p height="1em" width="0pt">2 года Д</p><p height="1em" width="0pt">Д 3А</p><p height="1em" width="0pt">Б</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">NAND2</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Д 3Г</p><p height="1em" width="0pt"><b>(а)</b>2-битная логическая схема вентиля ИЛИ, построенная из 3 NAND</p><p height="1em" width="0pt"><b>(б)</b>Контакты 3A и 3B принимают значения от 1Y и 2Y.</p><p height="1em" width="0pt">ворота с 4 контактами только для 2 битов ввода.</p><p height="1em" width="0pt"><b>Рисунок 2.3.3:</b>2-битная реализация вентиля ИЛИ</p><p height="1em" width="0pt">упоминание</p><p height="1em" width="0pt"><b>Таблица 2.3.3:</b>Правда</p><p height="1em" width="0pt">таблица</p><p height="1em" width="0pt">ИЛИ</p><p height="1em" width="0pt">логическая схема.</p><p height="1em" width="0pt"><b>А</b></p><p height="1em" width="0pt"><b>Б</b></p><p height="1em" width="0pt"><b>С</b></p><p height="1em" width="0pt"><b>Д</b></p><p height="1em" width="0pt"><b>Д</b></p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Для реализации 4-битного вентиля ИЛИ нам потребуется всего четыре микросхемы 74HC00 1.</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">сконфигурированы как вентили ИЛИ, упакованные в виде одного чипа, как показано на рисунке.<a href="#filepos77431">2.3.4.</a></p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt"><b>Рисунок 2.3.4:</b>Изготовлен 4-битный чип ИЛИ</p><p height="1em" width="0pt">1А А1</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">1Б А2</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">от четырех устройств 74HC00</p><p height="1em" width="0pt">1Г С1</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">2А Б1</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2Б В1</p><p height="1em" width="0pt">С1 3Б</p><p height="1em" width="0pt">2 года Д1</p><p height="1em" width="0pt">Д1 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y1 3Y</p><p height="1em" width="0pt">1А А2</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">1Б А2</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">1Г С2</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">2А Б2</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2Б В2</p><p height="1em" width="0pt">С2 3Б</p><p height="1em" width="0pt">2Г Д2</p><p height="1em" width="0pt">Д2 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y2 3Y</p><p height="1em" width="0pt">1А А3</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">1Б А3</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">1Г С3</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">2А Б3</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2Б В3</p><p height="1em" width="0pt">С3 3Б</p><p height="1em" width="0pt">2Г Д3</p><p height="1em" width="0pt">Д3 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y3 3Y</p><p height="1em" width="0pt">1А А4</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">1Б А4</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">1Г С4</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">2А В4</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2Б В4</p><p height="1em" width="0pt">С4 3Б</p><p height="1em" width="0pt">2Г Д4</p><p height="1em" width="0pt">Д4 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y4 3Y</p><a id="filepos82050" /><p height="1em" width="0pt">от аппаратного к программному: уровни абстракции 21</p><p height="1em" width="0pt"> <i>2.3.2 Язык ассемблера</i></p><p height="1em" width="0pt">Язык ассемблера — это символическое представление двоичного машинного кода с помощью мнемонических имен битовых шаблонов. Когда программистам приходилось записывать 0 и 1, это было огромным улучшением. Например, вместо того, чтобы писать 000000101, программист просто писал hlt, чтобы остановить компьютер. Такая абстракция облегчает запоминание инструкций, выполняемых ЦП, и, таким образом, можно запомнить больше инструкций, меньше времени тратится на поиск инструкций по ЦП в битовых формах, и в результате код пишется быстрее.</p><p height="1em" width="0pt">Понимание языка ассемблера имеет решающее значение для областей низкоуровневого программирования даже по сей день. Чем больше инструкций хочет понять программист, тем глубже требуется понимание архитектуры машины.</p><p height="1em" width="0pt"><b>Пример 2.3.2.</b>Мы можем собрать устройство с двумя инструкциями по сборке: или</p><p height="1em" width="0pt"><оп1>, <оп2></p><p height="1em" width="0pt">и <op1>, <op2></p><p height="1em" width="0pt">или принимает два 4-битных операнда. Это соответствует логическому элементу ИЛИ с 4 входами, построенному из 4 микросхем 74HC00.</p><p height="1em" width="0pt">nand принимает два 4-битных операнда. Это соответствует одному 74HC00</p><p height="1em" width="0pt">фишки, оставь как есть.</p><p height="1em" width="0pt">По сути, ворота в примере<a href="#filepos69986">2.3.1</a>выполняет инструкции.</p><p height="1em" width="0pt">До этого момента мы указываем только ввод и вывод и вручную передаем их на устройство. То есть для выполнения операции:</p><p height="1em" width="0pt">Собрать устройство руками.</p><p height="1em" width="0pt">Вручную поместите электрические сигналы на контакты.</p><p height="1em" width="0pt">Во-первых, мы хотим автоматизировать процесс выбора устройства. То есть мы хотим просто написать инструкцию по сборке и устройство, реализующее инструкцию, выбрано правильно. Решить эту проблему просто: дайте каждой инструкции индекс в двоичном коде, называемый<i>код операции</i> <b>Таблица 2.3.4:</b>Инструкция-код операции</p><p height="1em" width="0pt">или<i>код операции</i>для краткости, и вставьте его как часть ввода. Значение для каждого сопоставления.</p><p height="1em" width="0pt">инструкция указана как в таблице<a href="#filepos82050">2.3.4.</a></p><p height="1em" width="0pt"><b>Инструкция</b></p><p height="1em" width="0pt"><b>Бинарный код</b></p><p height="1em" width="0pt">нанд</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">или</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">22</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Каждый ввод теперь содержит в начале дополнительные данные: код операции.</p><p height="1em" width="0pt">Например, инструкция:</p><p height="1em" width="0pt">и 1100, 1100</p><p height="1em" width="0pt">соответствует двоичной строке: 0011001100. Первые два бита 00</p><p height="1em" width="0pt">кодирует инструкцию nand, как указано в таблице выше.</p><p height="1em" width="0pt">Добавьте другое устройство, чтобы выбрать устройство на основе двоичного кода, характерного для инструкции.</p><p height="1em" width="0pt">Такое устройство называется<i>декодер</i>, важный компонент ЦП, который решает, какую схему использовать. В приведенном выше примере при подаче 0011001100</p><p height="1em" width="0pt">декодеру, поскольку код операции равен 00, данные отправляются на устройство NAND для вычислений.</p><p height="1em" width="0pt">Наконец, написание ассемблерного кода — это просто более простой способ написания двоичных строк, понятных устройству. Когда мы пишем ассемблерный код и сохраняем его в текстовом файле, программа, называемая<i>ассемблер</i>переводит текстовый файл</p><p height="1em" width="0pt"> <i><b>ассемблер</b></i></p><p height="1em" width="0pt">в двоичные строки, которые устройство может понять. Итак, как вообще может существовать ассемблер? Предположим, что это первый ассемблер в мире, тогда он написан в двоичном коде. В следующей версии жизнь упрощается: программисты пишут ассемблер в ассемблерном коде, затем используют первую версию для компиляции самого себя. Эти двоичные строки затем сохраняются на другом устройстве, которое позже может быть извлечено и отправлено в декодер. А<i>хранение де-</i></p><p height="1em" width="0pt"> <i><b>накопитель</b></i></p><p height="1em" width="0pt"> <i>порок</i>это устройство, хранящее машинные инструкции, представляющее собой массив схем для сохранения состояний 0 и 1.</p><p height="1em" width="0pt">Декодер построен из логических вентилей, подобных другим цифровым устройствам. Однако запоминающим устройством может быть все, что может хранить 0 и 1 и может быть извлечено. Запоминающее устройство может быть намагниченным устройством, которое использует магнетизм для хранения информации, или оно может состоять из электрических цепей, которые могут изменять и запоминать состояния при приложении напряжения. Независимо от используемой технологии, пока устройство может хранить данные и доступно для извлечения данных, этого достаточно. Действительно, современные устройства настолько сложны, что невозможно и не нужно разбираться во всех деталях реализации. Вместо этого нам нужно только изучить интерфейсы, например. контакты, которые выставляют устройства.</p><p height="1em" width="0pt">от аппаратного к программному: уровни абстракции 23</p><p height="1em" width="0pt">текущая инструкция</p><p height="1em" width="0pt">4-битное ИЛИ</p><p height="1em" width="0pt">Хранилище</p><p height="1em" width="0pt">1А А1</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">получить данные</p><p height="1em" width="0pt">1Б А2</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">0011001100</p><p height="1em" width="0pt">1Г С1</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">0111111111</p><p height="1em" width="0pt">2А Б1</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2Б В1</p><p height="1em" width="0pt">С1 3Б</p><p height="1em" width="0pt">0111101100</p><p height="1em" width="0pt">Декодер</p><p height="1em" width="0pt">2 года Д1</p><p height="1em" width="0pt">Д1 3А</p><p height="1em" width="0pt">0010101110</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y1 3Y</p><p height="1em" width="0pt">....................</p><p height="1em" width="0pt">....................</p><p height="1em" width="0pt">....................</p><p height="1em" width="0pt">1А А2</p><p height="1em" width="0pt">Вкк</p><p height="1em" width="0pt">1Б А2</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">1Г С2</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">2А Б2</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2Б В2</p><p height="1em" width="0pt">С2 3Б</p><p height="1em" width="0pt">2Г Д2</p><p height="1em" width="0pt">Д2 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y2 3Y</p><p height="1em" width="0pt">1А А3</p><p height="1em" width="0pt">В</p><p height="1em" width="0pt">отправить данные</p><p height="1em" width="0pt">копия</p><p height="1em" width="0pt">1Б А3</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">1Г С3</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">2А Б3</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2Б В3</p><p height="1em" width="0pt">С3 3Б</p><p height="1em" width="0pt">2Г Д3</p><p height="1em" width="0pt">Д3 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y3 3Y</p><p height="1em" width="0pt">1А А4</p><p height="1em" width="0pt">В</p><p height="1em" width="0pt">1А 1</p><p height="1em" width="0pt">В</p><p height="1em" width="0pt">копия</p><p height="1em" width="0pt">копия</p><p height="1em" width="0pt">1Б А4</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">1Б 1</p><p height="1em" width="0pt">0 4Б</p><p height="1em" width="0pt">1Г С4</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">1Г 0</p><p height="1em" width="0pt">0 4А</p><p height="1em" width="0pt">2А В4</p><p height="1em" width="0pt">4 года</p><p height="1em" width="0pt">2А 0</p><p height="1em" width="0pt">1 4 года</p><p height="1em" width="0pt">4-битный И-НЕ</p><p height="1em" width="0pt">2Б В4</p><p height="1em" width="0pt">С4 3Б</p><p height="1em" width="0pt">2Б 0</p><p height="1em" width="0pt">1 3Б</p><p height="1em" width="0pt">2Г Д4</p><p height="1em" width="0pt">Д4 3А</p><p height="1em" width="0pt">2 года 1</p><p height="1em" width="0pt">1 3А</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">Y4 3Y</p><p height="1em" width="0pt">ЗАЗЕМЛЕНИЕ</p><p height="1em" width="0pt">0 3 года</p><p height="1em" width="0pt"><b>Рисунок 2.3.5:</b>Декодер извлекает</p><p height="1em" width="0pt">Компьютер по существу реализует этот процесс:</p><p height="1em" width="0pt">текущая инструкция, указанная</p><p height="1em" width="0pt">стрелка и</p><p height="1em" width="0pt">выбирает И-НЕ</p><p height="1em" width="0pt">устройство для выполнения инструкции nand-</p><p height="1em" width="0pt"> <i>Принести</i>инструкция с запоминающего устройства.</p><p height="1em" width="0pt">ция.</p><p height="1em" width="0pt"> <i>Расшифровать</i>Инструкция.</p><p height="1em" width="0pt"> <i>Выполнять</i>Инструкция.</p><p height="1em" width="0pt">Или, короче, цикл выборка — декодирование — выполнение. Вышеприведенное устройство крайне рудиментарно, но уже представляет собой компьютер с<i>принести</i>–<i>декодировать</i></p><p height="1em" width="0pt">–<i>выполнять</i>цикл. Дополнительные инструкции можно реализовать, добавив больше устройств и выделив больше кодов операций для инструкций, а затем соответствующим образом обновив декодер. Управляющий компьютер Apollo, цифровой компьютер, созданный для космической программы Apollo с 1961 по 1972 год, был полностью построен с вентилями NOR — альтернативой вентилям NAND для создания</p><p height="1em" width="0pt">24</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">другие логические элементы. Точно так же, если мы продолжим улучшать наше гипотетическое устройство, оно в конечном итоге станет полноценным компьютером.</p><p height="1em" width="0pt"> <i>2.3.3 Языки программирования</i></p><p height="1em" width="0pt">Язык ассемблера — это шаг вперед по сравнению с записью 0 и 1. Со временем люди поняли, что многие фрагменты ассемблерного кода имеют повторяющиеся шаблоны использования. Было бы неплохо, если бы вместо того, чтобы писать все повторяющиеся блоки кода заново во всех местах, мы просто ссылались бы на такие блоки кода с помощью более простых в использовании текстовых форм. Например, блок кода на ассемблере проверяет, больше ли одна переменная, чем другая, и если да, то выполняется блок кода, в противном случае выполняется другой блок кода; в C такой блок ассемблерного кода представлен оператором if, близким к человеческому языку.</p><p height="1em" width="0pt">source1.asm</p><p height="1em" width="0pt"><b>Рисунок 2.3.6:</b>Повторная сборка</p><p height="1em" width="0pt">если (...) {</p><p height="1em" width="0pt">.......</p><p height="1em" width="0pt">шаблоны обобщаются в новый</p><p height="1em" width="0pt">} еще {</p><p height="1em" width="0pt">язык.</p><p height="1em" width="0pt">.......</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">.................</p><p height="1em" width="0pt">source2.asm</p><p height="1em" width="0pt">.................</p><p height="1em" width="0pt">.................</p><p height="1em" width="0pt">источник<n>.asm</p><p height="1em" width="0pt">Люди создали текстовые формы для представления общих блоков ассемблерного кода, таких как приведенный выше синтаксис if, а затем написали программу для перевода текстовых форм в ассемблерный код. Программа, переводящая такие текстовые формы в машинный код, называется<i>компилятор</i>:</p><p height="1em" width="0pt"> <i><b>компилятор</b></i></p><p height="1em" width="0pt">Любая программная логика, которую может реализовать язык программирования, аппаратная</p><p height="1em" width="0pt">от железа к ПО: уровни абстракции 25</p><p height="1em" width="0pt">если (аргумент) {</p><p height="1em" width="0pt">cmp DWORD PTR [ebp+0x8],0x0</p><p height="1em" width="0pt">je 80483f7 <main+0x1c></p><p height="1em" width="0pt">я = 1;</p><p height="1em" width="0pt">mov DWORD PTR [ebp-0x4],0x1</p><p height="1em" width="0pt">} еще {</p><p height="1em" width="0pt">Компилятор</p><p height="1em" width="0pt">jmp 80483fe <main+0x23></p><p height="1em" width="0pt">mov DWORD PTR [ebp-0x4],0x0</p><p height="1em" width="0pt">я = 0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>Рисунок 2.3.7:</b>Из лан-</p><p height="1em" width="0pt">вернуться к низкоуровневому языку.</p><p height="1em" width="0pt">также может реализовать. Верно и обратное: любая аппаратная логика, реализованная в схеме, может быть повторно реализована на языке программирования. Простая причина в том, что языки программирования, или языки ассемблера, или машинные языки, или логические вентили — это всего лишь языки для выражения вычислений. Программное обеспечение не может реализовать то, на что не способно аппаратное обеспечение, потому что язык программирования — это просто более простой способ использования базового оборудования. В конце концов, языки программирования транслируются в машинные инструкции, которые действительны для процессора. В противном случае код не запускается, поэтому программное обеспечение бесполезно. И наоборот, программное обеспечение может делать все, что может аппаратное обеспечение (которое запускает программное обеспечение), поскольку языки программирования — это просто более простой способ использования аппаратного обеспечения.</p><p height="1em" width="0pt">В действительности, хотя все языки эквивалентны по мощности, не все из них способны выражать программы друг друга. Языки программирования различаются между двумя концами спектра: высоким уровнем и низким уровнем.</p><p height="1em" width="0pt">Чем выше уровень языка программирования, тем дальше он от аппаратного обеспечения. В некоторых высокоуровневых языках программирования, таких как Python, программист не может манипулировать базовым оборудованием, несмотря на то, что может выполнять те же вычисления, что и низкоуровневые языки программирования. Причина в том, что языки высокого уровня хотят скрыть детали аппаратного обеспечения, чтобы освободить программистов от работы с ненужными деталями, не относящимися к текущим проблемным областям. Такое удобство, однако, не является бесплатным: оно требует, чтобы программное обеспечение содержало дополнительный код для управления деталями оборудования (например, памятью), что замедляет работу кода и делает аппаратное программирование трудным или невозможным. Чем больше абстракций накладывает язык программирования, тем сложнее писать низкоуровневое программное обеспечение, такое как драйверы оборудования или операционная система. По этой причине язык C обычно выбирают для написания операционной системы, поскольку C — это всего лишь тонкая оболочка базового оборудования,</p><a id="filepos96782" /><p height="1em" width="0pt">26</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">легко понять, как именно работает аппаратное устройство при выполнении определенного фрагмента кода C.</p><p height="1em" width="0pt">Каждый язык программирования представляет собой способ мышления о программах. Языки программирования более высокого уровня помогают сосредоточиться на проблемных областях, которые вообще не связаны с аппаратным обеспечением и где производительность программиста важнее, чем производительность компьютера. Языки программирования более низкого уровня помогают сосредоточиться на внутренней работе машины, поэтому они лучше всего подходят для проблемных областей, связанных с аппаратным обеспечением управления. Вот почему существует так много языков. Используйте правильные инструменты для правильной работы, чтобы достичь наилучших результатов.</p><p height="1em" width="0pt"><b>2,4</b></p><p height="1em" width="0pt"><b>Абстракция</b></p><p height="1em" width="0pt"> <i>Абстракция</i>это метод сокрытия сложности, которая не имеет отношения к проблеме в контексте. Например, написание программ без какого-либо другого уровня, кроме самого нижнего уровня: со схемами. Человеку нужно не только глубокое понимание того, как работают схемы, что делает проектирование схемы гораздо более неясным, потому что разработчик должен смотреть на необработанные схемы, но думать на более высоком уровне, таком как логические вентили. Это отвлекающий процесс, так как дизайнер должен постоянно воплощать идею в схемы. Это возможно, когда дизайнер просто обдумывает свои высокоуровневые идеи, а затем воплощает их в схемы. Это не только более эффективно, но и более точно, поскольку дизайнер может сосредоточить все свои усилия на проверке проекта с высокоуровневым мышлением. Когда приходит новый дизайнер, он может легко понять проекты высокого уровня, поэтому может продолжать разрабатывать или поддерживать существующие системы.</p><p height="1em" width="0pt"> <i>2.4.1 Почему абстракция работает</i></p><p height="1em" width="0pt">Во всех слоях проявляются абстракции:</p><p height="1em" width="0pt">Логические вентили абстрагируются от деталей CMOS.</p><p height="1em" width="0pt">Машинный язык абстрагируется от деталей логических вентилей.</p><p height="1em" width="0pt">Язык ассемблера абстрагируется от деталей машинных языков.</p><p height="1em" width="0pt">Язык программирования абстрагируется от деталей языков ассемблера.</p><p height="1em" width="0pt">от аппаратного к программному: уровни абстракции 27</p><p height="1em" width="0pt">Мы видим повторяющиеся паттерны того, как нижние слои строят верхние: Нижний слой имеет повторяющийся паттерн. Затем этот повторяющийся шаблон удаляется и на его основе строится язык.</p><p height="1em" width="0pt">Более высокий уровень удаляет характерные для слоя (неповторяющиеся) детали, чтобы сосредоточиться на повторяющихся деталях.</p><p height="1em" width="0pt">Повторяющиеся детали даются новым и более простым языком, чем языки нижних слоев.</p><p height="1em" width="0pt">Что нужно понимать, так это то, что каждый слой просто<i>более удобный язык для</i></p><p height="1em" width="0pt"> <i><b>описывать</b></i><i>нижний слой</i>. Только после того, как описание будет полностью создано на языке более высокого уровня, оно будет<i>реализовано</i>с языком нижнего слоя.</p><p height="1em" width="0pt">Уровень CMOS имеет повторяющийся шаблон, который обеспечивает надежную трансляцию логических элементов в схемы CMOS:<i><b>k-входной вентиль использует k PMOS</b></i></p><p height="1em" width="0pt"> <i><b>и k транзисторов NMOS</b></i><a href="#filepos805320">(Уокерли, 1999).</a>Поскольку в цифровых устройствах используется исключительно КМОП, возник язык для описания идей более высокого уровня при сокрытии КМОП-схем: логические вентили.</p><p height="1em" width="0pt">Logic Gates скрывает язык схем и фокусируется на том, как реализовать примитивные логические функции и комбинировать их для создания новых функций. Все логические вентили получают ввод и генерируют вывод в виде двоичных чисел. Благодаря этим повторяющимся шаблонам логические вентили скрыты для нового языка: ассемблера, который представляет собой набор предопределенных двоичных шаблонов, заставляющих базовые вентили выполнять действие.</p><p height="1em" width="0pt">Вскоре люди поняли, что многие повторяющиеся шаблоны возникают внутри языка ассемблера. Повторяющиеся блоки кода ассемблера появляются в исходных файлах ассемблера, которые выражают одну и ту же или похожую идею. Было много таких идей, которые можно надежно воплотить в ассемблерный код. Таким образом, были извлечены идеи для встраивания в языки программирования высокого уровня, которые сегодня изучает каждый программист.</p><p height="1em" width="0pt">Повторяющиеся паттерны — ключ к абстракции. Повторяющиеся шаблоны — вот почему абстракция работает. Без них язык не может быть построен, и поэтому</p><p height="1em" width="0pt">28</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">никакой абстракции. К счастью, человечество уже разработало систематическую дисциплину для изучения закономерностей: математику. Цитата из британского математика Г. Х. Харди<a href="#filepos805320">(2005):</a></p><p height="1em" width="0pt">Математик, как художник или поэт, создает узоры. Если его узоры более постоянны, чем их, то это потому, что они сделаны из идей.</p><p height="1em" width="0pt">Разве это не математическая формула, представляющая закономерность? Переменная представляет значения с теми же свойствами, которые заданы ограничениями? Математика предоставляет формальную систему для выявления и описания существующих закономерностей в природе. По этой причине эту систему, безусловно, можно применять в цифровом мире, который является лишь подмножеством реального мира. Математику можно использовать как общий язык, чтобы облегчить перевод между слоями и помочь в понимании слоев.</p><p height="1em" width="0pt">Язык программирования</p><p height="1em" width="0pt">Язык ассемблера</p><p height="1em" width="0pt">Математика</p><p height="1em" width="0pt">Проблемная область</p><p height="1em" width="0pt">Логические ворота</p><p height="1em" width="0pt">Схема</p><p height="1em" width="0pt"><b>Рисунок 2.4.1:</b>Математика как</p><p height="1em" width="0pt">универсальный язык для</p><p height="1em" width="0pt">все слои.</p><p height="1em" width="0pt">Поскольку все слои могут выражать математические</p><p height="1em" width="0pt"> <i>2.4.2 Почему абстракция снижает сложность</i></p><p height="1em" width="0pt">матика со своими технологиями, каждый</p><p height="1em" width="0pt">Абстракция за счет построения языка, безусловно, повышает производительность за счет того, что полосовой слой может быть переведен на другой язык.</p><p height="1em" width="0pt">слой.</p><p height="1em" width="0pt">пинговать не относящиеся к проблеме детали. Представьте, что вы пишете программы без какого-либо другого макета, кроме самого нижнего уровня: со схемами. Вот как возникает сложность: когда идеи высокого уровня выражаются языком более низкого уровня, как показано в приведенном выше примере. К сожалению, так обстоит дело с программным обеспечением, поскольку в настоящее время языки программирования больше внимания уделяют программному обеспечению, а не предметным областям. То есть без предварительных знаний код, написанный на языке, не может выразить знание своего целевого домена. Другими словами,<i>язык является выразительным, если его синтаксис предназначен для выражения проблемной области, которую он пытается решить</i>. Рассмотрим этот пример: то есть<i>что</i>скорее подойдет</p><p height="1em" width="0pt">от железа к ПО: уровни абстракции 29</p><p height="1em" width="0pt">в<i>как</i>это будет сделать.</p><p height="1em" width="0pt"><b>Пример 2.4.1.</b>Графвиз<a href="http://www.graphviz.org/">(http://www.graphviz.org/)</a>— это программное обеспечение для визуализации, которое предоставляет язык, называемый точкой, для описания графа:</p><p height="1em" width="0pt">орграф {</p><p height="1em" width="0pt">а -> б;</p><p height="1em" width="0pt">б -> в;</p><p height="1em" width="0pt">а -> в;</p><p height="1em" width="0pt">б</p><p height="1em" width="0pt">д</p><p height="1em" width="0pt">г -> в;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">с</p><p height="1em" width="0pt"><b>Рисунок 2.4.2:</b>Из описания графика-</p><p height="1em" width="0pt">Как видно, код отлично выражает то, как граф соединяется с графом.</p><p height="1em" width="0pt">связанный. Даже непрограммист может легко понять и использовать такой язык. Реализация на C была бы более проблематичной, и это при условии, что функции для рисования графиков уже доступны. Чтобы нарисовать линию, в C мы могли бы написать что-то вроде: draw_line(a, b);</p><p height="1em" width="0pt">Тем не менее, он все еще многословен по сравнению с:</p><p height="1em" width="0pt">а -> б;</p><p height="1em" width="0pt">Кроме того, a и b должны быть определены в C по сравнению с неявными узлами в точечном языке. Однако, если не учитывать многословие, то C</p><p height="1em" width="0pt">все еще имеет ограничение: он не может изменить свой синтаксис в соответствии с проблемной областью. Язык предметной области может быть даже более подробным, но он делает предметную область более понятной. Если проблемная область должна быть выражена в C, то это ограничение синтаксисом C. Поскольку C не является</p><p height="1em" width="0pt">30</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">специализированный язык для предметной области, который, но является<i>общее назначение</i>язык программирования, знание предметной области скрыто в деталях реализации. В результате для расшифровки и извлечения знаний предметной области требуется программист на C. Если знание предметной области не может быть извлечено, то дальнейшее развитие программного обеспечения невозможно.</p><p height="1em" width="0pt"><b>Пример 2.4.2.</b>В Linux полно приложений, управляемых многими предметно-ориентированными языками, которые размещаются в каталоге /etc, например веб-сервер.</p><p height="1em" width="0pt">Вместо того, чтобы перепрограммировать программное обеспечение, для него создается язык, не зависящий от предметной области.</p><p height="1em" width="0pt">В общем, код, который может выражать проблемную область, должен быть понятен эксперту в предметной области. Даже в области программного обеспечения полезно создавать язык из повторяющихся шаблонов программирования. Это помогает людям узнать о существовании таких шаблонов в коде и, таким образом, упрощает поддержку программного обеспечения, поскольку структура программного обеспечения видна как язык. Только язык программирования, способный трансформироваться в соответствии с проблемной областью, может достичь этой цели. Такой язык называется<i>программируемый</i> <i>язык программирования</i>. К сожалению, такой подход к тому, чтобы сделать структуру программного обеспечения видимой, не нравится программистам, поскольку для его поддержки необходимо создать новый язык вместе с новым набором инструментов. Таким образом, структура программного обеспечения и знание предметной области скрыты внутри кода, написанного на синтаксисе языка общего назначения, и если программист не знаком или даже не знает о существовании шаблона кода, то понять код безнадежно. . Ярким примером является чтение кода C, который управляет оборудованием, например. операционная система: если программист абсолютно ничего не знает об оборудовании, то он не сможет читать и писать код операционной системы на C, даже если бы у него было 20 лет написания кода приложений на C.</p><p height="1em" width="0pt">С помощью абстракции инженер-программист также может понять внутреннюю работу устройства без специальных знаний о проектировании физических схем, что позволяет инженеру-программисту писать код, управляющий устройством.</p><p height="1em" width="0pt">Разделение между логической и физической реализацией также влечет за собой возможность повторного использования конструкций вентилей, даже если базовые технологии</p><p height="1em" width="0pt">от аппаратного к программному обеспечению: уровни абстракции 31</p><p height="1em" width="0pt">измененный. Например, в далеком будущем биологический компьютер может стать реальностью, а гейты могут быть реализованы не в виде CMOS, а в виде каких-то биологических клеток, например. как живые клетки; в любой технологии: электрической или биологической, до тех пор, пока логические вентили реализованы физически, может быть реализован один и тот же компьютерный дизайн.</p><p height="1em" width="0pt"> <a id="filepos108871" /><b>3</b></p><p height="1em" width="0pt">Компьютерная архитектура</p><p height="1em" width="0pt">Чтобы писать код более низкого уровня, программист должен понимать архитектуру компьютера. Это похоже на то, как когда кто-то пишет программы в программной среде, он должен знать, какие проблемы решает среда, и как использовать структуру с помощью предоставляемых ею программных интерфейсов.</p><p height="1em" width="0pt">Но прежде чем перейти к определению того, что такое компьютерная архитектура, мы должны понять, что именно представляет собой компьютер, поскольку многие до сих пор думают, что компьютер — это обычный компьютер, который мы ставим на стол, или, в лучшем случае, сервер.</p><p height="1em" width="0pt">Компьютеры бывают разных форм и размеров и представляют собой устройства, о которых люди никогда не думают, что они компьютеры, и этот код может работать на таких устройствах.</p><p height="1em" width="0pt"><b>3.1</b></p><p height="1em" width="0pt"><b>Что такое компьютер?</b></p><p height="1em" width="0pt">А<i>компьютер</i>аппаратное устройство, состоящее как минимум из процессора (CPU),<i><b>компьютер</b></i></p><p height="1em" width="0pt">запоминающее устройство и интерфейсы ввода/вывода. Все компьютеры можно разделить на два типа:</p><p height="1em" width="0pt"> <i>Одноцелевой компьютер</i>это компьютер, созданный в<i>аппаратный уровень</i>для конкретных задач. Например, специальные кодировщики/декодеры приложений, таймеры, процессоры изображений/видео/звука.</p><p height="1em" width="0pt"> <i>Компьютер общего назначения</i>это компьютер, который можно запрограммировать (без модификации его аппаратного обеспечения) для эмуляции различных функций одноцелевого</p><p height="1em" width="0pt"><img align="baseline" height="683" src="Images/image00238.jpeg" width="1024"></img></p><p height="1em" width="0pt"><img align="baseline" height="256" src="Images/image00226.jpeg" width="256"></img></p><p height="1em" width="0pt"><img align="baseline" height="256" src="Images/image00208.jpeg" width="256"></img></p><p height="1em" width="0pt"><img align="baseline" height="256" src="Images/image00209.jpeg" width="256"></img></p><p height="1em" width="0pt"><img align="baseline" height="256" src="Images/image00222.jpeg" width="256"></img></p><p height="1em" width="0pt"><img align="baseline" height="256" src="Images/image00228.jpeg" width="256"></img></p><p height="1em" width="0pt"><img align="baseline" height="256" src="Images/image00225.jpeg" width="256"></img></p><p height="1em" width="0pt"><img align="baseline" height="256" src="Images/image00227.jpeg" width="256"></img></p><p height="1em" width="0pt">34</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">компьютеры.</p><p height="1em" width="0pt"> <i>3.1.1 Сервер</i></p><p height="1em" width="0pt">А<i>сервер</i>представляет собой универсальный высокопроизводительный компьютер с огромным</p><p height="1em" width="0pt"> <i><b>сервер</b></i></p><p height="1em" width="0pt">источники для предоставления масштабных услуг для широкой аудитории. Аудитория — люди, персональные компьютеры которых подключены к серверу.</p><p height="1em" width="0pt"><b>Рисунок 3.1.1:</b>Блейд-серверы. Каждый</p><p height="1em" width="0pt">блейд-сервер — это компьютер с</p><p height="1em" width="0pt">модульная конструкция оптимизирует использование</p><p height="1em" width="0pt">физического пространства и энергии.</p><p height="1em" width="0pt">Корпус блейд-серверов называется</p><p height="1em" width="0pt"> <i>шасси</i>.(Источник:<a href="https://commons.wikimedia.org/wiki/File:Wikimedia_Foundation_Servers-8055_35.jpg">Викимедиа,</a>автор: Викторгригас)</p><p height="1em" width="0pt"> <i>3.1.2 Настольный компьютер</i></p><p height="1em" width="0pt">А<i>настольный компьютер</i>представляет собой универсальный компьютер с входом и выходом.</p><p height="1em" width="0pt"> <i><b>настольный компьютер</b></i></p><p height="1em" width="0pt">поставить систему, предназначенную для пользователя-человека, с умеренными ресурсами, достаточными для регулярного использования. Система ввода обычно включает в себя мышь и клавиатуру, а система вывода обычно состоит из монитора, который может отображать большое количество пикселей. Компьютер заключен в корпус, достаточно большой для размещения различных компонентов компьютера, таких как процессор, материнская плата, блок питания, жесткий диск и т. д.</p><p height="1em" width="0pt"><b>Рисунок 3.1.2:</b>Типичный</p><p height="1em" width="0pt">рабочий стол</p><p height="1em" width="0pt">компьютер.</p><p height="1em" width="0pt"><img align="baseline" height="252" src="Images/image00233.jpeg" width="512"></img></p><p height="1em" width="0pt"><img align="baseline" height="336" src="Images/image00236.jpeg" width="512"></img></p><p height="1em" width="0pt"><img align="baseline" height="124" src="Images/image00217.jpeg" width="256"></img></p><p height="1em" width="0pt">компьютерная архитектура</p><p height="1em" width="0pt">35</p><p height="1em" width="0pt"> <i>3.1.3 Мобильный компьютер</i></p><p height="1em" width="0pt">А<i>мобильный компьютер</i>похож на настольный компьютер с меньшим количеством ресурсов</p><p height="1em" width="0pt"> <i><b>мобильный компьютер</b></i></p><p height="1em" width="0pt">но можно носить с собой.</p><p height="1em" width="0pt"><b>Рисунок 3.1.3:</b>Мобильные компьютеры</p><p height="1em" width="0pt"><b>(а)</b>Ноутбук</p><p height="1em" width="0pt"><b>(б)</b>Планшет</p><p height="1em" width="0pt"><b>(с)</b>А</p><p height="1em" width="0pt">мобильный</p><p height="1em" width="0pt">телефон</p><p height="1em" width="0pt"> <i>3.1.4 Игровые приставки</i></p><p height="1em" width="0pt">Игровые приставки похожи на настольные компьютеры, но оптимизированы для игр. Вместо клавиатуры и мыши системой ввода игровой консоли являются игровые контроллеры, представляющие собой устройства с несколькими кнопками для управления экранными объектами; выходная система - телевизор. Корпус похож на настольный компьютер, но меньше. В игровых консолях используются специальные процессоры и графические процессоры, но они аналогичны тем, что используются в настольных компьютерах. Например, в первом Xbox используется специальный процессор Intel Pentium III.</p><p height="1em" width="0pt"><b>(а)</b>Игровая приставка 4</p><p height="1em" width="0pt"><b>(б)</b>Xbox One</p><p height="1em" width="0pt"><b>(с)</b>Wii U</p><p height="1em" width="0pt"><b>Рисунок 3.1.4:</b>Текущее поколение</p><p height="1em" width="0pt">Игра</p><p height="1em" width="0pt">Портативные игровые приставки аналогичны игровым приставкам, но включают консоли.</p><p height="1em" width="0pt">обе системы ввода и вывода вместе с компьютером в одном корпусе.</p><p height="1em" width="0pt"><img align="baseline" height="96" src="Images/image00221.jpeg" width="128"></img></p><p height="1em" width="0pt"><img align="baseline" height="195" src="Images/image00211.jpeg" width="320"></img></p><p height="1em" width="0pt"><img align="baseline" height="253" src="Images/image00219.jpeg" width="256"></img></p><p height="1em" width="0pt"><img align="baseline" height="149" src="Images/image00223.jpeg" width="300"></img></p><p height="1em" width="0pt"><img align="baseline" height="150" src="Images/image00242.jpeg" width="128"></img></p><p height="1em" width="0pt">36</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Рисунок 3.1.5:</b>Некоторые портативные</p><p height="1em" width="0pt">Консоли</p><p height="1em" width="0pt"><b>(а)</b>Нинтендо ДС</p><p height="1em" width="0pt"><b>(б)</b>ПС Вита</p><p height="1em" width="0pt"> <i>3.1.5 Встроенный компьютер</i></p><p height="1em" width="0pt">Ан<i>Встраиваемый компьютер</i>представляет собой одноплатный или однокристальный компьютер с</p><p height="1em" width="0pt"> <i><b>Встраиваемый компьютер</b></i></p><p height="1em" width="0pt">ресурсы, предназначенные для интеграции в более крупные аппаратные устройства.</p><p height="1em" width="0pt"><b>Рисунок 3.1.6:</b>АнИнтел</p><p height="1em" width="0pt">82815</p><p height="1em" width="0pt">Графический контроллер и контроллер памяти</p><p height="1em" width="0pt">А<i>микроконтроллер</i>представляет собой встроенный компьютер, предназначенный для управления Hub</p><p height="1em" width="0pt">встроенный</p><p height="1em" width="0pt">на компе мать-</p><p height="1em" width="0pt">другие аппаратные устройства. Микроконтроллер смонтирован на микросхеме. Плата микроконтроллеров. (Источник:<a href="https://commons.wikimedia.org/wiki/File:Intel_82815_GMCH.jpg">Викимедиа,</a>автор: есть компы общего назначения, но с ограниченными ресурсами так что это куррен)</p><p height="1em" width="0pt">способны выполнять только одну или несколько специализированных задач. Эти компьютеры используются для одной цели, но они по-прежнему универсальны, поскольку их можно запрограммировать для выполнения различных задач, в зависимости от требований, без изменения базового оборудования.</p><p height="1em" width="0pt">Другой тип встроенного компьютера<i>система на кристалле</i>. А<i>система на кристалле</i>это полноценный компьютер на одном чипе. Хотя микроконтроллер размещен на чипе, его назначение другое: управлять некоторыми аппаратными средствами. Микроконтроллер обычно проще и более ограничен в аппаратных ресурсах, т.к.<b>Рисунок 3.1.7:</b>PIC-микрокон-он специализируется только на одной цели при работе, тогда как системный-контроллер. (Источник:<a href="http://www.microchip.com/wwwproducts/en/PIC18F4620">Микрочип)</a></p><p height="1em" width="0pt">чип — это компьютер общего назначения, который может служить нескольким целям. Система на кристалле может работать как обычный настольный компьютер, способный загружать операционную систему и запускать различные приложения. Система на кристалле обычно присутствует в смартфоне, таком как Apple A5 SoC.</p><p height="1em" width="0pt"> <i><b>микроконтроллер</b></i></p><p height="1em" width="0pt">в Ipad2 и iPhone 4S или Qualcomm Snapdragon, используемом во многих телефонах Android.</p><p height="1em" width="0pt"><b>Рисунок 3.1.8:</b>Apple A5 SoC</p><p height="1em" width="0pt">Будь то микроконтроллер или система на кристалле, должна быть среда, в которой эти устройства могут подключаться к другим устройствам. Эта среда представляет собой печатную плату, называемую<i>печатная плата</i>–<i><b>п</b></i><i>печатный</i><i><b>С</b></i><i>схема</i><i><b>Б</b></i><i>весло.</i>А<i>печатная плата</i>представляет собой физическую плату, которая содержит линии и контактные площадки для обеспечения потоков электронов между электрическими и электронными компонентами. Без печатной платы устройства не могут быть объединены для создания более крупного устройства. Пока эти</p><p height="1em" width="0pt"><img align="baseline" height="2143" src="Images/image00239.jpeg" width="3208"></img></p><p height="1em" width="0pt">компьютерная архитектура</p><p height="1em" width="0pt">37</p><p height="1em" width="0pt">устройства скрыты внутри более крупного устройства и вносят вклад в более крупное устройство, которое работает на уровне более высокого уровня для целей более высокого уровня, они являются встроенными устройствами. Поэтому написание программы для встроенного устройства называется<i>встроенное программирование</i>. Встроенные компьютеры используются в автоматически управляемых устройствах, включая электроинструменты, игрушки, имплантируемые медицинские устройства, офисные машины, системы управления двигателем, бытовую технику, пульты дистанционного управления и другие типы встроенных систем.</p><p height="1em" width="0pt">40 контактов: 28x GPIO, I2C, SPI, UART</p><p height="1em" width="0pt"><b>с'ДЕЛ</b>р</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt"><b>с</b></p><p height="1em" width="0pt">PW</p><p height="1em" width="0pt"><b>2x USB 2.0</b></p><p height="1em" width="0pt"><b>ута</b>Т</p><p height="1em" width="0pt"><b>т</b></p><p height="1em" width="0pt">С</p><p height="1em" width="0pt"><b>Модель Raspberry Pi B+ V1.2</b></p><p height="1em" width="0pt"><b>С</b></p><p height="1em" width="0pt">А</p><p height="1em" width="0pt"><b>НУ (С) Raspberry Pi 2014</b></p><p height="1em" width="0pt"><b>р</b></p><p height="1em" width="0pt"><b>е</b></p><p height="1em" width="0pt">я</p><p height="1em" width="0pt"><b>4x USB +</b></p><p height="1em" width="0pt"><b>ЦП/ГП</b></p><p height="1em" width="0pt"><b>т д</b></p><p height="1em" width="0pt">С</p><p height="1em" width="0pt"><b>Ethernet</b></p><p height="1em" width="0pt"><b>контроллер</b></p><p height="1em" width="0pt"><b>о я</b></p><p height="1em" width="0pt"><b>л с</b></p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt"><b>Бродком</b></p><p height="1em" width="0pt"><b>с</b></p><p height="1em" width="0pt"><b>LAN9514</b></p><p height="1em" width="0pt"><b>м</b></p><p height="1em" width="0pt"><b>Делать</b></p><p height="1em" width="0pt"><b>2x USB 2.0</b></p><p height="1em" width="0pt"><b>BCM2835</b></p><p height="1em" width="0pt"><b>С т</b></p><p height="1em" width="0pt"><b>о т</b></p><p height="1em" width="0pt">класть</p><p height="1em" width="0pt"><b>р о</b></p><p height="1em" width="0pt"><b>512 МБ SDRAM</b></p><p height="1em" width="0pt"><b>с б</b></p><p height="1em" width="0pt"><b>я н</b></p><p height="1em" width="0pt">провайдер</p><p height="1em" width="0pt"><b>о</b></p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt">текущий</p><p height="1em" width="0pt">HDMI</p><p height="1em" width="0pt">С</p><p height="1em" width="0pt">3,3 В</p><p height="1em" width="0pt">ограничитель</p><p height="1em" width="0pt">&</p><p height="1em" width="0pt">С</p><p height="1em" width="0pt">1,8 В</p><p height="1em" width="0pt">Регулятор</p><p height="1em" width="0pt">защита от полярности</p><p height="1em" width="0pt">Ethernet</p><p height="1em" width="0pt">ра</p><p height="1em" width="0pt"><b>т</b></p><p height="1em" width="0pt"><b>о</b></p><p height="1em" width="0pt">е</p><p height="1em" width="0pt"><b>ты э</b></p><p height="1em" width="0pt"><b>я</b></p><p height="1em" width="0pt">RJ45</p><p height="1em" width="0pt"><b>о т</b></p><p height="1em" width="0pt"><b>дю</b></p><p height="1em" width="0pt">м</p><p height="1em" width="0pt"><b>я</b></p><p height="1em" width="0pt"><b>а</b></p><p height="1em" width="0pt"><b>РС</b></p><p height="1em" width="0pt"><b>+</b></p><p height="1em" width="0pt">а</p><p height="1em" width="0pt"><b>м о</b></p><p height="1em" width="0pt"><b>о</b></p><p height="1em" width="0pt"><b>5</b></p><p height="1em" width="0pt"><b>Микро</b></p><p height="1em" width="0pt"><b>п</b></p><p height="1em" width="0pt"><b>е</b></p><p height="1em" width="0pt">власть</p><p height="1em" width="0pt">С</p><p height="1em" width="0pt"><b>.</b></p><p height="1em" width="0pt"><b>д</b></p><p height="1em" width="0pt">хороший</p><p height="1em" width="0pt"><b>3 месяца</b></p><p height="1em" width="0pt"><b>я</b></p><p height="1em" width="0pt">Выход HDMI</p><p height="1em" width="0pt"><b>С</b></p><p height="1em" width="0pt"><b>В</b></p><p height="1em" width="0pt"><b>USB</b></p><p height="1em" width="0pt">Ethernet</p><p height="1em" width="0pt"><b>Мощность в</b></p><p height="1em" width="0pt">4-полюсный разъем</p><p height="1em" width="0pt"><b>(а)</b>Функциональный вид.</p><p height="1em" width="0pt"><b>(б)</b>Физический</p><p height="1em" width="0pt">SoC — Broadcom BCM2835.</p><p height="1em" width="0pt">Вид</p><p height="1em" width="0pt">Микроконтроллером является контроллер Ethernet LAN9514.</p><p height="1em" width="0pt">(Источник:<a href="https://commons.wikimedia.org/wiki/File:Raspberry_Pi_B%2B_rev_1.2.svg">Викимедиа,</a>автор: Efa2)<b>Рисунок 3.1.9:</b>Малина</p><p height="1em" width="0pt">Пи</p><p height="1em" width="0pt">В+</p><p height="1em" width="0pt">Грань между микроконтроллером и системой на кристалле размыта. Если Rev 1.2, одноплатный компьютер</p><p height="1em" width="0pt">который включает в себя как систему на кристалле</p><p height="1em" width="0pt">аппаратное обеспечение продолжает развиваться более мощное, тогда микроконтроллер может получить и микроконтроллер.</p><p height="1em" width="0pt">достаточно ресурсов, чтобы запустить на нем минимальную операционную систему для множества специализированных целей. Напротив, система на кристалле достаточно мощна, чтобы справиться с работой микроконтроллера. Однако использование системы на кристалле в качестве микроконтроллера было бы неразумным выбором, поскольку цена значительно возрастет, но мы также тратим впустую аппаратные ресурсы, поскольку программное обеспечение, написанное для микроконтроллера, требует небольших вычислительных ресурсов.</p><p height="1em" width="0pt"> <i>3.1.6 Программируемый массив Field Gate</i></p><p height="1em" width="0pt"> <i>Программируемая пользователем вентильная матрица</i>(<i>ПЛИС</i>) представляет собой аппаратный массив ре-</p><p height="1em" width="0pt"> <i><b>Программируемые ворота</b></i></p><p height="1em" width="0pt">настраиваемые вентили, которые делают структуру схемы программируемой после нее</p><p height="1em" width="0pt"> <i><b>Множество</b></i></p><p height="1em" width="0pt">отгружается с завода1. Напомним, что в предыдущей главе 1 Вот почему это называется<i><b>Поле</b></i>Программируемый массив вентилей. Это изменчиво</p><p height="1em" width="0pt">каждая микросхема 74HC00 может быть сконфигурирована как гейт, а более навороченная</p><p height="1em" width="0pt">«в поле», где оно применяется.</p><p height="1em" width="0pt">Устройство может быть построено путем объединения нескольких микросхем 74HC00. В подобном</p><p height="1em" width="0pt"><img align="baseline" height="212" src="Images/image00230.jpeg" width="400"></img></p><p height="1em" width="0pt">38</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Таким образом, каждое устройство FPGA содержит тысячи микросхем, называемых<i>логические блоки</i>, который является более сложной микросхемой, чем микросхема 74HC00, которую можно настроить для реализации функции булевой логики. Эти логические блоки могут быть объединены в цепочку для создания высокоуровневой аппаратной функции. Эта высокоуровневая функция обычно представляет собой специальный алгоритм, требующий высокоскоростной обработки.</p><p height="1em" width="0pt"><b>Рисунок 3.1.10:</b>ПЛИС</p><p height="1em" width="0pt">Архитектура (Источник:</p><p height="1em" width="0pt"><a href="http://www.ni.com/tutorial/6097/en/">Национальный</a></p><p height="1em" width="0pt"><a href="http://www.ni.com/tutorial/6097/en/">Инструменты)</a></p><p height="1em" width="0pt">Цифровые устройства могут быть разработаны путем объединения логических элементов без учета реальных компонентов схемы, поскольку физические схемы представляют собой просто кратные схемы КМОП. Цифровое оборудование, в том числе различные компоненты компьютера, разрабатывается путем написания кода, как обычный программист, с использованием языка, описывающего, как вентили соединяются вместе. Этот язык называется<i>Язык описания оборудования</i>. Позже описание аппаратного обеспечения компилируется в описание подключенных электронных компонентов, называемых<i>список соединений</i>, который является более подробным описанием того, как связаны вентили.</p><p height="1em" width="0pt">Разница между FPGA и другими встроенными компьютерами заключается в том, что программы в FPGA реализованы на уровне цифровой логики, тогда как программы во встроенных компьютерах, таких как микроконтроллеры или устройства на кристалле, реализованы на уровне ассемблерного кода. Алгоритм, написанный для устройства FPGA, представляет собой описание алгоритма в логических элементах, которым затем устройство FPGA следует по описанию, чтобы настроить себя для запуска алгоритма. Алгоритм, написанный для микроконтроллера, находится в инструкциях по сборке, которые процессор может понять и действовать соответственно.</p><p height="1em" width="0pt">FPGA применяется в тех случаях, когда специализированные операции неприемлемы и дорогостоящи для выполнения на обычном компьютере, например, обработка медицинских изображений в реальном времени, система круиз-контроля, прототипирование схем, обработка видео.</p><a id="filepos127840" /><p height="1em" width="0pt">компьютерная архитектура</p><p height="1em" width="0pt">39</p><p height="1em" width="0pt">кодирование/декодирование и т. д. Эти приложения требуют высокоскоростной обработки, недостижимой для обычного процессора, поскольку процессор тратит значительное количество времени на выполнение множества неспециализированных инструкций, которые могут составлять до тысяч инструкций и более, чтобы реализовать специализированную операцию, таким образом, больше схем на физическом уровне для выполнения одной и той же операции. Устройство FPGA не несет таких накладных расходов; вместо этого он выполняет одну специализированную операцию, реализованную непосредственно в аппаратном обеспечении.</p><p height="1em" width="0pt"> <i>3.1.7 Специализированная интегральная схема</i></p><p height="1em" width="0pt">Ан<i><b>А</b></i><i>приложение-</i><i><b>С</b></i><i>конкретный</i><i><b>я</b></i><i>интегрированный</i><i><b>С</b></i><i>схема</i>(или<i>ASIC</i>) — это чип, предназначенный для конкретной цели, а не для общего использования. ASIC не содержит общего массива логических блоков, которые можно переконфигурировать для адаптации к любой операции, такой как FPGA; вместо этого каждый логический блок в ASIC создается и оптимизируется для самой схемы. FPGA можно рассматривать как этап прототипирования ASIC, а ASIC — как завершающий этап производства схемы. ASIC еще более специализирован, чем FPGA, поэтому может достигать еще более высокой производительности. Тем не менее, ASIC очень дороги в производстве, и после изготовления схемы, если случаются ошибки проектирования, все выбрасывается, в отличие от устройств FPGA, которые можно просто перепрограммировать из-за универсальной вентильной матрицы.</p><p height="1em" width="0pt"><b>3.2</b></p><p height="1em" width="0pt"><b>Компьютерная архитектура</b></p><p height="1em" width="0pt">В предыдущем разделе были рассмотрены различные классы компьютеров. Независимо от формы и размера, каждый компьютер предназначен для архитектора от высокого до низкого уровня.</p><p height="1em" width="0pt"> <i>Компьютерная архитектура</i>"="<i>Архитектура набора инструкций</i>+<i>Компьютерная организация</i>+<i>Аппаратное обеспечение</i>На самом высоком уровне находится архитектура набора инструкций.</p><p height="1em" width="0pt">На среднем уровне находится компьютерная организация.</p><p height="1em" width="0pt">На самом низком уровне находится аппаратное обеспечение.</p><p height="1em" width="0pt">40</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>3.2.1 Архитектура набора инструкций</i></p><p height="1em" width="0pt">Ан<i>Набор инструкций</i>это основной набор команд и инструкций, которые микропроцессор понимает и может выполнять.</p><p height="1em" width="0pt">Ан<i><b>я</b></i><i>инструкция</i><i><b>С</b></i><i>эт</i><i><b>А</b></i><i>архитектура</i>, или<i><b>ЭТО</b></i>, — это дизайн среды, реализующей набор инструкций. По сути, среда выполнения похожа на интерпретаторы языков высокого уровня. Проект включает в себя все инструкции, регистры, прерывания, модели памяти (как память устроена для использования программами), режимы адресации, ввод-вывод и т. д. ЦП. Чем больше функций (например, больше инструкций) имеет ЦП, тем больше схем требуется для его реализации.</p><p height="1em" width="0pt"> <i>3.2.2 Компьютерная организация</i></p><p height="1em" width="0pt"> <i>Компьютерная организация</i>это функциональный взгляд на конструкцию компьютера.</p><p height="1em" width="0pt"> <i><b>Компьютерная организация</b></i></p><p height="1em" width="0pt">В этом представлении аппаратные компоненты компьютера представлены в виде блоков с входом и выходом, которые соединяются друг с другом и формируют дизайн компьютера. Два компьютера могут иметь одну и ту же ISA, но разные организации. Например, процессоры AMD и Intel реализуют x86.</p><p height="1em" width="0pt">ISA, но аппаратные компоненты каждого процессора, составляющие среду для ISA, не одинаковы.</p><p height="1em" width="0pt">Компьютерные организации могут различаться в зависимости от конструкции производителя, но все они основаны на архитектуре фон Неймана2: 2<i>Джон фон Нейман</i>математик и физик, изобрел</p><p height="1em" width="0pt">компьютерная архитектура.</p><p height="1em" width="0pt">Процессор</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt">Вход и</p><p height="1em" width="0pt"><b>Рисунок 3.2.1:</b>Фон-Нейман</p><p height="1em" width="0pt">Выход</p><p height="1em" width="0pt">Архитектура</p><p height="1em" width="0pt">Шина управления</p><p height="1em" width="0pt">Адресная шина</p><p height="1em" width="0pt">Шина данных</p><p height="1em" width="0pt">системная шина</p><p height="1em" width="0pt"> <i>Процессор</i>непрерывно извлекает инструкции из основной памяти и выполняет.</p><p height="1em" width="0pt">компьютерная архитектура</p><p height="1em" width="0pt">41</p><p height="1em" width="0pt"> <i>Память</i>хранит программный код и данные.</p><p height="1em" width="0pt"> <i>Автобус</i>представляют собой электрические провода для передачи сырых битов между вышеуказанными компонентами.</p><p height="1em" width="0pt"> <i>Устройства ввода/вывода</i>- это устройства, которые вводят данные в компьютер, например, клавиатуру, мышь, датчик и т. д., и получают выходные данные от компьютера, т. е. монитор принимает информацию, отправленную ЦП, для ее отображения, светодиод включается/выключается в соответствии с шаблоном, вычисленным ЦП, и т. д.</p><p height="1em" width="0pt">Компьютер фон-Неймана работает, сохраняя свои инструкции в основной памяти, а ЦП многократно извлекает эти инструкции во внутреннюю память для выполнения, одну за другой. Данные передаются по шине данных между ЦП, памятью и устройствами ввода-вывода, а места для хранения в устройствах передаются по адресной шине ЦП. Эта архитектура полностью реализует<i>выборка — декодирование — выполнение</i>цикл.</p><p height="1em" width="0pt">Более ранние компьютеры были просто точной реализацией архитектуры фон Неймана, где ЦП, память и устройства ввода-вывода обменивались данными через одну и ту же шину. Сегодня в компьютере больше шин, каждая из которых специализирована для определенного типа трафика. Однако по своей сути они по-прежнему являются архитектурой фон Неймана. Чтобы написать ОС для компьютера фон Неймана, программист должен уметь понимать и писать код, управляющий основными компонентами: процессором, памятью, устройствами ввода-вывода и шиной.</p><p height="1em" width="0pt"> <i><b>Процессор</b></i>, или<i><b>С</b></i><i>энтеральный</i><i><b>п</b></i><i>обработка</i><i><b>U</b></i><i>гнида</i>, является сердцем и мозгом любой компьютерной системы. Поймите, что ЦП необходим для написания ОС с нуля: чтобы использовать эти устройства, программист должен управлять ЦП, чтобы использовать программные интерфейсы других устройств. ЦП — это единственный способ, так как ЦП — это единственное прямое устройство, которое может использовать программист, и единственное устройство, которое понимает код, написанный программистом.</p><p height="1em" width="0pt">В ЦП многие концепции ОС уже реализованы непосредственно в аппаратном обеспечении, например. переключение задач, пейджинг. Программист ядра должен знать, как использовать аппаратные функции, чтобы избежать дублирования такой концепции в программном обеспечении, что приводит к пустой трате ресурсов компьютера.</p><p height="1em" width="0pt">Встроенные в ЦП функции ОС повышают как производительность ОС, так и производительность разработчиков, поскольку эти функции представляют собой реальное оборудование, самый низкий возможный уровень, и разработчики могут свободно реализовывать такие функции.</p><p height="1em" width="0pt">42</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Чтобы эффективно использовать ЦП, программист должен понимать документацию, предоставленную производителем ЦП. Например,<a href="[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel®</a></p><p height="1em" width="0pt"><a href="[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Руководства разработчика программного обеспечения для архитектур 64 и IA-32.</a></p><p height="1em" width="0pt">Хорошо поняв архитектуру одного ЦП, легче изучить другие архитектуры ЦП.</p><p height="1em" width="0pt">ЦП — это реализация ISA, фактически реализация языка ассемблера (и в зависимости от архитектуры ЦП язык может различаться). Язык ассемблера — это один из интерфейсов, который предоставляется инженерам-программистам для управления процессором, то есть для управления компьютером.</p><p height="1em" width="0pt">Но как можно управлять каждым компьютерным устройством, имея доступ только к центральному процессору? Простой ответ заключается в том, что ЦП может связываться с другими устройствами через эти два интерфейса, управляя ими: Регистры — это аппаратный компонент для высокоскоростного доступа к данным и связи.</p><p height="1em" width="0pt"> <i><b>Регистры</b></i></p><p height="1em" width="0pt">связь с другими аппаратными устройствами. Регистры позволяют программному обеспечению напрямую управлять аппаратным обеспечением путем записи в регистры устройства или получать информацию от аппаратного устройства при чтении из регистров устройства.</p><p height="1em" width="0pt">Не все регистры используются для связи с другими устройствами. В ЦП большинство регистров используются в качестве высокоскоростного хранилища для временных данных. Другие устройства, с которыми ЦП может взаимодействовать, всегда имеют набор регистров для взаимодействия с ЦП.</p><p height="1em" width="0pt">Порт — это специализированный регистр в аппаратном устройстве, используемом для связи.</p><p height="1em" width="0pt"> <i><b>Порт</b></i></p><p height="1em" width="0pt">с другими устройствами. Когда данные записываются в порт, аппаратное устройство выполняет некоторую операцию в соответствии со значениями, записанными в порт. Разница между портом и регистром заключается в том, что порт не хранит данные, а делегирует данные какой-либо другой схеме.</p><p height="1em" width="0pt">Эти два интерфейса чрезвычайно важны, поскольку они являются единственными интерфейсами для управления оборудованием с помощью программного обеспечения. Написание драйверов устройств — это, по сути, изучение функциональности каждого регистра и того, как правильно их использовать для управления устройством.</p><p height="1em" width="0pt"> <i>Память</i>это запоминающее устройство, которое хранит информацию. Память состоит</p><p height="1em" width="0pt"> <i><b>Память</b></i></p><p height="1em" width="0pt">из многих клеток. Каждая ячейка представляет собой байт со своим номером адреса, поэтому ЦП может</p><p height="1em" width="0pt">компьютерная архитектура</p><p height="1em" width="0pt">43</p><p height="1em" width="0pt">используйте такой номер адреса для доступа к точному местоположению в памяти. Память — это место, где программные инструкции (в форме машинного языка) хранятся и извлекаются для выполнения ЦП; память также хранит данные, необходимые некоторым программам. Память в машине фон Неймана не различает, какие байты являются данными, а какие байтами являются программными инструкциями. Это зависит от программного обеспечения, и если каким-то образом байты данных извлекаются и выполняются как инструкции, ЦП все равно делает это, если такие байты представляют действительные инструкции, но это приведет к нежелательным результатам. Для процессора нет кода и данных; оба являются просто разными типами данных, с которыми он может действовать: один говорит ему, как делать что-то определенным образом, а другой является необходимым материалом для выполнения такого действия.</p><p height="1em" width="0pt">Оперативная память управляется устройством, называемым<i>контроллер памяти</i>. В настоящее время это устройство встроено в большинство процессоров, поэтому ЦП имеет выделенную шину памяти, соединяющую процессор с ОЗУ. На более старых ЦП3, как-3 до ЦП, выпущенных в 2009 г.</p><p height="1em" width="0pt">когда-либо это устройство было расположено в чипе, также известном как<b>МЧ</b>или<i><b>М</b></i><i>Эмори</i></p><p height="1em" width="0pt"> <i><b>С</b></i><i>контроллер</i><i><b>ЧАС</b></i><i>уб</i>. В этом случае ЦП взаимодействует не напрямую с ОЗУ, а с микросхемой MCH, и эта микросхема затем обращается к памяти для чтения или записи данных. Первый вариант обеспечивает лучшую производительность, так как в обмене данными между ЦП нет посредника.</p><p height="1em" width="0pt">и память.</p><p height="1em" width="0pt">Системная шина</p><p height="1em" width="0pt">Системная шина</p><p height="1em" width="0pt">Контроль</p><p height="1em" width="0pt">Контроль</p><p height="1em" width="0pt">Процессор</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">МЧ</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt">Данные</p><p height="1em" width="0pt">Данные</p><p height="1em" width="0pt">МЧ</p><p height="1em" width="0pt">Процессор</p><p height="1em" width="0pt"><b>(а)</b>Старый процессор</p><p height="1em" width="0pt"><b>(б)</b>Современный процессор</p><p height="1em" width="0pt"><b>Рисунок 3.2.2:</b>ЦП - Память</p><p height="1em" width="0pt">На физическом уровне оперативная память реализована в виде сетки ячеек, которые каждая связь</p><p height="1em" width="0pt">содержат транзистор и электрическое устройство, называемое<i>конденсатор</i>, который хранит</p><p height="1em" width="0pt"> <i><b>конденсатор</b></i></p><p height="1em" width="0pt">заряжать на короткие промежутки времени. Транзистор управляет доступом к конденсатору; при включении он позволяет считывать или записывать на конденсатор небольшой заряд. Заряд на конденсаторе медленно рассеивается,</p><a id="filepos140936" /><p height="1em" width="0pt">44</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">требующие включения схемы обновления для периодического считывания значений из ячеек и записи их обратно после усиления от внешнего источника питания.</p><p height="1em" width="0pt"> <i>Автобус</i>это подсистема, которая передает данные между компонентами компьютера</p><p height="1em" width="0pt"> <i><b>Автобус</b></i></p><p height="1em" width="0pt">или между компьютерами. Физически шины — это просто электрические провода, которые соединяют все компоненты вместе, и каждый провод передает один большой блок данных. Общее количество проводов называется<i>ширина шины</i>, и зависит</p><p height="1em" width="0pt"> <i><b>ширина шины</b></i></p><p height="1em" width="0pt">от того, сколько проводов может поддерживать ЦП. Если ЦП может принимать только 16</p><p height="1em" width="0pt">бит за раз, тогда шина имеет 16 проводов, соединяющих компонент с ЦП, что означает, что ЦП может получать только 16 бит данных за раз.</p><p height="1em" width="0pt"> <i>3.2.3 Аппаратное обеспечение</i></p><p height="1em" width="0pt">Аппаратное обеспечение — это конкретная реализация компьютера. Линия процессоров реализует одну и ту же архитектуру набора команд и использует почти идентичные организации, но различается аппаратной реализацией. Например, семейство Core i7 представляет собой модель для настольных компьютеров, которая является более мощной, но потребляет больше энергии, а другая модель для ноутбуков менее производительна, но более энергоэффективна. Чтобы написать программное обеспечение для аппаратного устройства, нам редко нужно понимать аппаратную реализацию, если доступны документы. Организация компьютера и особенно архитектура набора команд более важны для программиста операционной системы. По этой причине следующая глава посвящена изучению архитектуры x86.</p><p height="1em" width="0pt">архитектура набора команд в деталях.</p><p height="1em" width="0pt"><b>3.3</b></p><p height="1em" width="0pt"><b>архитектура x86</b></p><p height="1em" width="0pt">А<i>чипсет</i>это чип с несколькими функциями. Исторически сложилось так, что набор микросхем фактически представляет собой набор отдельных микросхем, каждая из которых отвечает за определенную функцию, например.</p><p height="1em" width="0pt">контроллер памяти, графические контроллеры, сетевой контроллер, контроллер питания и т. д. По мере развития аппаратного обеспечения набор микросхем был объединен в одну микросхему, что обеспечило больше места, энергии и экономичности. В настольном компьютере различные аппаратные устройства соединены друг с другом через печатную плату, называемую<i>материнская плата</i>. Для каждого процессора требуется совместимая материнская плата, на которой он может размещаться. Каждая материнская плата определяется моделью чипсета, которая</p><p height="1em" width="0pt">компьютерная архитектура</p><p height="1em" width="0pt">45</p><p height="1em" width="0pt">определяют среду, которой ЦП может управлять. Эта среда обычно состоит из</p><p height="1em" width="0pt">слот или более для процессора</p><p height="1em" width="0pt">набор микросхем из двух микросхем, которые являются микросхемами северного и южного мостов.</p><p height="1em" width="0pt"><b>–</b>Чип северного моста отвечает за высокопроизводительную связь между ЦП, оперативной памятью и графической картой.</p><p height="1em" width="0pt"><b>–</b>Микросхема южного моста отвечает за связь с вводом-выводом.</p><p height="1em" width="0pt">устройства и другие устройства, которые не чувствительны к производительности.</p><p height="1em" width="0pt">слоты для карт памяти</p><p height="1em" width="0pt">слот или более для графических карт.</p><p height="1em" width="0pt">общие слоты для других устройств, например. сетевая карта, звуковая карта.</p><p height="1em" width="0pt">порты для устройств ввода-вывода, например. клавиатура, мышь, USB.</p><p height="1em" width="0pt">Чтобы написать полную операционную систему, программист должен понимать, как программировать эти устройства. В конце концов, операционная система автоматически управляет аппаратным обеспечением, освобождая при этом прикладные программы. Однако из всех компонентов обучение программированию ЦП является наиболее важным, поскольку это компонент, присутствующий в любом компьютере, независимо от его типа. По этой причине основное внимание в этой книге будет уделено тому, как программировать процессор x86. Даже сосредоточившись исключительно на этом устройстве, можно написать достаточно хорошую минимальную операционную систему. Причина в том, что не все компьютеры включают в себя все устройства, как в обычном настольном компьютере. Например, встроенный компьютер может иметь только ЦП.</p><p height="1em" width="0pt">и ограниченная внутренняя память с контактами для ввода и вывода; тем не менее, операционные системы были написаны для таких устройств.</p><p height="1em" width="0pt">Тем не менее, научиться программировать процессор x86 — сложная задача, для которой написано 3 основных руководства: почти 500 страниц для тома 1, более 2000 страниц для тома 2 и более 1000 страниц для тома 3. Это впечатляющий подвиг для программист, чтобы освоить все аспекты программирования процессоров x86.</p><a id="filepos145827" /><p height="1em" width="0pt">46</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Рисунок 3.3.1:</b>Материнская плата</p><p height="1em" width="0pt">зация</p><p height="1em" width="0pt">Процессор</p><p height="1em" width="0pt">Часы</p><p height="1em" width="0pt">Графика</p><p height="1em" width="0pt">Лицевая сторона</p><p height="1em" width="0pt">Генератор</p><p height="1em" width="0pt">разъем для карты</p><p height="1em" width="0pt">автобус</p><p height="1em" width="0pt">Чипсет</p><p height="1em" width="0pt">Слоты памяти</p><p height="1em" width="0pt">Высокоскоростной</p><p height="1em" width="0pt">графическая шина</p><p height="1em" width="0pt">(AGP или PCI</p><p height="1em" width="0pt">Северный мост</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt">Выражать)</p><p height="1em" width="0pt">автобус</p><p height="1em" width="0pt">(Память</p><p height="1em" width="0pt">концентратор контроллера)</p><p height="1em" width="0pt">Внутренний</p><p height="1em" width="0pt">Автобус</p><p height="1em" width="0pt">Южный мост</p><p height="1em" width="0pt">PCI</p><p height="1em" width="0pt">(контроллер ввода/вывода</p><p height="1em" width="0pt">Автобус</p><p height="1em" width="0pt">центр)</p><p height="1em" width="0pt">IDE</p><p height="1em" width="0pt">САТА</p><p height="1em" width="0pt">USB</p><p height="1em" width="0pt">Кабели и</p><p height="1em" width="0pt">Ethernet</p><p height="1em" width="0pt">порты ведущие</p><p height="1em" width="0pt">Аудио кодек</p><p height="1em" width="0pt">КМОП-память</p><p height="1em" width="0pt">вне борта</p><p height="1em" width="0pt">слоты PCI</p><p height="1em" width="0pt">ЛПК</p><p height="1em" width="0pt">Автобус</p><p height="1em" width="0pt">Супер ввод/вывод</p><p height="1em" width="0pt">Последовательный порт</p><p height="1em" width="0pt">Параллельный порт</p><p height="1em" width="0pt">Флэш-ПЗУ</p><p height="1em" width="0pt">Дискета</p><p height="1em" width="0pt">(БИОС)</p><p height="1em" width="0pt">Клавиатура</p><p height="1em" width="0pt">мышь</p><a id="filepos147832" /><p height="1em" width="0pt">компьютерная архитектура</p><p height="1em" width="0pt">47</p><p height="1em" width="0pt"><b>3.4</b></p><p height="1em" width="0pt"><b>Чипсет Intel Q35</b></p><p height="1em" width="0pt">Q35 — это набор микросхем Intel, выпущенный в сентябре 2007 года. Q35 используется как пример компьютерной организации высокого уровня, поскольку позже мы будем использовать QEMU.</p><p height="1em" width="0pt">для эмуляции системы Q35, которая является последней системой Intel, которую может эмулировать QEMU. Несмотря на то, что Q35 был выпущен в 2007 году, он относительно современен по сравнению с текущим аппаратным обеспечением, и его знания все еще могут быть повторно использованы для текущей модели чипсета. С набором микросхем Q35 эмулируемый ЦП также относительно современен с функциями, представленными в современных ЦП, поэтому мы можем использовать последние руководства по программному обеспечению от Intel.</p><p height="1em" width="0pt">Фигура<a href="#filepos145827">3.3.1 на предыдущей странице</a>— это типичная современная организация материнских плат, в которой Q35 имеет аналогичную организацию.</p><p height="1em" width="0pt"><b>3,5</b></p><p height="1em" width="0pt"><b>Среда выполнения x86</b></p><p height="1em" width="0pt">Ан<i>среда выполнения</i>это среда, предоставляющая возможность сделать код исполняемым. Среда выполнения должна ответить на следующий вопрос:</p><p height="1em" width="0pt">Поддерживаемые операции? передача данных, арифметика, управление, операции с плавающей запятой и т. д.</p><p height="1em" width="0pt">Где хранятся операнды? регистры, память, стек, аккумулятор</p><p height="1em" width="0pt">Сколько явных операндов имеется для каждой инструкции? 0, 1, 2 или 3</p><p height="1em" width="0pt">Как указывается местоположение операнда? регистровые, непосредственные, косвенные и т. д.</p><p height="1em" width="0pt">Какие типы и размеры операндов поддерживаются? байт,</p><p height="1em" width="0pt">int, float, double, string, vector и т. д.</p><p height="1em" width="0pt">и т. д.</p><p height="1em" width="0pt">В оставшейся части этой главы, пожалуйста, продолжайте чтение до главы 3.</p><p height="1em" width="0pt">в Руководстве Intel, том 1,<i>«Базовая среда выполнения»</i>.</p><p height="1em" width="0pt"> <a id="filepos149943" /><b>4</b></p><p height="1em" width="0pt">x86 ассемблер и C</p><p height="1em" width="0pt">В этой главе мы исследуем язык ассемблера и то, как он связан с Си. Но зачем нам это делать? Не лучше ли довериться компилятору, плюс никто больше не пишет сборки?</p><p height="1em" width="0pt">Не совсем. Конечно, компилятор в его нынешнем состоянии заслуживает доверия, и нам не нужно писать код на ассемблере,<i>большую часть времени</i>.</p><p height="1em" width="0pt">Компилятор может генерировать код, но, как упоминалось ранее, язык высокого уровня представляет собой набор шаблонов языка более низкого уровня. Он не охватывает все, что предоставляет аппаратная платформа. Как следствие, не каждая ассемблерная инструкция может быть сгенерирована компилятором, поэтому нам все еще нужно писать ассемблерный код для этих обстоятельств, чтобы получить доступ к аппаратно-зависимым функциям. Поскольку специфичные для оборудования функции требуют написания ассемблерного кода, отладка требует его чтения. Мы можем проводить даже больше времени за чтением, чем за письмом. При работе с низкоуровневым кодом, напрямую взаимодействующим с аппаратным обеспечением, ассемблерный код неизбежен. Кроме того, понимание того, как компилятор генерирует ассемблерный код, может повысить производительность программиста. Например, если работа или школьное задание требует от нас написания ассемблерного кода, мы можем просто написать его на C, а затем пусть gcc сделает всю тяжелую работу по написанию ассемблерного кода за нас. Мы просто собираем сгенерированный ассемблерный код, модифицируем по мере необходимости и выполняем задание.</p><p height="1em" width="0pt">Мы подробно изучим objdump, а также как использовать документы Intel, чтобы помочь понять код сборки x86.</p><a id="filepos151594" /><p height="1em" width="0pt">50</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>4.1</b></p><p height="1em" width="0pt"><b>objdump</b></p><p height="1em" width="0pt">objdump — программа, отображающая информацию об объектных файлах. Позже будет удобно отладить неправильную верстку из ручного связывания. Теперь мы используем objdump, чтобы проверить, как высокоуровневый исходный код отображается в ассемблерный код. На данный момент мы игнорируем вывод и сначала узнаем, как использовать команду. Предположим, что у нас есть исполняемый двоичный файл с именем hello, скомпилированный из hello.c, который печатает «Hello World», использовать objdump просто.</p><p height="1em" width="0pt">:</p><p height="1em" width="0pt">$ objdump -d привет</p><p height="1em" width="0pt">Опция -d отображает только собранное содержимое исполняемых разделов. А<i>раздел</i>блок памяти, который содержит либо программный код, либо данные.</p><p height="1em" width="0pt">Раздел кода может выполняться процессором, а раздел данных не может быть выполнен. Неисполняемые разделы, такие как .data и .bss (для хранения данных программы), отладочные разделы и т.п. не отображаются. Мы узнаем больше о разделе при изучении двоичного формата файла ELF в главе<a href="#filepos344661">5 на странице 107</a>. С другой стороны: $ objdump -D привет</p><p height="1em" width="0pt">где опция -D отображает содержимое сборки всех разделов. Если -D, -d подразумевается неявно. objdump в основном используется для проверки ассемблерного кода, поэтому параметр -d является наиболее полезным и поэтому установлен по умолчанию.</p><p height="1em" width="0pt">Вывод выходит за пределы экрана терминала. Чтобы упростить чтение, отправьте весь вывод в less:</p><p height="1em" width="0pt">$ objdump -d привет | меньше</p><p height="1em" width="0pt">Чтобы смешать исходный код и сборку, двоичный файл должен быть скомпилирован с параметром -g, чтобы включить в него исходный код, а затем добавить параметр -S: $ objdump -S hello | меньше</p><a id="filepos153494" /><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">51</p><p height="1em" width="0pt">Синтаксис по умолчанию, используемый objdump, — это синтаксис AT&T. Чтобы изменить его на знакомый синтаксис Intel:</p><p height="1em" width="0pt">$ objdump -M Intel -D привет | меньше</p><p height="1em" width="0pt">При использовании опции -M опция -D или -d должна быть указана явно.</p><p height="1em" width="0pt">Далее мы воспользуемся objdump, чтобы проверить, как скомпилированные данные и код C представлены в машинном коде.</p><p height="1em" width="0pt">Наконец, мы напишем 32-битное ядро, поэтому нам нужно будет скомпилировать 32-битный бинарник и проверить его в 32-битном режиме:</p><p height="1em" width="0pt">$ objdump -M i386,intel -D привет | меньше</p><p height="1em" width="0pt">-M i386 указывает objdump отображать содержимое сборки с использованием 32-битной компоновки.</p><p height="1em" width="0pt">Знание разницы между 32-битной и 64-битной версиями имеет решающее значение для написания кода ядра. Мы рассмотрим этот вопрос позже при написании нашего ядра.</p><p height="1em" width="0pt"><b>4.2</b></p><p height="1em" width="0pt"><b>Чтение вывода</b></p><p height="1em" width="0pt">При запуске выводит файл формата объектного файла: привет: формат файла elf64-x86-64</p><p height="1em" width="0pt">После линии идет ряд разобранных секций:</p><p height="1em" width="0pt">Разборка раздела .interp:</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">Разборка раздела .note.ABI-tag:</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">Разборка раздела .note.gnu.build-id:</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">и т. д.</p><p height="1em" width="0pt">52</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Наконец, каждый дизассемблированный раздел отображает свое фактическое содержимое — последовательность инструкций по сборке — в следующем формате: 4004d6:</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">рбп</p><p height="1em" width="0pt">Первый столбец — это адрес ассемблерной инструкции. В приведенном выше примере адрес 0x4004d6.</p><p height="1em" width="0pt">Второй столбец - это инструкция по сборке в необработанных шестнадцатеричных значениях. В приведенном выше примере значение равно 0x55.</p><p height="1em" width="0pt">Третий столбец — инструкция по сборке. В зависимости от раздела инструкция по сборке может быть значимой или бессмысленной. Например, если инструкции по ассемблеру находятся в текстовом разделе, то инструкции по ассемблеру представляют собой фактический программный код. С другой стороны, если инструкции по сборке отображаются в разделе .data, то мы можем спокойно игнорировать отображаемые инструкции. Причина в том, что objdump не знает, какие шестнадцатеричные значения являются кодом, а какие данными, поэтому он вслепую переводит каждое шестнадцатеричное значение в инструкции по сборке. В приведенном выше примере ассемблерной инструкцией является push %rbp.</p><p height="1em" width="0pt">Необязательный четвертый столбец представляет собой комментарий, который появляется, когда есть ссылка на адрес, чтобы сообщить, откуда происходит адрес. Например, комментарий синего цвета:</p><p height="1em" width="0pt">lea r12,[rip+0x2008ee] # 600e10 <__frame_dummy_init_array_entry> должен сообщить, что указанный адрес из [rip+0x2008ee] равен 0x600e10, где находится переменная __frame_dummy_init_array_entry.</p><p height="1em" width="0pt">В разобранном виде он также может содержать<i>этикетки</i>. Метка — это имя, данное инструкции по сборке. Этикетка обозначает назначение сборочного блока для читателя-человека, чтобы облегчить его понимание. Например, раздел .text содержит множество таких меток, обозначающих, где начинается код в программе; Раздел .text ниже выполняет две функции: _start и deregister_tm_clones. Функция _start начинается с адреса 4003e0 и аннотируется слева от имени функции. Прямо под меткой _start также находится инструкция по адресу 4003e0. Все это означает, что метка — это просто имя адреса памяти. Функция deregister_tm_clones также использует тот же формат, что и все функции в этом разделе.</p><a id="filepos157688" /><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">53</p><p height="1em" width="0pt">00000000004003e0 <_start>:</p><p height="1em" width="0pt">4003e0:</p><p height="1em" width="0pt">31 изд.</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">эбп, эбп</p><p height="1em" width="0pt">4003e2:</p><p height="1em" width="0pt">49 89 д1</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">г9, рдкс</p><p height="1em" width="0pt">4003e5:</p><p height="1em" width="0pt">5е</p><p height="1em" width="0pt">поп</p><p height="1em" width="0pt">rsi</p><p height="1em" width="0pt">...больше ассемблерного кода....</p><p height="1em" width="0pt">0000000000400410 <deregister_tm_clones>:</p><p height="1em" width="0pt">400410:</p><p height="1em" width="0pt">b8 3f 10 60 00</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еах, 0x60103f</p><p height="1em" width="0pt">400415:</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">рбп</p><p height="1em" width="0pt">400416:</p><p height="1em" width="0pt">48 2д 38 10 60 00</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">ракс, 0x601038</p><p height="1em" width="0pt">...больше ассемблерного кода....</p><p height="1em" width="0pt"><b>4.3</b></p><p height="1em" width="0pt"><b>Руководства Intel</b></p><p height="1em" width="0pt">Лучший способ понять и правильно использовать язык ассемблера — это точно понять базовую архитектуру компьютера и то, что делает каждая машинная инструкция. Для этого наиболее надежным источником является обращение к документам, предоставленным поставщиками. В конце концов, производители оборудования — это те, кто производит свои машины. Чтобы понять набор инструкций Intel, нам нужен документ «<i>Разработчик программного обеспечения для архитектур Intel 64 и IA-32</i> <i>объединенные вручную объемы 2A, 2B, 2C и 2D: справочник по набору инструкций,</i> <i>А-Я</i>». Документ можно получить здесь:<a href="https://software.intel.com/en-us/articles/intel-sdm">https://software.intel.</a></p><p height="1em" width="0pt"><a href="https://software.intel.com/en-us/articles/intel-sdm">com/en-us/articles/intel-sdm.</a></p><p height="1em" width="0pt">Глава 1 содержит краткую информацию о руководстве и примечаниях, используемых в книге.</p><p height="1em" width="0pt">В главе 2 дается подробное объяснение анатомии ассемблерных инструкций, которую мы рассмотрим в следующем разделе.</p><p height="1em" width="0pt">В главах 3–5 подробно описаны все инструкции x86_64.</p><p height="1em" width="0pt">архитектура.</p><p height="1em" width="0pt">Глава 6 содержит информацию о расширениях более безопасного режима. Нам не понадобится использовать эту главу.</p><p height="1em" width="0pt">Первый том»<i>Разработчик программного обеспечения для архитектуры Intel® 64 и IA-32</i> <i>Руководство Том 1: Базовая архитектура</i>описывает базовую архитектуру и среду программирования процессоров Intel. В книге глава</p><a id="filepos160699" /><p height="1em" width="0pt">54</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">5 дает сводку всех инструкций Intel, перечисляя инструкции по разным категориям. Нам нужно только изучить инструкции общего назначения, перечисленные<i>глава 5.1</i>для нашей ОС.<i>Глава 7</i>описывает назначение каждой категории. Постепенно мы выучим все эти инструкции.</p><p height="1em" width="0pt"><b>Упражнение 4.3.1.</b>Прочитайте раздел 1.3 в томе 2, исключите разделы 1.3.5 и 1.3.7.</p><p height="1em" width="0pt"><b>4.4</b></p><p height="1em" width="0pt"><b>Поэкспериментируйте с ассемблерным кодом</b></p><p height="1em" width="0pt">В последующих разделах рассматривается структура инструкции по сборке. Чтобы полностью понять, необходимо написать код и увидеть код в его реальной форме, отображаемый в виде шестнадцатеричных чисел. Для этого мы используем ассемблер nasm, чтобы написать несколько строк ассемблерного кода и посмотреть сгенерированный код.</p><p height="1em" width="0pt"><b>Пример 4.4.1.</b>Предположим, мы хотим увидеть машинный код, сгенерированный для этой инструкции:</p><p height="1em" width="0pt">jmp eax</p><p height="1em" width="0pt">Затем мы используем редактор, например. Emacs, затем создайте новый файл, напишите код и сохраните его в файле, например. тест.асм. Затем в терминале выполните команду:</p><p height="1em" width="0pt">$ nasm -f бин test.asm -o тест</p><p height="1em" width="0pt">Параметр -f указывает формат файла, например. ELF конечного выходного файла. Но в данном случае формат bin, что означает, что этот файл представляет собой просто плоский двоичный вывод без какой-либо дополнительной информации. То есть написанный ассемблерный код транслируется в машинный код как есть, без накладных расходов на метаданные из формата файла, такого как ELF. Действительно, после компиляции мы можем проверить вывод с помощью этой команды:</p><p height="1em" width="0pt">$ hd тест</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">hd (сокращение от hexdump) — это программа, которая отображает содержимое файла в шестнадцатеричном формате. И получите следующий вывод:</p><p height="1em" width="0pt">Хотя его имя является сокращением от hex-</p><p height="1em" width="0pt">дамп, hd может отображаться в разных</p><p height="1em" width="0pt">00000000</p><p height="1em" width="0pt">66 сл e0</p><p height="1em" width="0pt">|ф..|</p><p height="1em" width="0pt">база, напр. двоичный, кроме шестнадцатеричного.</p><p height="1em" width="0pt">00000003</p><p height="1em" width="0pt">Файл состоит всего из 3 байтов: 66 ff e0, что эквивалентно инструкции jmp eax.</p><p height="1em" width="0pt"><b>Пример 4.4.2.</b>Если бы мы использовали elf в качестве формата файла: $ nasm -f elf test.asm -o test</p><p height="1em" width="0pt">Было бы сложнее выучить и понять инструкции по сборке со всем добавленным шумом1:</p><p height="1em" width="0pt">1 Вывод с hd.</p><p height="1em" width="0pt">00000000</p><p height="1em" width="0pt">7f 45 4c 46 01 01 01 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|.ЭЛЬФ............|</p><p height="1em" width="0pt">00000010</p><p height="1em" width="0pt">01 00 03 00 01 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000020</p><p height="1em" width="0pt">40 00 00 00 00 00 00 00</p><p height="1em" width="0pt">34 00 00 00 00 00 28 00</p><p height="1em" width="0pt">|@.......4.....(.|</p><p height="1em" width="0pt">00000030</p><p height="1em" width="0pt">05 00 02 00 00 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000040</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">*</p><p height="1em" width="0pt">00000060</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">01 00 00 00 01 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000070</p><p height="1em" width="0pt">06 00 00 00 00 00 00 00</p><p height="1em" width="0pt">10 01 00 00 02 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000080</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">10 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000090</p><p height="1em" width="0pt">07 00 00 00 03 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">000000a0</p><p height="1em" width="0pt">20 01 00 00 21 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">| ...!.........|</p><p height="1em" width="0pt">000000b0</p><p height="1em" width="0pt">01 00 00 00 00 00 00 00</p><p height="1em" width="0pt">11 00 00 00 02 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">000000c0</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">50 01 00 00 30 00 00 00</p><p height="1em" width="0pt">|........П...0...|</p><p height="1em" width="0pt">000000d0</p><p height="1em" width="0pt">04 00 00 00 03 00 00 00</p><p height="1em" width="0pt">04 00 00 00 10 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">000000e0</p><p height="1em" width="0pt">19 00 00 00 03 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">000000f0</p><p height="1em" width="0pt">80 01 00 00 0д 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000100</p><p height="1em" width="0pt">01 00 00 00 00 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><a id="filepos166809" /><p height="1em" width="0pt">56</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">00000110</p><p height="1em" width="0pt">ff e0 00 00 00 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000120</p><p height="1em" width="0pt">00 2е 74 65 78 74 00 2е</p><p height="1em" width="0pt">73 68 73 74 72 74 61 62</p><p height="1em" width="0pt">|..текст..shstrtab|</p><p height="1em" width="0pt">00000130</p><p height="1em" width="0pt">00 2е 73 79 6д 74 61 62</p><p height="1em" width="0pt">00 2е 73 74 72 74 61 62</p><p height="1em" width="0pt">|..symtab..strtab|</p><p height="1em" width="0pt">00000140</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">*</p><p height="1em" width="0pt">00000160</p><p height="1em" width="0pt">01 00 00 00 00 00 00 00</p><p height="1em" width="0pt">00 00 00 00 04 00 f1 и далее</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000170</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">00 00 00 00 03 00 01 00</p><p height="1em" width="0pt">|................|</p><p height="1em" width="0pt">00000180</p><p height="1em" width="0pt">00 74 65 73 74 2е 61 73</p><p height="1em" width="0pt">6д 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|.disp8-5.asm....|</p><p height="1em" width="0pt">00000190</p><p height="1em" width="0pt">Таким образом, в данном случае лучше просто использовать плоский бинарный формат, экспериментировать инструкция за инструкцией.</p><p height="1em" width="0pt">С таким простым рабочим процессом мы готовы исследовать структуру каждой инструкции по сборке.</p><p height="1em" width="0pt"><b>Примечание:</b>Использование формата bin переводит nasm по умолчанию в 16-битный режим.</p><p height="1em" width="0pt">Чтобы включить генерацию 32-битного кода, мы должны добавить эту строку в начало исходного файла nasm:</p><p height="1em" width="0pt">бит 32</p><p height="1em" width="0pt"><b>4,5</b></p><p height="1em" width="0pt"><b>Анатомия инструкции по сборке</b></p><p height="1em" width="0pt">В главе 2 справочного руководства по эксплуатации подробно рассматривается формат инструкций. Но информации слишком много, чтобы ошеломить новичков. В этом разделе приведены более простые инструкции перед чтением настоящей главы руководства.</p><p height="1em" width="0pt">Напомним, что ассемблерная инструкция — это просто последовательность битов фиксированного размера.</p><p height="1em" width="0pt">Длина инструкции варьируется и зависит от сложности инструкции. То, что объединяет каждую инструкцию, — это общий формат, описанный на рисунке выше, который делит биты инструкции на более мелкие части, которые кодируют различные типы информации. Эти части:<i>Префиксы инструкций</i>появляется в начале инструкции. Префиксы необязательны. Программист может выбирать, использовать префикс или нет, потому что на практике так называемый префикс — это просто еще одна ассемблерная инструкция.</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">57</p><p height="1em" width="0pt">Инструкция</p><p height="1em" width="0pt">Опкод</p><p height="1em" width="0pt">ModR/M</p><p height="1em" width="0pt">СИБ</p><p height="1em" width="0pt">смещение</p><p height="1em" width="0pt">Немедленный</p><p height="1em" width="0pt">Префиксы</p><p height="1em" width="0pt">Префиксы</p><p height="1em" width="0pt">1-, 2- или 3-байтовый</p><p height="1em" width="0pt">1 байт</p><p height="1em" width="0pt">1 байт</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Немедленный</p><p height="1em" width="0pt">по 1 байту</p><p height="1em" width="0pt">код операции</p><p height="1em" width="0pt">(если необходимо)</p><p height="1em" width="0pt">(если необходимо)</p><p height="1em" width="0pt">смещение</p><p height="1em" width="0pt">данные</p><p height="1em" width="0pt">(опционально)1,2</p><p height="1em" width="0pt">из 1, 2 или 4</p><p height="1em" width="0pt">1, 2 или 4</p><p height="1em" width="0pt">байт или нет3</p><p height="1em" width="0pt">байт или нет3</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">6 5</p><p height="1em" width="0pt">3 2</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">6 5</p><p height="1em" width="0pt">3 2</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Рег/</p><p height="1em" width="0pt">мод</p><p height="1em" width="0pt">р/м</p><p height="1em" width="0pt">Шкала</p><p height="1em" width="0pt">Индекс</p><p height="1em" width="0pt">База</p><p height="1em" width="0pt">Опкод</p><p height="1em" width="0pt">1. Префикс REX является необязательным, но если он используется, он должен быть непосредственно перед кодом операции; см. раздел 2.2.1, «Префиксы REX» в руководстве для получения дополнительной информации.</p><p height="1em" width="0pt">2. Информацию о кодировании VEX см. в разделе 2.3, «Intel® Advanced Vector Extensions (Intel®</p><p height="1em" width="0pt">AVX)» в руководстве.</p><p height="1em" width="0pt">3. Некоторые редкие инструкции могут занимать 8 байт сразу или 8 байтов смещения.</p><p height="1em" width="0pt"><b>Рисунок 4.5.1:</b>Intel 64 и IA-32</p><p height="1em" width="0pt">Формат инструкции по архитектуре</p><p height="1em" width="0pt">быть вставлен перед другой инструкцией по сборке, что такой префикс применим. Инструкции с 2-х или 3-х байтными кодами операций включают префиксы по умолчанию.</p><p height="1em" width="0pt"> <i>Опкод</i>это уникальный номер, который идентифицирует инструкцию. Каждому коду операции дается мнемоническое имя, понятное человеку, например. один из кодов операции для добавления инструкции — 04. Когда ЦП видит число 04</p><p height="1em" width="0pt">в своем кэше инструкций он видит, что инструкция добавляется и выполняется соответственно. Код операции может иметь длину 1, 2 или 3 байта и при необходимости включает дополнительное 3-битное поле в байте ModR/M.</p><p height="1em" width="0pt"><b>Пример 4.5.1.</b>Эта инструкция:</p><p height="1em" width="0pt">джмп [0x1234]</p><p height="1em" width="0pt">генерирует машинный код:</p><p height="1em" width="0pt">26 34 12</p><p height="1em" width="0pt">Самый первый байт, 0xff, — это код операции, уникальный для инструкции jmp.</p><p height="1em" width="0pt"> <i>ModR/M</i>определяет операнды инструкции. Операнд может быть либо</p><p height="1em" width="0pt">58</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">регистр, место в памяти или непосредственное значение. Этот компонент инструкции состоит из 3 меньших частей:</p><p height="1em" width="0pt"> <i>мод</i>поле или<i>модификатор</i>поле, объединенное с полем r/m, дает в общей сложности 5 бит информации для кодирования 32 возможных значений: 8 регистров и 24 режима адресации.</p><p height="1em" width="0pt"> <i>рег/опкод</i>поле кодирует либо операнд регистра, либо расширяет поле кода операции еще на 3 бита.</p><p height="1em" width="0pt"> <i>р/м</i>Поле кодирует либо операнд регистра, либо может быть объединено с полем mod для кодирования режима адресации.</p><p height="1em" width="0pt">Столы<a href="#filepos174261">4.5.1</a>и<a href="#filepos188918">4.5.2</a>перечислите все возможные 256 значений байта ModR/M и то, как каждое значение отображается в режим адресации и регистр в 16-битном и 32-битном режимах.</p><a id="filepos174261" /><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">59</p><p height="1em" width="0pt">г8(/р)</p><p height="1em" width="0pt">АЛ</p><p height="1em" width="0pt">КЛ</p><p height="1em" width="0pt">DL</p><p height="1em" width="0pt">БЛ</p><p height="1em" width="0pt">АХ</p><p height="1em" width="0pt">CH</p><p height="1em" width="0pt">ЦТ</p><p height="1em" width="0pt">ЧД</p><p height="1em" width="0pt">р16(/р)</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">клиентский опыт</p><p height="1em" width="0pt">DX</p><p height="1em" width="0pt">БХ</p><p height="1em" width="0pt">СП</p><p height="1em" width="0pt">BP1</p><p height="1em" width="0pt">СИ</p><p height="1em" width="0pt">DI</p><p height="1em" width="0pt">р32(/р)</p><p height="1em" width="0pt">EAX</p><p height="1em" width="0pt">ЕСХ</p><p height="1em" width="0pt">EDX</p><p height="1em" width="0pt">EBX</p><p height="1em" width="0pt">ЭСП</p><p height="1em" width="0pt">ЭБП</p><p height="1em" width="0pt">ЭСИ</p><p height="1em" width="0pt">ЭОД</p><p height="1em" width="0pt">мм (/ об)</p><p height="1em" width="0pt">мм0</p><p height="1em" width="0pt">ММ1</p><p height="1em" width="0pt">ММ2</p><p height="1em" width="0pt">ММ3</p><p height="1em" width="0pt">ММ4</p><p height="1em" width="0pt">ММ5</p><p height="1em" width="0pt">ММ6</p><p height="1em" width="0pt">ММ7</p><p height="1em" width="0pt">хмм(/р)</p><p height="1em" width="0pt">XMM0</p><p height="1em" width="0pt">XMM1</p><p height="1em" width="0pt">XMM2</p><p height="1em" width="0pt">XMM3</p><p height="1em" width="0pt">XMM4</p><p height="1em" width="0pt">XMM5</p><p height="1em" width="0pt">XMM6</p><p height="1em" width="0pt">XMM7</p><p height="1em" width="0pt">(в десятичном формате) / цифра (код операции)</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">(в двоичном формате) REG =</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt"><b>Фактический адрес</b></p><p height="1em" width="0pt"><b>мод</b></p><p height="1em" width="0pt"><b>р/м</b></p><p height="1em" width="0pt"><b>Значения ModR/M байт (в шестнадцатеричном формате)</b></p><p height="1em" width="0pt">[БХ + СИ]</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">18</p><p height="1em" width="0pt">20</p><p height="1em" width="0pt">28</p><p height="1em" width="0pt">30</p><p height="1em" width="0pt">38</p><p height="1em" width="0pt">[БХ + ДВ]</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">09</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">19</p><p height="1em" width="0pt">21</p><p height="1em" width="0pt">29</p><p height="1em" width="0pt">31</p><p height="1em" width="0pt">39</p><p height="1em" width="0pt">[БП + СИ]</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">0А</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">1А</p><p height="1em" width="0pt">22</p><p height="1em" width="0pt">2А</p><p height="1em" width="0pt">32</p><p height="1em" width="0pt">3А</p><p height="1em" width="0pt">[БП + ДВ]</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">0В</p><p height="1em" width="0pt">13</p><p height="1em" width="0pt">1Б</p><p height="1em" width="0pt">23</p><p height="1em" width="0pt">2Б</p><p height="1em" width="0pt">33</p><p height="1em" width="0pt">3Б</p><p height="1em" width="0pt">[СИ]</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">04</p><p height="1em" width="0pt">0С</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">1С</p><p height="1em" width="0pt">24</p><p height="1em" width="0pt">2С</p><p height="1em" width="0pt">34</p><p height="1em" width="0pt">3С</p><p height="1em" width="0pt">[ДИ]</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">0D</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">1D</p><p height="1em" width="0pt">25</p><p height="1em" width="0pt">2D</p><p height="1em" width="0pt">35</p><p height="1em" width="0pt">3D</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">дисп16</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">0Э</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">1Э</p><p height="1em" width="0pt">26</p><p height="1em" width="0pt">2Э</p><p height="1em" width="0pt">36</p><p height="1em" width="0pt">3Е</p><p height="1em" width="0pt">[БХ]</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">0F</p><p height="1em" width="0pt">17</p><p height="1em" width="0pt">1эт</p><p height="1em" width="0pt">27</p><p height="1em" width="0pt">2F</p><p height="1em" width="0pt">37</p><p height="1em" width="0pt">3F</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">[BX+SI]+disp8</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">40</p><p height="1em" width="0pt">48</p><p height="1em" width="0pt">50</p><p height="1em" width="0pt">58</p><p height="1em" width="0pt">60</p><p height="1em" width="0pt">68</p><p height="1em" width="0pt">70</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt">[BX+DI]+disp8</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">41</p><p height="1em" width="0pt">49</p><p height="1em" width="0pt">51</p><p height="1em" width="0pt">59</p><p height="1em" width="0pt">61</p><p height="1em" width="0pt">69</p><p height="1em" width="0pt">71</p><p height="1em" width="0pt">79</p><p height="1em" width="0pt">[BP + SI] + дисп8</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">42</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">52</p><p height="1em" width="0pt">5А</p><p height="1em" width="0pt">62</p><p height="1em" width="0pt">6А</p><p height="1em" width="0pt">72</p><p height="1em" width="0pt">7А</p><p height="1em" width="0pt">[BP + DI] + дисп8</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">43</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">53</p><p height="1em" width="0pt">5Б</p><p height="1em" width="0pt">63</p><p height="1em" width="0pt">6Б</p><p height="1em" width="0pt">73</p><p height="1em" width="0pt">7Б</p><p height="1em" width="0pt">[СИ] + дисп8</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">44</p><p height="1em" width="0pt">4С</p><p height="1em" width="0pt">54</p><p height="1em" width="0pt">5С</p><p height="1em" width="0pt">64</p><p height="1em" width="0pt">6С</p><p height="1em" width="0pt">74</p><p height="1em" width="0pt">7С</p><p height="1em" width="0pt">[DI] + дисп8</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">45</p><p height="1em" width="0pt">4D</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">5D</p><p height="1em" width="0pt">65</p><p height="1em" width="0pt">6Д</p><p height="1em" width="0pt">75</p><p height="1em" width="0pt">7D</p><p height="1em" width="0pt">[ВР] + дисп8</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">46</p><p height="1em" width="0pt">4Э</p><p height="1em" width="0pt">56</p><p height="1em" width="0pt">5Э</p><p height="1em" width="0pt">66</p><p height="1em" width="0pt">6Е</p><p height="1em" width="0pt">76</p><p height="1em" width="0pt">7Е</p><p height="1em" width="0pt">[BX] + дисп8</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">47</p><p height="1em" width="0pt">4F</p><p height="1em" width="0pt">57</p><p height="1em" width="0pt">5эт</p><p height="1em" width="0pt">67</p><p height="1em" width="0pt">6F</p><p height="1em" width="0pt">77</p><p height="1em" width="0pt">7F</p><p height="1em" width="0pt">[BX+SI]+disp16</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">80</p><p height="1em" width="0pt">88</p><p height="1em" width="0pt">90</p><p height="1em" width="0pt">98</p><p height="1em" width="0pt">А0</p><p height="1em" width="0pt">А8</p><p height="1em" width="0pt">B0</p><p height="1em" width="0pt">В8</p><p height="1em" width="0pt">[BX+DI]+disp16</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">81</p><p height="1em" width="0pt">89</p><p height="1em" width="0pt">91</p><p height="1em" width="0pt">99</p><p height="1em" width="0pt">А1</p><p height="1em" width="0pt">А9</p><p height="1em" width="0pt">Б1</p><p height="1em" width="0pt">В9</p><p height="1em" width="0pt">[ВР + СИ] + дисп16</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">82</p><p height="1em" width="0pt">8А</p><p height="1em" width="0pt">92</p><p height="1em" width="0pt">9А</p><p height="1em" width="0pt">А2</p><p height="1em" width="0pt">АА</p><p height="1em" width="0pt">Би 2</p><p height="1em" width="0pt">бакалавр</p><p height="1em" width="0pt">[BP+DI]+disp16</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">83</p><p height="1em" width="0pt">8Б</p><p height="1em" width="0pt">93</p><p height="1em" width="0pt">9Б</p><p height="1em" width="0pt">А3</p><p height="1em" width="0pt">АБ</p><p height="1em" width="0pt">Б3</p><p height="1em" width="0pt">ББ</p><p height="1em" width="0pt">[СИ] + дисп16</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">84</p><p height="1em" width="0pt">8С</p><p height="1em" width="0pt">94</p><p height="1em" width="0pt">9С</p><p height="1em" width="0pt">А4</p><p height="1em" width="0pt">переменный ток</p><p height="1em" width="0pt">В4</p><p height="1em" width="0pt">До нашей эры</p><p height="1em" width="0pt">[DI] + дисп16</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">85</p><p height="1em" width="0pt">8D</p><p height="1em" width="0pt">95</p><p height="1em" width="0pt">9Д</p><p height="1em" width="0pt">А5</p><p height="1em" width="0pt">ОБЪЯВЛЕНИЕ</p><p height="1em" width="0pt">В5</p><p height="1em" width="0pt">БД</p><p height="1em" width="0pt">[БП] + дисп16</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">86</p><p height="1em" width="0pt">8Е</p><p height="1em" width="0pt">96</p><p height="1em" width="0pt">9Е</p><p height="1em" width="0pt">А6</p><p height="1em" width="0pt">АЭ</p><p height="1em" width="0pt">В6</p><p height="1em" width="0pt">БЫТЬ</p><p height="1em" width="0pt">[BX] + дисп16</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">87</p><p height="1em" width="0pt">8F</p><p height="1em" width="0pt">97</p><p height="1em" width="0pt">9F</p><p height="1em" width="0pt">А7</p><p height="1em" width="0pt">АФ</p><p height="1em" width="0pt">В7</p><p height="1em" width="0pt">БФ</p><p height="1em" width="0pt">EAX/AX/AL/MM0/XMM0</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">С0</p><p height="1em" width="0pt">С8</p><p height="1em" width="0pt">Д0</p><p height="1em" width="0pt">Д8</p><p height="1em" width="0pt">Е0</p><p height="1em" width="0pt">Е8</p><p height="1em" width="0pt">F0</p><p height="1em" width="0pt">F8</p><p height="1em" width="0pt">ECX/CX/CL/MM1/XMM1</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">С1</p><p height="1em" width="0pt">С9</p><p height="1em" width="0pt">Д1</p><p height="1em" width="0pt">Д9</p><p height="1em" width="0pt">Е1</p><p height="1em" width="0pt">Е9</p><p height="1em" width="0pt">F1</p><p height="1em" width="0pt">F9</p><p height="1em" width="0pt">ЭДС/ДС/ДЛ/ММ2/ХММ2</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">С2</p><p height="1em" width="0pt">Калифорния</p><p height="1em" width="0pt">Д2</p><p height="1em" width="0pt">Д.А.</p><p height="1em" width="0pt">Е2</p><p height="1em" width="0pt">советник</p><p height="1em" width="0pt">F2</p><p height="1em" width="0pt">ФА</p><p height="1em" width="0pt">ЭБС/БС/БЛ/ММ3/ХММ3</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">С3</p><p height="1em" width="0pt">ЦБ</p><p height="1em" width="0pt">Д3</p><p height="1em" width="0pt">БД</p><p height="1em" width="0pt">Е3</p><p height="1em" width="0pt">ЭБ</p><p height="1em" width="0pt">F3</p><p height="1em" width="0pt">ФБ</p><p height="1em" width="0pt">ЭСП/СП/АХММ4/ХММ4</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">С4</p><p height="1em" width="0pt">CC</p><p height="1em" width="0pt">Д4</p><p height="1em" width="0pt">ОКРУГ КОЛУМБИЯ</p><p height="1em" width="0pt">Е4</p><p height="1em" width="0pt">ЕС</p><p height="1em" width="0pt">F4</p><p height="1em" width="0pt">ФК</p><p height="1em" width="0pt">ЭБП/БП/CH/MM5/XMM5</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">С5</p><p height="1em" width="0pt">CD</p><p height="1em" width="0pt">Д5</p><p height="1em" width="0pt">ДД</p><p height="1em" width="0pt">Е5</p><p height="1em" width="0pt">ЭД</p><p height="1em" width="0pt">F5</p><p height="1em" width="0pt">ФД</p><p height="1em" width="0pt">ЭСИ/СИ/ДХ/ММ6/ХММ6</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">С6</p><p height="1em" width="0pt">CE</p><p height="1em" width="0pt">Д6</p><p height="1em" width="0pt">DE</p><p height="1em" width="0pt">Е6</p><p height="1em" width="0pt">ЕЕ</p><p height="1em" width="0pt">F6</p><p height="1em" width="0pt">КЭ</p><p height="1em" width="0pt">ЭОД/ДИ/ЧД/ММ7/ХММ7</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">С7</p><p height="1em" width="0pt">CF</p><p height="1em" width="0pt">Д7</p><p height="1em" width="0pt">ДФ</p><p height="1em" width="0pt">Е7</p><p height="1em" width="0pt">ЭФ</p><p height="1em" width="0pt">F7</p><p height="1em" width="0pt">ФФ</p><p height="1em" width="0pt">1. Сегментный регистр по умолчанию — SS для эффективных адресов, содержащих индекс BP, DS для других эффективных адресов.</p><p height="1em" width="0pt">2. Номенклатура disp16 обозначает 16-битное смещение, которое следует за байтом ModR/M и которое добавляется к индексу.</p><p height="1em" width="0pt">3. Номенклатура disp8 обозначает 8-битное смещение, которое следует за байтом ModR/M и которое расширяется по знаку и добавляется к индексу.</p><p height="1em" width="0pt"><b>Таблица 4.5.1:</b>16-битный</p><p height="1em" width="0pt">Адресация</p><p height="1em" width="0pt">Формы с байтом ModR/M</p><a id="filepos188918" /><p height="1em" width="0pt">60</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">г8(/р)</p><p height="1em" width="0pt">АЛ</p><p height="1em" width="0pt">КЛ</p><p height="1em" width="0pt">DL</p><p height="1em" width="0pt">БЛ</p><p height="1em" width="0pt">АХ</p><p height="1em" width="0pt">CH</p><p height="1em" width="0pt">ЦТ</p><p height="1em" width="0pt">ЧД</p><p height="1em" width="0pt">р16(/р)</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">клиентский опыт</p><p height="1em" width="0pt">DX</p><p height="1em" width="0pt">БХ</p><p height="1em" width="0pt">СП</p><p height="1em" width="0pt">АД</p><p height="1em" width="0pt">СИ</p><p height="1em" width="0pt">DI</p><p height="1em" width="0pt">р32(/р)</p><p height="1em" width="0pt">EAX</p><p height="1em" width="0pt">ЕСХ</p><p height="1em" width="0pt">EDX</p><p height="1em" width="0pt">EBX</p><p height="1em" width="0pt">ЭСП</p><p height="1em" width="0pt">ЭБП</p><p height="1em" width="0pt">ЭСИ</p><p height="1em" width="0pt">ЭОД</p><p height="1em" width="0pt">мм (/ об)</p><p height="1em" width="0pt">мм0</p><p height="1em" width="0pt">ММ1</p><p height="1em" width="0pt">ММ2</p><p height="1em" width="0pt">ММ3</p><p height="1em" width="0pt">ММ4</p><p height="1em" width="0pt">ММ5</p><p height="1em" width="0pt">ММ6</p><p height="1em" width="0pt">ММ7</p><p height="1em" width="0pt">хмм(/р)</p><p height="1em" width="0pt">XMM0</p><p height="1em" width="0pt">XMM1</p><p height="1em" width="0pt">XMM2</p><p height="1em" width="0pt">XMM3</p><p height="1em" width="0pt">XMM4</p><p height="1em" width="0pt">XMM5</p><p height="1em" width="0pt">XMM6</p><p height="1em" width="0pt">XMM7</p><p height="1em" width="0pt">(в десятичном формате) / цифра (код операции)</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">(в двоичном формате) REG =</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt"><b>Фактический адрес</b></p><p height="1em" width="0pt"><b>мод</b></p><p height="1em" width="0pt"><b>р/м</b></p><p height="1em" width="0pt"><b>Значения ModR/M байт (в шестнадцатеричном формате)</b></p><p height="1em" width="0pt">[EAX]</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">18</p><p height="1em" width="0pt">20</p><p height="1em" width="0pt">28</p><p height="1em" width="0pt">30</p><p height="1em" width="0pt">38</p><p height="1em" width="0pt">[ECX]</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">09</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">19</p><p height="1em" width="0pt">21</p><p height="1em" width="0pt">29</p><p height="1em" width="0pt">31</p><p height="1em" width="0pt">39</p><p height="1em" width="0pt">[EDX]</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">0А</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">1А</p><p height="1em" width="0pt">22</p><p height="1em" width="0pt">2А</p><p height="1em" width="0pt">32</p><p height="1em" width="0pt">3А</p><p height="1em" width="0pt">[EBX]</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">0В</p><p height="1em" width="0pt">13</p><p height="1em" width="0pt">1Б</p><p height="1em" width="0pt">23</p><p height="1em" width="0pt">2Б</p><p height="1em" width="0pt">33</p><p height="1em" width="0pt">3Б</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[--][--]</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">04</p><p height="1em" width="0pt">0С</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">1С</p><p height="1em" width="0pt">24</p><p height="1em" width="0pt">2С</p><p height="1em" width="0pt">34</p><p height="1em" width="0pt">3С</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">disp32</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">0D</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">1D</p><p height="1em" width="0pt">25</p><p height="1em" width="0pt">2D</p><p height="1em" width="0pt">35</p><p height="1em" width="0pt">3D</p><p height="1em" width="0pt">[ESI]</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">0Э</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">1Э</p><p height="1em" width="0pt">26</p><p height="1em" width="0pt">2Э</p><p height="1em" width="0pt">36</p><p height="1em" width="0pt">3Е</p><p height="1em" width="0pt">[ЭОД]</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">0F</p><p height="1em" width="0pt">17</p><p height="1em" width="0pt">1эт</p><p height="1em" width="0pt">27</p><p height="1em" width="0pt">2F</p><p height="1em" width="0pt">37</p><p height="1em" width="0pt">3F</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">[EAX] + дисп8</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">40</p><p height="1em" width="0pt">48</p><p height="1em" width="0pt">50</p><p height="1em" width="0pt">58</p><p height="1em" width="0pt">60</p><p height="1em" width="0pt">68</p><p height="1em" width="0pt">70</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt">[ECX] + дисп8</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">41</p><p height="1em" width="0pt">49</p><p height="1em" width="0pt">51</p><p height="1em" width="0pt">59</p><p height="1em" width="0pt">61</p><p height="1em" width="0pt">69</p><p height="1em" width="0pt">71</p><p height="1em" width="0pt">79</p><p height="1em" width="0pt">[EDX] + дисп8</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">42</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">52</p><p height="1em" width="0pt">5А</p><p height="1em" width="0pt">62</p><p height="1em" width="0pt">6А</p><p height="1em" width="0pt">72</p><p height="1em" width="0pt">7А</p><p height="1em" width="0pt">[EBX] + дисп8</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">43</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">53</p><p height="1em" width="0pt">5Б</p><p height="1em" width="0pt">63</p><p height="1em" width="0pt">6Б</p><p height="1em" width="0pt">73</p><p height="1em" width="0pt">7Б</p><p height="1em" width="0pt">[--][--] + дисп8</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">44</p><p height="1em" width="0pt">4С</p><p height="1em" width="0pt">54</p><p height="1em" width="0pt">5С</p><p height="1em" width="0pt">64</p><p height="1em" width="0pt">6С</p><p height="1em" width="0pt">74</p><p height="1em" width="0pt">7С</p><p height="1em" width="0pt">[EBP] + дисп8</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">45</p><p height="1em" width="0pt">4D</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">5D</p><p height="1em" width="0pt">65</p><p height="1em" width="0pt">6Д</p><p height="1em" width="0pt">75</p><p height="1em" width="0pt">7D</p><p height="1em" width="0pt">[ESI] + дисп8</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">46</p><p height="1em" width="0pt">4Э</p><p height="1em" width="0pt">56</p><p height="1em" width="0pt">5Э</p><p height="1em" width="0pt">66</p><p height="1em" width="0pt">6Е</p><p height="1em" width="0pt">76</p><p height="1em" width="0pt">7Е</p><p height="1em" width="0pt">[EDI] + дисп8</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">47</p><p height="1em" width="0pt">4F</p><p height="1em" width="0pt">57</p><p height="1em" width="0pt">5эт</p><p height="1em" width="0pt">67</p><p height="1em" width="0pt">6F</p><p height="1em" width="0pt">77</p><p height="1em" width="0pt">7F</p><p height="1em" width="0pt">[EAX] + дисп32</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">80</p><p height="1em" width="0pt">88</p><p height="1em" width="0pt">90</p><p height="1em" width="0pt">98</p><p height="1em" width="0pt">А0</p><p height="1em" width="0pt">А8</p><p height="1em" width="0pt">B0</p><p height="1em" width="0pt">В8</p><p height="1em" width="0pt">[ECX] + дисп32</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">81</p><p height="1em" width="0pt">89</p><p height="1em" width="0pt">91</p><p height="1em" width="0pt">99</p><p height="1em" width="0pt">А1</p><p height="1em" width="0pt">А9</p><p height="1em" width="0pt">Б1</p><p height="1em" width="0pt">В9</p><p height="1em" width="0pt">[EDX] + дисп32</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">82</p><p height="1em" width="0pt">8А</p><p height="1em" width="0pt">92</p><p height="1em" width="0pt">9А</p><p height="1em" width="0pt">А2</p><p height="1em" width="0pt">АА</p><p height="1em" width="0pt">Би 2</p><p height="1em" width="0pt">бакалавр</p><p height="1em" width="0pt">[EBX] + дисп32</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">83</p><p height="1em" width="0pt">8Б</p><p height="1em" width="0pt">93</p><p height="1em" width="0pt">9Б</p><p height="1em" width="0pt">А3</p><p height="1em" width="0pt">АБ</p><p height="1em" width="0pt">Б3</p><p height="1em" width="0pt">ББ</p><p height="1em" width="0pt">[--][--] + дисп32</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">84</p><p height="1em" width="0pt">8С</p><p height="1em" width="0pt">94</p><p height="1em" width="0pt">9С</p><p height="1em" width="0pt">А4</p><p height="1em" width="0pt">переменный ток</p><p height="1em" width="0pt">В4</p><p height="1em" width="0pt">До нашей эры</p><p height="1em" width="0pt">[EBP] + дисп32</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">85</p><p height="1em" width="0pt">8D</p><p height="1em" width="0pt">95</p><p height="1em" width="0pt">9Д</p><p height="1em" width="0pt">А5</p><p height="1em" width="0pt">ОБЪЯВЛЕНИЕ</p><p height="1em" width="0pt">В5</p><p height="1em" width="0pt">БД</p><p height="1em" width="0pt">[ESI] + дисп32</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">86</p><p height="1em" width="0pt">8Е</p><p height="1em" width="0pt">96</p><p height="1em" width="0pt">9Е</p><p height="1em" width="0pt">А6</p><p height="1em" width="0pt">АЭ</p><p height="1em" width="0pt">В6</p><p height="1em" width="0pt">БЫТЬ</p><p height="1em" width="0pt">[ЭОД] + дисп32</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">87</p><p height="1em" width="0pt">8F</p><p height="1em" width="0pt">97</p><p height="1em" width="0pt">9F</p><p height="1em" width="0pt">А7</p><p height="1em" width="0pt">АФ</p><p height="1em" width="0pt">В7</p><p height="1em" width="0pt">БФ</p><p height="1em" width="0pt">EAX/AX/AL/MM0/XMM0</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">С0</p><p height="1em" width="0pt">С8</p><p height="1em" width="0pt">Д0</p><p height="1em" width="0pt">Д8</p><p height="1em" width="0pt">Е0</p><p height="1em" width="0pt">Е8</p><p height="1em" width="0pt">F0</p><p height="1em" width="0pt">F8</p><p height="1em" width="0pt">ECX/CX/CL/MM/XMM1</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">С1</p><p height="1em" width="0pt">С9</p><p height="1em" width="0pt">Д1</p><p height="1em" width="0pt">Д9</p><p height="1em" width="0pt">Е1</p><p height="1em" width="0pt">Е9</p><p height="1em" width="0pt">F1</p><p height="1em" width="0pt">F9</p><p height="1em" width="0pt">ЭДС/ДС/ДЛ/ММ2/ХММ2</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">С2</p><p height="1em" width="0pt">Калифорния</p><p height="1em" width="0pt">Д2</p><p height="1em" width="0pt">Д.А.</p><p height="1em" width="0pt">Е2</p><p height="1em" width="0pt">советник</p><p height="1em" width="0pt">F2</p><p height="1em" width="0pt">ФА</p><p height="1em" width="0pt">ЭБС/БС/БЛ/ММ3/ХММ3</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">С3</p><p height="1em" width="0pt">ЦБ</p><p height="1em" width="0pt">Д3</p><p height="1em" width="0pt">БД</p><p height="1em" width="0pt">Е3</p><p height="1em" width="0pt">ЭБ</p><p height="1em" width="0pt">F3</p><p height="1em" width="0pt">ФБ</p><p height="1em" width="0pt">ЭСП/СП/АХ/ММ4/ХММ4</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">С4</p><p height="1em" width="0pt">CC</p><p height="1em" width="0pt">Д4</p><p height="1em" width="0pt">ОКРУГ КОЛУМБИЯ</p><p height="1em" width="0pt">Е4</p><p height="1em" width="0pt">ЕС</p><p height="1em" width="0pt">F4</p><p height="1em" width="0pt">ФК</p><p height="1em" width="0pt">ЭБП/БП/CH/MM5/XMM5</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">С5</p><p height="1em" width="0pt">CD</p><p height="1em" width="0pt">Д5</p><p height="1em" width="0pt">ДД</p><p height="1em" width="0pt">Е5</p><p height="1em" width="0pt">ЭД</p><p height="1em" width="0pt">F5</p><p height="1em" width="0pt">ФД</p><p height="1em" width="0pt">ЭСИ/СИ/ДХ/ММ6/ХММ6</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">С6</p><p height="1em" width="0pt">CE</p><p height="1em" width="0pt">Д6</p><p height="1em" width="0pt">DE</p><p height="1em" width="0pt">Е6</p><p height="1em" width="0pt">ЕЕ</p><p height="1em" width="0pt">F6</p><p height="1em" width="0pt">КЭ</p><p height="1em" width="0pt">ЭОД/ДИ/ЧД/ММ7/ХММ7</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">С7</p><p height="1em" width="0pt">CF</p><p height="1em" width="0pt">Д7</p><p height="1em" width="0pt">ДФ</p><p height="1em" width="0pt">Е7</p><p height="1em" width="0pt">ЭФ</p><p height="1em" width="0pt">F7</p><p height="1em" width="0pt">ФФ</p><p height="1em" width="0pt">1. Номенклатура [--][--] означает, что SIB следует за байтом ModR/M.</p><p height="1em" width="0pt">2. Номенклатура disp32 обозначает 32-битное смещение, которое следует за байтом ModR/M (или байтом SIB, если он присутствует) и которое добавляется к индексу.</p><p height="1em" width="0pt">3. Номенклатура disp8 обозначает 8-битное смещение, которое следует за байтом ModR/M (или байтом SIB, если он присутствует) и которое расширяется по знаку и добавляется к индексу.</p><p height="1em" width="0pt"><b>Таблица 4.5.2:</b>32-битный</p><p height="1em" width="0pt">Адресация</p><p height="1em" width="0pt">Формы с байтом ModR/M</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">61</p><p height="1em" width="0pt">Как читать таблицу:</p><p height="1em" width="0pt">В инструкции рядом с кодом операции находится байт ModR/M. Затем найдите значение байта в этой таблице, чтобы получить соответствующие операнды в строке и столбце.</p><p height="1em" width="0pt"><b>Пример 4.5.2.</b>Инструкция использует этот режим адресации: jmp [0x1234]</p><p height="1em" width="0pt">Тогда машинный код:</p><p height="1em" width="0pt">26 34 12</p><p height="1em" width="0pt">0xff — код операции. Рядом с ним 0x26 — это байт ModR/M. Найдите в 16-битной таблице первый операнд в строке, эквивалентной disp16. Помните,</p><p height="1em" width="0pt">используя формат bin</p><p height="1em" width="0pt">что означает 16-битное смещение. Так как инструкция не имеет по умолчанию генерирует 16-битный код</p><p height="1em" width="0pt">второй операнд, столбец можно игнорировать.</p><p height="1em" width="0pt"><b>Пример 4.5.3.</b>Инструкция использует этот режим адресации: add eax, ecx</p><p height="1em" width="0pt">Тогда машинный код:</p><p height="1em" width="0pt">66 01 с8</p><p height="1em" width="0pt">Интересной особенностью этой инструкции является то, что 0x66 не является кодом операции. 0x01 — код операции. Итак, что такое 0x66? Напомним, что для каждой ассемблерной инструкции будет необязательный префикс инструкции, и это то, что представляет собой 0x66. Согласно руководству Intel, том 1: префикс переопределения размера операнда позволяет программе переключаться между 16-битным и 32-битным размером операнда. Любой размер может быть значением по умолчанию; использование префикса выбирает размер не по умолчанию.</p><p height="1em" width="0pt">Если ЦП переключен в 32-битный режим, когда он выполняет инструкцию с префиксом 0x66, операнды инструкции ограничены только 16-битной шириной.</p><p height="1em" width="0pt">62</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">С другой стороны, если ЦП находится в 16-битной среде, в результате 32-битная считается нестандартной, и поэтому операнды инструкций временно обновляются до 32-битной ширины, в то время как инструкции без префикса используют 16-битную. битовые операнды.</p><p height="1em" width="0pt">Рядом с ним c8 находится байт ModR/M. Посмотрите в 16-битной таблице на с8</p><p height="1em" width="0pt">значение, строка сообщает, что первый операнд — это ax, столбец — второй. Помните, что при использовании формата bin gen-operand равен cx; столбец не может быть проигнорирован, так как второй операнд по умолчанию стирает 16-битный код</p><p height="1em" width="0pt">Инструкция.</p><p height="1em" width="0pt">Почему первый операнд в строке, а второй в столбце? Давайте разобьем байт ModR/M с примером значения c8 на биты:<b>мод</b></p><p height="1em" width="0pt"><b>рег/опкод</b></p><p height="1em" width="0pt"><b>р/м</b></p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Поле mod делит режимы адресации на 4 разные категории. Кроме того, в сочетании с полем r/m можно выбрать ровно один режим адресации из одной из 24 строк. Если инструкции требуется только один операнд, то столбец можно игнорировать. Затем поле reg/opcode, наконец, предоставляет дополнительный регистр или другие варианты, если инструкция требует этого.</p><p height="1em" width="0pt"> <i>СИБ</i>является<i><b>С</b></i><i>Кале-</i><i><b>я</b></i><i>индекс-</i><i><b>Б</b></i><i>асе</i>байт. Этот байт кодирует способы вычисления позиции памяти в элементе массива. SIB — это название, основанное на следующей формуле расчета эффективного адреса: Эффективный адрес = шкала * индекс + база</p><p height="1em" width="0pt">Индекс — это смещение в массиве.</p><p height="1em" width="0pt">Масштаб является фактором индекса. Масштаб — одно из значений 1, 2, 4 или 8; любое другое значение недопустимо. Для масштабирования со значениями, отличными от 2, 4 или 8, коэффициент масштабирования должен быть установлен равным 1, а смещение должно быть рассчитано вручную. Например, если мы хотим получить адрес n-го элемента в массиве, и каждый элемент имеет длину 12 байт. Поскольку каждый элемент имеет длину 12 байтов вместо 1, 2, 4 или 8, масштаб устанавливается равным 1, и компилятору необходимо вычислить смещение:</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">63</p><p height="1em" width="0pt">Эффективный адрес = 1 ∗ (12 ∗ n) + основание</p><p height="1em" width="0pt">Зачем нам возиться с SIB, когда мы можем вычислить смещение вручную? Ответ заключается в том, что в приведенном выше сценарии необходимо выполнить дополнительную инструкцию mul, чтобы получить смещение, и инструкция mul потребляет более 1 байта, в то время как SIB потребляет только 1 байт.</p><p height="1em" width="0pt">байт. Что еще более важно, если к элементу многократно обращаются в цикле, например. миллионы раз, то дополнительная инструкция mul может снизить производительность, поскольку ЦП должен тратить время на выполнение миллионов этих дополнительных инструкций mul.</p><p height="1em" width="0pt">Значения 2, 4 и 8 выбраны не случайно. Они отображают 16-битные (или 2 байта), 32-битные (или 4 байта) и 64-битные (или 8 байты) числа, которые часто используются для интенсивных числовых вычислений.</p><p height="1em" width="0pt">База — это начальный адрес.</p><p height="1em" width="0pt">Ниже приведена таблица со списком всех 256 значений байта SIB с правилом поиска, аналогичным таблицам ModR/M:</p><p height="1em" width="0pt"><b>Пример 4.5.4.</b>Эта инструкция:</p><p height="1em" width="0pt">jmp [eax*2 + ebx]</p><p height="1em" width="0pt">генерирует следующий код:</p><p height="1em" width="0pt">00000000</p><p height="1em" width="0pt">67 и далее 24 43</p><p height="1em" width="0pt">Прежде всего, первый байт, 0x67,<i>нет</i>код операции, но<i>префикс</i>. Номер представляет собой предопределенный префикс для префикса переопределения размера адреса. После префикса идет код операции 0xff и байт ModR/M 0x24. Значение из ModR/M предполагает наличие следующего за ним байта SIB. Байт SIB равен 0x43.</p><p height="1em" width="0pt">Посмотрите в таблице SIB, в строке указано, что eax масштабируется на 2, а в столбце указано, что добавляемая база находится в ebx.</p><p height="1em" width="0pt"> <i>смещение</i>это смещение от начала базового индекса.</p><p height="1em" width="0pt"><b>Пример 4.5.5.</b>Эта инструкция:</p><p height="1em" width="0pt">джмп [0x1234]</p><a id="filepos210160" /><p height="1em" width="0pt">64</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">р32(/р)</p><p height="1em" width="0pt">EAX</p><p height="1em" width="0pt">ЕСХ</p><p height="1em" width="0pt">EDX</p><p height="1em" width="0pt">EBX</p><p height="1em" width="0pt">ЭСП</p><p height="1em" width="0pt">ЭБП</p><p height="1em" width="0pt">ЭСИ</p><p height="1em" width="0pt">ЭОД</p><p height="1em" width="0pt">(в десятичном формате) / цифра (код операции)</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">(в двоичном формате) REG =</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt"><b>Фактический адрес</b></p><p height="1em" width="0pt"><b>SS</b></p><p height="1em" width="0pt"><b>р/м</b></p><p height="1em" width="0pt"><b>Значения байта SIB (в шестнадцатеричном формате)</b></p><p height="1em" width="0pt">[EAX]</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">04</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">[ECX]</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">09</p><p height="1em" width="0pt">0А</p><p height="1em" width="0pt">0В</p><p height="1em" width="0pt">0С</p><p height="1em" width="0pt">0D</p><p height="1em" width="0pt">0Э</p><p height="1em" width="0pt">0F</p><p height="1em" width="0pt">[EDX]</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">13</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">17</p><p height="1em" width="0pt">[EBX]</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">18</p><p height="1em" width="0pt">19</p><p height="1em" width="0pt">1А</p><p height="1em" width="0pt">1Б</p><p height="1em" width="0pt">1С</p><p height="1em" width="0pt">1D</p><p height="1em" width="0pt">1Э</p><p height="1em" width="0pt">1эт</p><p height="1em" width="0pt">никто</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">20</p><p height="1em" width="0pt">21</p><p height="1em" width="0pt">22</p><p height="1em" width="0pt">23</p><p height="1em" width="0pt">24</p><p height="1em" width="0pt">25</p><p height="1em" width="0pt">26</p><p height="1em" width="0pt">27</p><p height="1em" width="0pt">[EBP]</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">28</p><p height="1em" width="0pt">29</p><p height="1em" width="0pt">2А</p><p height="1em" width="0pt">2Б</p><p height="1em" width="0pt">2С</p><p height="1em" width="0pt">2D</p><p height="1em" width="0pt">2Э</p><p height="1em" width="0pt">2F</p><p height="1em" width="0pt">[ESI]</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">30</p><p height="1em" width="0pt">31</p><p height="1em" width="0pt">32</p><p height="1em" width="0pt">33</p><p height="1em" width="0pt">34</p><p height="1em" width="0pt">35</p><p height="1em" width="0pt">36</p><p height="1em" width="0pt">37</p><p height="1em" width="0pt">[ЭОД]</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">38</p><p height="1em" width="0pt">39</p><p height="1em" width="0pt">3А</p><p height="1em" width="0pt">3Б</p><p height="1em" width="0pt">3С</p><p height="1em" width="0pt">3D</p><p height="1em" width="0pt">3Е</p><p height="1em" width="0pt">3F</p><p height="1em" width="0pt">[ЕАКС*2]</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">40</p><p height="1em" width="0pt">41</p><p height="1em" width="0pt">42</p><p height="1em" width="0pt">43</p><p height="1em" width="0pt">44</p><p height="1em" width="0pt">45</p><p height="1em" width="0pt">46</p><p height="1em" width="0pt">47</p><p height="1em" width="0pt">[ECX*2]</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">48</p><p height="1em" width="0pt">49</p><p height="1em" width="0pt">4А</p><p height="1em" width="0pt">4Б</p><p height="1em" width="0pt">4С</p><p height="1em" width="0pt">4D</p><p height="1em" width="0pt">4Э</p><p height="1em" width="0pt">4F</p><p height="1em" width="0pt">[EDX*2]</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">50</p><p height="1em" width="0pt">51</p><p height="1em" width="0pt">52</p><p height="1em" width="0pt">53</p><p height="1em" width="0pt">54</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">56</p><p height="1em" width="0pt">57</p><p height="1em" width="0pt">[EBX*2]</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">58</p><p height="1em" width="0pt">59</p><p height="1em" width="0pt">5А</p><p height="1em" width="0pt">5Б</p><p height="1em" width="0pt">5С</p><p height="1em" width="0pt">5D</p><p height="1em" width="0pt">5Э</p><p height="1em" width="0pt">5эт</p><p height="1em" width="0pt">никто</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">60</p><p height="1em" width="0pt">61</p><p height="1em" width="0pt">62</p><p height="1em" width="0pt">63</p><p height="1em" width="0pt">64</p><p height="1em" width="0pt">65</p><p height="1em" width="0pt">66</p><p height="1em" width="0pt">67</p><p height="1em" width="0pt">[EBP*2]</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">68</p><p height="1em" width="0pt">69</p><p height="1em" width="0pt">6А</p><p height="1em" width="0pt">6Б</p><p height="1em" width="0pt">6С</p><p height="1em" width="0pt">6Д</p><p height="1em" width="0pt">6Е</p><p height="1em" width="0pt">6F</p><p height="1em" width="0pt">[ESI*2]</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">70</p><p height="1em" width="0pt">71</p><p height="1em" width="0pt">72</p><p height="1em" width="0pt">73</p><p height="1em" width="0pt">74</p><p height="1em" width="0pt">75</p><p height="1em" width="0pt">76</p><p height="1em" width="0pt">77</p><p height="1em" width="0pt">[ЭОД*2]</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt">79</p><p height="1em" width="0pt">7А</p><p height="1em" width="0pt">7Б</p><p height="1em" width="0pt">7С</p><p height="1em" width="0pt">7D</p><p height="1em" width="0pt">7Е</p><p height="1em" width="0pt">7F</p><p height="1em" width="0pt">[ЕАКС*4]</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">80</p><p height="1em" width="0pt">81</p><p height="1em" width="0pt">82</p><p height="1em" width="0pt">83</p><p height="1em" width="0pt">84</p><p height="1em" width="0pt">85</p><p height="1em" width="0pt">86</p><p height="1em" width="0pt">87</p><p height="1em" width="0pt">[ECX*4]</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">88</p><p height="1em" width="0pt">89</p><p height="1em" width="0pt">8А</p><p height="1em" width="0pt">8Б</p><p height="1em" width="0pt">8С</p><p height="1em" width="0pt">8D</p><p height="1em" width="0pt">8Е</p><p height="1em" width="0pt">8F</p><p height="1em" width="0pt">[EDX*4]</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">90</p><p height="1em" width="0pt">91</p><p height="1em" width="0pt">92</p><p height="1em" width="0pt">93</p><p height="1em" width="0pt">94</p><p height="1em" width="0pt">95</p><p height="1em" width="0pt">96</p><p height="1em" width="0pt">97</p><p height="1em" width="0pt">[ЭБХ*4]</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">98</p><p height="1em" width="0pt">99</p><p height="1em" width="0pt">9А</p><p height="1em" width="0pt">9Б</p><p height="1em" width="0pt">9С</p><p height="1em" width="0pt">9Д</p><p height="1em" width="0pt">9Е</p><p height="1em" width="0pt">9F</p><p height="1em" width="0pt">никто</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">А0</p><p height="1em" width="0pt">А1</p><p height="1em" width="0pt">А2</p><p height="1em" width="0pt">А3</p><p height="1em" width="0pt">А4</p><p height="1em" width="0pt">А5</p><p height="1em" width="0pt">А6</p><p height="1em" width="0pt">А7</p><p height="1em" width="0pt">[EBP*4]</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">А8</p><p height="1em" width="0pt">А9</p><p height="1em" width="0pt">АА</p><p height="1em" width="0pt">АБ</p><p height="1em" width="0pt">переменный ток</p><p height="1em" width="0pt">ОБЪЯВЛЕНИЕ</p><p height="1em" width="0pt">АЭ</p><p height="1em" width="0pt">АФ</p><p height="1em" width="0pt">[ESI*4]</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">B0</p><p height="1em" width="0pt">Б1</p><p height="1em" width="0pt">Би 2</p><p height="1em" width="0pt">Б3</p><p height="1em" width="0pt">В4</p><p height="1em" width="0pt">В5</p><p height="1em" width="0pt">В6</p><p height="1em" width="0pt">В7</p><p height="1em" width="0pt">[ЭОД*4]</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">В8</p><p height="1em" width="0pt">В9</p><p height="1em" width="0pt">бакалавр</p><p height="1em" width="0pt">ББ</p><p height="1em" width="0pt">До нашей эры</p><p height="1em" width="0pt">БД</p><p height="1em" width="0pt">БЫТЬ</p><p height="1em" width="0pt">БФ</p><p height="1em" width="0pt">[ЕАКС*8]</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">000</p><p height="1em" width="0pt">С0</p><p height="1em" width="0pt">С1</p><p height="1em" width="0pt">С2</p><p height="1em" width="0pt">С3</p><p height="1em" width="0pt">С4</p><p height="1em" width="0pt">С5</p><p height="1em" width="0pt">С6</p><p height="1em" width="0pt">С7</p><p height="1em" width="0pt">[ECX*8]</p><p height="1em" width="0pt">001</p><p height="1em" width="0pt">С8</p><p height="1em" width="0pt">С9</p><p height="1em" width="0pt">Калифорния</p><p height="1em" width="0pt">ЦБ</p><p height="1em" width="0pt">CC</p><p height="1em" width="0pt">CD</p><p height="1em" width="0pt">CE</p><p height="1em" width="0pt">CF</p><p height="1em" width="0pt">[EDX*8]</p><p height="1em" width="0pt">010</p><p height="1em" width="0pt">Д0</p><p height="1em" width="0pt">Д1</p><p height="1em" width="0pt">Д2</p><p height="1em" width="0pt">Д3</p><p height="1em" width="0pt">Д4</p><p height="1em" width="0pt">Д5</p><p height="1em" width="0pt">Д6</p><p height="1em" width="0pt">Д7</p><p height="1em" width="0pt">[EBX*8]</p><p height="1em" width="0pt">011</p><p height="1em" width="0pt">Д8</p><p height="1em" width="0pt">Д9</p><p height="1em" width="0pt">Д.А.</p><p height="1em" width="0pt">БД</p><p height="1em" width="0pt">ОКРУГ КОЛУМБИЯ</p><p height="1em" width="0pt">ДД</p><p height="1em" width="0pt">DE</p><p height="1em" width="0pt">ДФ</p><p height="1em" width="0pt">никто</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">Е0</p><p height="1em" width="0pt">Е1</p><p height="1em" width="0pt">Е2</p><p height="1em" width="0pt">Е3</p><p height="1em" width="0pt">Е4</p><p height="1em" width="0pt">Е5</p><p height="1em" width="0pt">Е6</p><p height="1em" width="0pt">Е7</p><p height="1em" width="0pt">[EBP*8]</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">Е8</p><p height="1em" width="0pt">Е9</p><p height="1em" width="0pt">советник</p><p height="1em" width="0pt">ЭБ</p><p height="1em" width="0pt">ЕС</p><p height="1em" width="0pt">ЭД</p><p height="1em" width="0pt">ЕЕ</p><p height="1em" width="0pt">ЭФ</p><p height="1em" width="0pt">[ESI*8]</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">F0</p><p height="1em" width="0pt">F1</p><p height="1em" width="0pt">F2</p><p height="1em" width="0pt">F3</p><p height="1em" width="0pt">F4</p><p height="1em" width="0pt">F5</p><p height="1em" width="0pt">F6</p><p height="1em" width="0pt">F7</p><p height="1em" width="0pt">[ЭОД*8]</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt">F8</p><p height="1em" width="0pt">F9</p><p height="1em" width="0pt">ФА</p><p height="1em" width="0pt">ФБ</p><p height="1em" width="0pt">ФК</p><p height="1em" width="0pt">ФД</p><p height="1em" width="0pt">КЭ</p><p height="1em" width="0pt">ФФ</p><p height="1em" width="0pt">1. Номенклатура [*] означает disp32 без базы, если MOD равен 00B. В противном случае [*] означает disp8 или disp32 +</p><p height="1em" width="0pt">[ЭБП]. Это обеспечивает следующие режимы адресации:</p><p height="1em" width="0pt"><b>Биты MOD Действующий адрес</b></p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">[масштабированный индекс] + disp32</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">[масштабированный индекс] + disp8 + [EBP]</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">[масштабированный индекс] + disp32 + [EBP]</p><p height="1em" width="0pt"><b>Таблица 4.5.3:</b>32-битный</p><p height="1em" width="0pt">Адресация</p><p height="1em" width="0pt">Формы с байтом SIB</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">65</p><p height="1em" width="0pt">генерирует машинный код:</p><p height="1em" width="0pt">26 34 12</p><p height="1em" width="0pt">0x1234, который генерируется как 34 12 в необработанном машинном коде, является смещением и стоит рядом с 0x26, который является байтом ModR/M.</p><p height="1em" width="0pt"><b>Пример 4.5.6.</b>Эта инструкция:</p><p height="1em" width="0pt">jmp [экс * 4 + 0x1234]</p><p height="1em" width="0pt">генерирует машинный код:</p><p height="1em" width="0pt">67 и далее 24 85 34 12 00 00</p><p height="1em" width="0pt">0x67 — это префикс переопределения размера адреса. Это означает, что если инструкция выполняет размер адреса по умолчанию, например. 16-бит, использование префикса позволяет инструкции использовать размер адреса не по умолчанию, например. 32-битная или 64-битная. Поскольку двоичный файл должен быть 16-битным, 0x67 изменяет инструкцию на 32-битный режим.</p><p height="1em" width="0pt">0xff — код операции.</p><p height="1em" width="0pt">0x24 — это байт ModR/M. Согласно таблице<a href="#filepos188918">4.5.2,</a>значение предполагает, что следует байт SIB, .</p><p height="1em" width="0pt">0x85 — это байт SIB. Согласно таблице<a href="#filepos210160">4.5.3,</a>байт 0x85 можно разбить на биты следующим образом:</p><p height="1em" width="0pt"><b>SS</b></p><p height="1em" width="0pt"><b>р/м</b></p><p height="1em" width="0pt"><b>РЕГ</b></p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Приведенные выше значения получаются через столбцы<b>SS</b>,<b>р/м</b>и, наконец, 8 столбец<b>РЕГ</b>соответственно. Общее количество битов объединено в значение 10000101, которое равно 0x85 в шестнадцатеричном формате. По умолчанию, если регистр после смещения не указан, он устанавливается в EBP.</p><p height="1em" width="0pt">регистр, поэтому всегда выбирается 6-й столбец (битовая комбинация 101). Если в примере используется другой регистр:</p><p height="1em" width="0pt"><b>Пример 4.5.7.</b>Например:</p><p height="1em" width="0pt">jmp [eax * 4 + eax + esi]</p><p height="1em" width="0pt">байт SIB становится 0x86 вместо , который находится в 7-м столбце.</p><p height="1em" width="0pt">Попробуйте проверить по таблице<a href="#filepos210160">4.5.3</a>снова.</p><a id="filepos225809" /><p height="1em" width="0pt">66</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">34 12 00 00 — водоизмещение. Как видно, смещение имеет размер 4 байта, что эквивалентно 32 битам из-за префикса переопределения размера адреса.</p><p height="1em" width="0pt"> <i>Немедленный</i>Когда инструкция принимает фиксированное значение, например. 0x1234, как операнд, это необязательное поле содержит значение. Обратите внимание, что это поле отличается от смещения: в качестве значения не обязательно используется смещение, а может быть произвольное значение чего угодно.</p><p height="1em" width="0pt"><b>Пример 4.5.8.</b>Эта инструкция:</p><p height="1em" width="0pt">мов акс, 0x1234</p><p height="1em" width="0pt">генерирует код:</p><p height="1em" width="0pt">66 б8 34 12 00 00</p><p height="1em" width="0pt">0x66 — префикс переопределения размером с операнд. Подобно префиксу переопределения размера адреса, этот префикс позволяет не использовать размер операнда по умолчанию.</p><p height="1em" width="0pt">0xb8 — один из кодов операции для инструкции mov.</p><p height="1em" width="0pt">0x1234 — это значение, которое должно быть сохранено в регистре eax. Это просто значение для сохранения непосредственно в регистре, и ничего более. С другой стороны, значение смещения является смещением для некоторого вычисления адреса.</p><p height="1em" width="0pt"><b>Упражнение 4.5.1.</b>Прочтите раздел 2.1 в Томе 2 для получения более подробной информации.</p><p height="1em" width="0pt"><b>Упражнение 4.5.2.</b>Пролистайте раздел 5.1 в томе 1. Прочтите главу 7 в томе 1. Если есть термины, которые вы не понимаете, например,</p><p height="1em" width="0pt">сегментации, не беспокойтесь, так как термины будут объяснены в следующих главах или проигнорированы.</p><p height="1em" width="0pt"><b>4.6</b></p><p height="1em" width="0pt"><b>Подробно изучить инструкцию</b></p><p height="1em" width="0pt">В справочном руководстве по инструкциям (том 2), начиная с главы 3, каждая инструкция x86 подробно документирована. Всякий раз, когда требуется точное поведение инструкции, мы всегда сначала обращаемся к этому документу.</p><p height="1em" width="0pt">Однако, прежде чем использовать документ, мы должны сначала узнать правила написания. Каждая инструкция имеет следующую общую структуру для организации информации:</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">67</p><p height="1em" width="0pt"> <i>Таблица опкодов</i>перечисляет все возможные коды операций ассемблерной инструкции.</p><p height="1em" width="0pt">Каждая таблица содержит следующие поля и может состоять из одной или нескольких строк:<b>Опкод</b></p><p height="1em" width="0pt"><b>Инструкция</b></p><p height="1em" width="0pt"><b>Открыть</b></p><p height="1em" width="0pt"><b>64/32-битный режим</b></p><p height="1em" width="0pt"><b>CPUID</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt"><b>Флаг функции</b></p><p height="1em" width="0pt"> <i>Опкод</i>показывает уникальный шестнадцатеричный номер, присвоенный инструкции. Для инструкции может быть более одного кода операции, каждый из которых кодирует вариант инструкции. Например, для одного варианта требуется один операнд, а для другого — два. В этом столбце могут быть и другие обозначения, кроме шестнадцатеричных чисел. Например, /r указывает, что байт ModR/M инструкции содержит операнд reg и операнд r/m. Подробный список находится в разделе<i>3.1.1.1</i>и<i>3.1.1.2</i>в руководстве Intel, том 2.</p><p height="1em" width="0pt"> <i>Инструкция</i>дает синтаксис ассемблерной инструкции, которую программист может использовать для написания кода. Помимо мнемонического представления кода операции, например. jmp, другие символы представляют операнды с определенными свойствами в инструкции. Например, rel8 представляет относительный адрес от 128 байт до конца инструкции до 127 байт после окончания инструкции; аналогично rel16/rel32</p><p height="1em" width="0pt">также представляет относительные адреса, но с размером операнда 16/32 бит вместо 8 бит, как rel8. Подробный список см. в разделе 3.1.1.3 тома 2.</p><p height="1em" width="0pt"> <i>Открыть</i>сокращение от<i><b>Оп</b></i><i>поручение/</i><i><b>En</b></i><i>кодирование</i>. Кодировка операнда указывает, как байт ModR/M кодирует операнды, требуемые инструкцией. Если вариант инструкции требует операндов, то дополнительная таблица с именем<i>«Кодирование операндов инструкций»</i>добавлен для объяснения кодировки операнда со следующей структурой:<b>Открыть</b></p><p height="1em" width="0pt"><b>Операнд 1</b></p><p height="1em" width="0pt"><b>Операнд 2</b></p><p height="1em" width="0pt"><b>Операнд 3</b></p><p height="1em" width="0pt"><b>Операнд 4</b></p><p height="1em" width="0pt">Большинство инструкций требуют от одного до двух операндов. Мы используем эти инструкции для нашей ОС и пропускаем инструкции, требующие трех или четырех операндов. Операнды могут быть доступны для чтения или записи или и того, и другого.</p><p height="1em" width="0pt">Символ (r) обозначает операнд, доступный для чтения, а (w) обозначает операнд, доступный для записи. Например, когда поле операнда 1 содержит ModRM:r/m</p><p height="1em" width="0pt">68</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">(r), это означает, что первый операнд закодирован в поле r/m байта ModR/M и доступен только для чтения.</p><p height="1em" width="0pt"> <i>64/32-битный режим</i>указывает, поддерживается ли последовательность кода операции в 64-битном режиме и, возможно, в 32-битном режиме.</p><p height="1em" width="0pt"> <i>Флаг функции CPUID</i>указывает, что для включения инструкции должна быть доступна определенная функция ЦП. Инструкция недействительна, если ЦП не поддерживает требуемую функцию.</p><p height="1em" width="0pt">В Linux команда:</p><p height="1em" width="0pt"> <i>Режим Compat/Leg</i>Во многих инструкциях нет этого поля, но в кате /proc/cpuinfo</p><p height="1em" width="0pt">stead заменен на Compat/Leg Mode, что означает<i>Совместимость</i>перечисляет информацию о доступных</p><p height="1em" width="0pt"> <i>или устаревший режим</i>. Этот режим включает 64-разрядные варианты процессоров инструкций и</p><p height="1em" width="0pt">его особенности во флагах</p><p height="1em" width="0pt">ции для нормальной работы в 16- или 32-битном режиме.</p><p height="1em" width="0pt">поле.</p><p height="1em" width="0pt"> <i>Описание</i>кратко поясняет вариант инструкции в таблице 4.6.1: Обозначения в</p><p height="1em" width="0pt">арендный ряд.</p><p height="1em" width="0pt">Режим Compat/Leg</p><p height="1em" width="0pt"><b>Обозначение</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt"> <i>Описание</i>указывает цель инструкций и то, как недействительный</p><p height="1em" width="0pt">Поддерживается</p><p height="1em" width="0pt">строительные работы в деталях.</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt">Не поддерживается</p><p height="1em" width="0pt">Н.Э.</p><p height="1em" width="0pt">64-битный код операции не может быть</p><p height="1em" width="0pt"> <i>Операция</i>псевдокод, реализующий инструкцию. Если описание закодировано, поскольку оно перекрывается с</p><p height="1em" width="0pt">существующий 32-битный код операции.</p><p height="1em" width="0pt">расплывчато, этот раздел является следующим лучшим источником для понимания инструкций по сборке. Синтаксис описан в разделе<i>3.1.1.9</i>в томе 2.</p><p height="1em" width="0pt"> <i>Затронутые флаги</i>перечисляет возможные изменения системных флагов в регистре EFLAGS.</p><p height="1em" width="0pt"> <i>Исключения</i>перечислите возможные ошибки, которые могут возникнуть, когда инструкция не может быть выполнена правильно. Этот раздел полезен для отладки ОС. Исключения относятся к одной из следующих категорий:</p><p height="1em" width="0pt">Исключения защищенного режима</p><p height="1em" width="0pt">Исключение режима реального адреса</p><p height="1em" width="0pt">Исключение режима Virtual-8086</p><p height="1em" width="0pt">Исключение с плавающей запятой</p><p height="1em" width="0pt">Исключение SIMD с плавающей запятой</p><p height="1em" width="0pt">Исключение режима совместимости</p><a id="filepos233869" /><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">69</p><p height="1em" width="0pt">Исключение 64-битного режима</p><p height="1em" width="0pt">Для нашей ОС мы используем только<i>Исключения защищенного режима</i>и<i>Режим реального адреса</i> <i>Исключения</i>. Подробности в разделе<i>3.1.1.13</i>и<i>3.1.1.14</i>, том 2.</p><p height="1em" width="0pt"><b>4.7</b></p><p height="1em" width="0pt"><b>Пример: инструкция jmp</b></p><p height="1em" width="0pt">Давайте посмотрим на нашу старую добрую инструкцию jmp. Во-первых, таблица кодов операций:<b>Опкод</b></p><p height="1em" width="0pt"><b>Инструкция</b></p><p height="1em" width="0pt"><b>Op/ 64-бит</b></p><p height="1em" width="0pt"><b>Compat/Leg Описание</b></p><p height="1em" width="0pt"><b>En</b></p><p height="1em" width="0pt"><b>Режим</b></p><p height="1em" width="0pt"><b>Режим</b></p><p height="1em" width="0pt">EB cb</p><p height="1em" width="0pt">СПМ, версия 8</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Короткий переход, RIP = RIP + 8-битный знак смещения</p><p height="1em" width="0pt">расширен до 64-бит</p><p height="1em" width="0pt">E9 пр.</p><p height="1em" width="0pt">СПМ, версия 16</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Н.С.</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Перейти рядом, относительно, смещение относительно следующего</p><p height="1em" width="0pt">инструкция. Не поддерживается в 64-битном режиме.</p><p height="1em" width="0pt">компакт-диск E9</p><p height="1em" width="0pt">СПМ, версия 32</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Перейти рядом, относительно, RIP = RIP + 32-битное смещение</p><p height="1em" width="0pt">знак расширен до 64-бит</p><p height="1em" width="0pt">ФФ /4</p><p height="1em" width="0pt">JMP р/м16</p><p height="1em" width="0pt">М</p><p height="1em" width="0pt">Н.С.</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Близкий переход, абсолютный косвенный, адрес = ноль-расширенный r/m16. Не поддерживается в 64-битном режиме</p><p height="1em" width="0pt">ФФ /4</p><p height="1em" width="0pt">JMP р/м32</p><p height="1em" width="0pt">М</p><p height="1em" width="0pt">Н.С.</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Перейти рядом, абсолютный косвенный адрес, указанный в r/m32.</p><p height="1em" width="0pt">Не поддерживается в 64-битном режиме</p><p height="1em" width="0pt">ФФ /4</p><p height="1em" width="0pt">JMP р/м64</p><p height="1em" width="0pt">М</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">северо-восток</p><p height="1em" width="0pt">Переход рядом, абсолютный косвенный, RIP = 64-битное смещение от регистра или памяти</p><p height="1em" width="0pt">компакт-диск EA</p><p height="1em" width="0pt">JMP часть16:16</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Инв.</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Перейти далеко, абсолютный, адрес указан в операнде</p><p height="1em" width="0pt">цена советника</p><p height="1em" width="0pt">JMP часть16:32</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Инв.</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Перейти далеко, абсолютный, адрес указан в операнде</p><p height="1em" width="0pt">ФФ /5</p><p height="1em" width="0pt">СПМ м16:16</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Перейти далеко, абсолютная непрямая связь, адрес указан в формате m16:16.</p><p height="1em" width="0pt">ФФ /5</p><p height="1em" width="0pt">СПМ м16:32</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Перейти далеко, абсолютный косвенный адрес, указанный в m16:32</p><p height="1em" width="0pt">РЕКС.W + FF /5</p><p height="1em" width="0pt">СПМ м16:64</p><p height="1em" width="0pt">Д</p><p height="1em" width="0pt">Действительный</p><p height="1em" width="0pt">Н.Э.</p><p height="1em" width="0pt">Перейти далеко, абсолютный косвенный адрес, указанный в m16:64</p><p height="1em" width="0pt"><b>Таблица 4.7.1:</b>таблица кодов операций jmp</p><p height="1em" width="0pt">В каждой строке указан вариант инструкции jmp. Первый столбец имеет код операции EB cb с эквивалентной символьной формой jmp rel8. Здесь, rel8</p><p height="1em" width="0pt">означает смещение 128 байт, считая с конца инструкции. Концом инструкции является следующий байт после последнего байта инструкции. Чтобы сделать это более конкретным, рассмотрим этот ассемблерный код: main:</p><p height="1em" width="0pt">джмп главный</p><p height="1em" width="0pt">jmp main2</p><p height="1em" width="0pt">джмп главный</p><p height="1em" width="0pt">70</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">главная2:</p><p height="1em" width="0pt">джмп 0x1234</p><p height="1em" width="0pt">генерирует машинный код:</p><p height="1em" width="0pt">основной</p><p height="1em" width="0pt">главная2</p><p height="1em" width="0pt"><b>Таблица 4.7.2:</b>Память</p><p height="1em" width="0pt">адрес</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">каждый опкод</p><p height="1em" width="0pt"><b>Адрес</b></p><p height="1em" width="0pt"><b>00</b></p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">04</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt"><b>06</b></p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">09</p><p height="1em" width="0pt"><b>Опкод</b></p><p height="1em" width="0pt">эб</p><p height="1em" width="0pt">фе</p><p height="1em" width="0pt">эб</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">эб</p><p height="1em" width="0pt">фа</p><p height="1em" width="0pt">e9</p><p height="1em" width="0pt">2б</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">Первая главная инструкция jmp генерируется в eb fe и занимает адреса 00 и 01; конец первого jmp main находится по адресу 02, после последнего байта первого jmp main, расположенного по адресу 01. Значение fe эквивалентно -2, так как код операции eb использует только байт (8 бит) для относительная адресация. Смещение равно -2, а конечный адрес первого jmp main равен 02, сложив их вместе, мы получим 00, который является адресом назначения для перехода.</p><p height="1em" width="0pt">Точно так же инструкция jmp main2 генерируется в eb 02, что означает смещение +2; конечный адрес jmp main2 равен 04, и, сложив вместе со смещением, мы получим адрес назначения 06, который является стартовой инструкцией, отмеченной меткой main2.</p><p height="1em" width="0pt">То же правило можно применить к кодировке rel16 и rel32. В примере кода jmp 0x1234 использует rel16 (что означает 2-байтовое смещение) и генерируется в e9 2b 12. Как видно из таблицы<a href="#filepos233869">4.7.1</a>показывает, код операции e9 принимает операнд cw, представляющий собой 2-байтовое смещение (раздел<i>3.1.1.1</i>, том 2). Обратите внимание на одну странную проблему: значение смещения равно 2b 12, а должно быть 34 12. В этом нет ничего плохого. Помните, что rel8/rel16/rel32 — это<i>компенсировать</i>, а не<i>адрес</i>. Смещение — это расстояние от точки. Поскольку не дается метка, кроме числа, смещение рассчитывается с начала программы.</p><p height="1em" width="0pt">В этом случае начало программы — адрес 00, конец jmp 0x1234 — адрес 092, поэтому смещение считается как 0x1234 — 0x9.</p><p height="1em" width="0pt">2, что означает, что было использовано 9 байт,</p><p height="1em" width="0pt">начиная с адреса 0.</p><p height="1em" width="0pt">= 0x122b. Это разрешило загадку!</p><p height="1em" width="0pt">Инструкции jmp с кодом операции FF /4 позволяют перейти к<i>около,</i> <i>абсолютный</i>адрес, хранящийся в регистре общего назначения или ячейке памяти; или короче, как написано в описании,<i>абсолютный косвенный</i>. Символ /4 — это столбец с цифрой 4 в таблице.<a href="#filepos174261">4.5.13</a>. Например: 3 Столбец со следующими полями:</p><p height="1em" width="0pt">АХ</p><p height="1em" width="0pt">СП</p><p height="1em" width="0pt">ЭСП</p><p height="1em" width="0pt">М45</p><p height="1em" width="0pt">XMM4</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">71</p><p height="1em" width="0pt">джмп [0x1234]</p><p height="1em" width="0pt">генерируется в:</p><p height="1em" width="0pt">26 34 12</p><p height="1em" width="0pt">Поскольку это 16-битный код, мы используем таблицу<a href="#filepos174261">4.5.1.</a>Глядя в таблицу, значение ModR/M 26 означает disp16, что означает 16-битное смещение от начала текущего index4, который является базовым адресом, хранящимся в регистре DS.</p><p height="1em" width="0pt">4 Посмотрите на записку под столом.</p><p height="1em" width="0pt">В этом случае jmp [0x1234] неявно понимается как jmp</p><p height="1em" width="0pt">[ds:0x1234], что означает, что адрес назначения находится на расстоянии 0x1234 байт от начала сегмента данных.</p><p height="1em" width="0pt">Инструкция jmp с кодом операции FF /5 позволяет перейти к<i>далекий, абсолютный</i>адрес, хранящийся в<i>ячейка памяти</i>(в отличие от /4, что означает сохранение в регистре); суммируя,<i>дальний указатель</i>. Чтобы сгенерировать такую ​​инструкцию, необходимо ключевое слово far, чтобы сообщить nasm, что мы используем указатель far: jmp far [eax]</p><p height="1em" width="0pt">генерируется в:</p><p height="1em" width="0pt">67 и далее 28</p><p height="1em" width="0pt">Так как 28 - это значение в 5-м столбце таблицы<a href="#filepos188918">4.5.25</a>который относится к 5 Помните, что префикс 67 указывает на</p><p height="1em" width="0pt">инструкция используется как 32-битная. Предварительно</p><p height="1em" width="0pt">to [eax], мы успешно генерируем инструкцию для дальнего перехода. После исправления добавляется только в том случае, если среда по умолчанию считается 16-битной при генерации.</p><p height="1em" width="0pt">ЦП запускает инструкцию, программный счетчик eIP и код сегментирует код ассемблером.</p><p height="1em" width="0pt">В регистр cs устанавливается адрес памяти, хранящийся в ячейке памяти, на которую указывает eax, и ЦП начинает выборку кода с нового адреса в cs и eip. Чтобы сделать это более конкретным, вот пример: 00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">04</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">09</p><p height="1em" width="0pt">0А</p><p height="1em" width="0pt">0В</p><p height="1em" width="0pt">0С</p><p height="1em" width="0pt">0D</p><p height="1em" width="0pt">0Э</p><p height="1em" width="0pt">0F</p><p height="1em" width="0pt">эакс</p><p height="1em" width="0pt">0x00001000 1000 34</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt">56</p><p height="1em" width="0pt">cs</p><p height="1em" width="0pt">0x00005678</p><p height="1em" width="0pt">эп</p><p height="1em" width="0pt">0x00001234</p><p height="1em" width="0pt"><b>Рисунок 4.7.1:</b>далеко</p><p height="1em" width="0pt">пример джмп,</p><p height="1em" width="0pt">с сохраненной памятью назначения</p><p height="1em" width="0pt">Дальний адрес занимает в общей сложности 6 байтов для 16-битного сегмента по адресу 0x1000, который хранится</p><p height="1em" width="0pt">и 32-битный адрес, который закодирован как</p><p height="1em" width="0pt">в eax для разыменования.</p><p height="1em" width="0pt">После</p><p height="1em" width="0pt">м16:32 из-за стола<a href="#filepos233869">4.7.1.</a>Как</p><p height="1em" width="0pt">ЦП выполняет инструкцию, код</p><p height="1em" width="0pt">сегментный регистр cs и инструкция</p><p height="1em" width="0pt">адрес указателя</p><a id="filepos245992" /><p height="1em" width="0pt">72</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">видно из рисунка выше, синяя часть — это адрес сегмента, загруженный в регистр cs со значением 0x5678; красная часть — это адрес памяти в этом сегменте, загруженный в регистр eip со значением 0x1234 и начавший выполнение оттуда.</p><p height="1em" width="0pt">Наконец, инструкции jmp с кодом операции EA переходят к прямому абсолютному адресу. Например, инструкция:</p><p height="1em" width="0pt">джмп 0x5678:0x1234</p><p height="1em" width="0pt">генерируется в:</p><p height="1em" width="0pt">шт. 34 12 78 56</p><p height="1em" width="0pt">Адрес 0x5678:0x1234 находится рядом с кодом операции, в отличие от FF /5.</p><p height="1em" width="0pt">Инструкция, которой требуется косвенный адрес в регистре eax.</p><p height="1em" width="0pt">Мы пропускаем инструкцию перехода с префиксом REX, так как это 64-битная инструкция.</p><p height="1em" width="0pt"><b>4,8</b></p><p height="1em" width="0pt"><b>Изучите скомпилированные данные</b></p><p height="1em" width="0pt">В этом разделе мы рассмотрим, как определение данных в C отображается в его ассемблерную форму. Сгенерированный код извлекается из раздела .bss. Это означает, что в отображаемом ассемблерном коде нет 6, кроме того, что показано, что таких 6 На самом деле код — это просто тип данных,</p><p height="1em" width="0pt">и часто используется для угона в</p><p height="1em" width="0pt">значение имеет эквивалентный ассемблерный код операции, который представляет программу, выполняющую инструкции для выполнения такого кода.</p><p height="1em" width="0pt">Тем не менее, мы не используем его в этом</p><p height="1em" width="0pt">ция.</p><p height="1em" width="0pt">книга.</p><p height="1em" width="0pt">Список сборки кода не случайный, а основан на<i>Глава 4</i></p><p height="1em" width="0pt">тома 1,<i>"Тип данных"</i>. В главе перечислены основные типы данных, с которыми работает аппаратное обеспечение x86, и, изучив сгенерированный ассемблерный код, можно понять, насколько близко C отображает свой синтаксис к оборудованию, а затем программист может понять, почему C подходит для программирования ОС.</p><p height="1em" width="0pt">В этом разделе используется следующая команда objdump: $ objdump -z -M intel -S -D -j .data -j .bss <объектный файл> | меньше</p><p height="1em" width="0pt"><b>Примечание:</b>нулевые байты скрыты тремя символами точек: ... Чтобы показать все нулевые байты, мы добавляем опцию -z.</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">73</p><p height="1em" width="0pt"> <i>4.8.1 Основные типы данных</i></p><p height="1em" width="0pt">Самые основные типы, с которыми работает архитектура x86, основаны на размерах, каждый в два раза больше предыдущего: 1 байт (8 бит), 2 байта (16 бит), 4 байта (32 бита), 8 байт (64 бита). ) и 16 байт (128 бит).</p><p height="1em" width="0pt">Байт Целое без знака</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt"><b>Рисунок 4.8.1:</b>Основные данные</p><p height="1em" width="0pt">Типы</p><p height="1em" width="0pt">Слово Целое без знака</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Двойное целое без знака</p><p height="1em" width="0pt">31</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Беззнаковое целое четверное слово</p><p height="1em" width="0pt">63</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Знак</p><p height="1em" width="0pt">Байт Целое со знаком</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Знак</p><p height="1em" width="0pt">Целое число со знаком слова</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Знак</p><p height="1em" width="0pt">Целое число со знаком двойного слова</p><p height="1em" width="0pt">31</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Знак</p><p height="1em" width="0pt">Целое число со знаком Quadword</p><p height="1em" width="0pt">63</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Эти типы самые простые: это просто фрагменты памяти разного размера, что позволяет ЦП эффективно обращаться к памяти. Из руководства,<i>раздел 4.1.1</i>, том 1:</p><p height="1em" width="0pt">Слова, двойные слова и четверные слова не нужно выравнивать в памяти по естественным границам. Естественными границами для слов, двойных слов и четверных слов являются четные адреса, адреса без остатка на четыре и адреса без остатка на восемь соответственно. Однако для повышения производительности программ структуры данных (особенно стеки) должны быть по возможности выровнены по естественным границам. Причина этого в том, что процессору требуется два доступа к памяти, чтобы сделать невыровненный доступ к памяти; выровненный доступ требует только одного доступа к памяти. Слово или операнд двойного слова, который пересекает 4-байтовую границу, или операнд четверного слова, который пересекает 8-байтовую границу, считаются невыровненными, и для доступа к ним требуется два отдельных цикла шины памяти.</p><p height="1em" width="0pt">Некоторые инструкции, которые работают с двойными четверными словами, требуют, чтобы операнды памяти были выровнены по естественной границе. Эти инструкции генерируют исключение общей защиты (#GP), если указан невыровненный операнд. Естественная граница для двойного четверного слова — это любой адрес, который без остатка делится на 16. Другие инструкции, работающие с двойными четверными словами.</p><p height="1em" width="0pt">74</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">разрешить невыровненный доступ (без генерации исключения общей защиты). Однако для доступа к невыровненным данным из памяти требуются дополнительные циклы шины памяти.</p><p height="1em" width="0pt">В C следующие примитивные типы (должны включать stdint.h) сопоставляются с фундаментальными типами:</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdint.h></p><p height="1em" width="0pt">uint8_t<b>байт</b>= 0x12;</p><p height="1em" width="0pt">uint16_t<b>слово</b>= 0x1234;</p><p height="1em" width="0pt">uint32_t<b>двойное слово</b>= 0x12345678;</p><p height="1em" width="0pt">uint64_t<b>QWORD</b>= 0x123456789abcdef;</p><p height="1em" width="0pt"><b>неподписанный</b>__int128<b>dqword1</b>= (__int128) 0x123456789abcdef;<b>неподписанный</b>__int128<b>dqword2</b>= (__int128) 0x123456789abcdef << 64;<b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">0804a018 <байт>:</p><p height="1em" width="0pt">804а018:</p><p height="1em" width="0pt">12 00</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">al,BYTE PTR [eax]</p><p height="1em" width="0pt">0804a01a <слово>:</p><p height="1em" width="0pt">804а01а:</p><p height="1em" width="0pt">34 12</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">ал, 0x12</p><p height="1em" width="0pt">0804a01c <двойное слово>:</p><p height="1em" width="0pt">804а01с:</p><p height="1em" width="0pt">78 56</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a074 <_end+0x48></p><p height="1em" width="0pt">804а01е:</p><p height="1em" width="0pt">34 12</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">ал, 0x12</p><p height="1em" width="0pt">0804a020 <qword>:</p><p height="1em" width="0pt">804а020:</p><p height="1em" width="0pt">эф</p><p height="1em" width="0pt">вне</p><p height="1em" width="0pt">дх, акс</p><p height="1em" width="0pt">804а021:</p><p height="1em" width="0pt">компакт-диск аб</p><p height="1em" width="0pt">инт</p><p height="1em" width="0pt">0xab</p><p height="1em" width="0pt">804а023:</p><p height="1em" width="0pt">89 67 45</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [edi+0x45],esp</p><p height="1em" width="0pt">804а026:</p><p height="1em" width="0pt">23 01</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">eax,DWORD PTR [ecx]</p><p height="1em" width="0pt">0000000000601040 <dqword1>:</p><p height="1em" width="0pt">601040:</p><p height="1em" width="0pt">эф</p><p height="1em" width="0pt">вне</p><p height="1em" width="0pt">дх, акс</p><p height="1em" width="0pt">601041:</p><p height="1em" width="0pt">компакт-диск аб</p><p height="1em" width="0pt">инт</p><p height="1em" width="0pt">0xab</p><p height="1em" width="0pt">601043:</p><p height="1em" width="0pt">89 67 45</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [rdi+0x45],esp</p><p height="1em" width="0pt">601046:</p><p height="1em" width="0pt">23 01</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">eax,DWORD PTR [rcx]</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">75</p><p height="1em" width="0pt">601048:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">60104а:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">60104с:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">60104e:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">0000000000601050 <dqword2>:</p><p height="1em" width="0pt">601050:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601052:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601054:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601056:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601058:</p><p height="1em" width="0pt">эф</p><p height="1em" width="0pt">вне</p><p height="1em" width="0pt">дх, акс</p><p height="1em" width="0pt">601059:</p><p height="1em" width="0pt">компакт-диск аб</p><p height="1em" width="0pt">инт</p><p height="1em" width="0pt">0xab</p><p height="1em" width="0pt">60105б:</p><p height="1em" width="0pt">89 67 45</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [rdi+0x45],esp</p><p height="1em" width="0pt">60105е:</p><p height="1em" width="0pt">23 01</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">eax,DWORD PTR [rcx]</p><p height="1em" width="0pt">gcc генерирует переменные byte, word, dword, qword, dqword1, dword2, записанные ранее, с соответствующими значениями, выделенными тем же цветом; переменные того же типа также выделяются тем же цветом. Поскольку это раздел данных, листинг сборки не имеет смысла. Когда байт объявляется с помощью uint8_t, gcc гарантирует, что размер байта всегда равен 1 байту. Но внимательный читатель может заметить 00</p><p height="1em" width="0pt">значение рядом со значением 12 в байтовой переменной. Это нормально, так как gcc избегает смещения памяти, добавляя дополнительные<i>байты заполнения</i>. Чтобы было легче увидеть, мы смотрим на вывод readelf раздела .data: $ readelf -x .data hello</p><p height="1em" width="0pt">вывод (цвета отмечают, какие значения принадлежат каким переменным): Шестнадцатеричный дамп раздела «.data»:</p><p height="1em" width="0pt">0x00601020 00000000 00000000 00000000 00000000 ................</p><p height="1em" width="0pt">0x00601030 12003412 78563412 efcdab89 67452301 ..4.xV4.....gE#.</p><p height="1em" width="0pt">0x00601040 efcdab89 67452301 00000000 00000000 ....gE#.........</p><p height="1em" width="0pt">0x00601050 00000000 00000000 efcdab89 67452301 ............gE#.</p><p height="1em" width="0pt">Как видно из вывода readelf, переменные выделяются памяти в соответствии с их типами и в объявленном порядке программой.</p><p height="1em" width="0pt">76</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">mer (цвета соответствуют переменным). Intel — это машина с прямым порядком байтов, что означает, что меньшие адреса содержат байты с меньшими значениями, большие адреса содержат байты с большими значениями. Например, 0x1234 отображается как 34 12; то есть 34 сначала появляется по адресу 0x601032, затем 12 по адресу 0x601033.</p><p height="1em" width="0pt">Десятичные значения внутри байта не изменились, поэтому мы видим 34 12 вместо 43 21. Поначалу это довольно запутанно, но вы скоро к этому привыкнете.</p><p height="1em" width="0pt">Кроме того, разве не избыточно, когда тип char всегда уже равен 1 байту, и зачем вообще добавлять int8_t? Правда в том, что тип char не обязательно имеет размер 1 байт, а только минимальный размер 1 байт. В C байт определяется как размер символа, а символ определяется как наименьшая адресуемая единица базовой аппаратной платформы. Существуют аппаратные устройства, в которых наименьшая адресуемая единица имеет размер 16 бит или даже больше, что означает, что размер char составляет 2 байта, а «байт» на таких платформах фактически представляет собой 2 единицы 8-битных байтов.</p><p height="1em" width="0pt">Не все архитектуры поддерживают тип double quadword. Тем не менее, gcc обеспечивает поддержку 128-битных чисел и генерирует код, когда ЦП поддерживает это (то есть ЦП должен быть 64-битным). Указав переменную типа __int128 или беззнакового __int128, мы получим 128-битную переменную. Если процессор не поддерживает 64-битный режим, gcc выдает ошибку.</p><p height="1em" width="0pt">Типы данных в C, представляющие основные типы данных, также называются<i>беззнаковые числа</i>. Помимо численных вычислений, беззнаковые числа используются как инструмент для структурирования данных в памяти; мы увидим это приложение позже в книге, когда различные структуры данных будут организованы в битовые группы.</p><p height="1em" width="0pt">Во всех приведенных выше примерах, когда значение переменной меньшего размера присваивается переменной большего размера, значение легко помещается в большую переменную. Напротив, значение переменной большего размера присваивается переменной меньшего размера, возникают два сценария: значение больше, чем максимальное значение переменной с меньшим макетом, поэтому его необходимо усечь до размера переменной. и вызывая неправильное значение.</p><p height="1em" width="0pt">Значение меньше максимального значения переменной с меньшим макетом, поэтому оно соответствует переменной.</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">77</p><p height="1em" width="0pt">Однако значение может быть неизвестно до времени выполнения и может быть значением, поэтому лучше не допускать, чтобы такое неявное преобразование выполнялось компилятором, а явно контролировалось программистом. В противном случае это вызовет тонкие ошибки, которые трудно отловить, поскольку ошибочные значения могут редко использоваться для воспроизведения ошибок.</p><p height="1em" width="0pt"> <i>4.8.2 Типы данных указателя</i></p><p height="1em" width="0pt">Указатели — это переменные, которые содержат адреса памяти. x86 работает с двумя типами указателей:</p><p height="1em" width="0pt"> <i>Ближний указатель</i>представляет собой 16-битное/32-битное смещение внутри сегмента, также называемое<i>фактический адрес</i>.</p><p height="1em" width="0pt"> <i>Дальний указатель</i>также является смещением, как ближний указатель, но с явным селектором сегмента.</p><p height="1em" width="0pt">Рядом с указателем</p><p height="1em" width="0pt"><b>Рисунок 4.8.2:</b>Числовой</p><p height="1em" width="0pt">Данные</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Типы</p><p height="1em" width="0pt">31</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Дальний указатель или логический адрес</p><p height="1em" width="0pt">Выбор сегмента</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">47</p><p height="1em" width="0pt">32 31</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">C поддерживает только ближние указатели, поскольку дальние указатели зависят от платформы, например x86. В коде приложения вы можете предположить, что адрес текущего сегмента начинается с 0, поэтому смещение фактически представляет собой любой адрес памяти от 0 до максимального адреса.</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdint.h></p><p height="1em" width="0pt">int8_t я = 0;</p><p height="1em" width="0pt">int8_t<b>*p1</b>= (int8_t *) 0x1234;</p><p height="1em" width="0pt">int8_t<b>*p2</b>= & я;</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">0000000000601030 <p1>:</p><p height="1em" width="0pt">601030:</p><p height="1em" width="0pt">34 12</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">ал, 0x12</p><p height="1em" width="0pt">601032:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601034:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601036:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">0000000000601038 <p2>:</p><p height="1em" width="0pt">601038:</p><p height="1em" width="0pt">41 10 60 00</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">БАЙТ PTR [r8+0x0],spl</p><p height="1em" width="0pt">60103с:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">60103e:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">Разборка раздела .bss:</p><p height="1em" width="0pt">0000000000601040 <__bss_start>:</p><p height="1em" width="0pt">601040:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">0000000000601041 <i>:</p><p height="1em" width="0pt">601041:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601043:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601045:</p><p height="1em" width="0pt">00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [rax],al</p><p height="1em" width="0pt">601047:</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">.байт 0x0</p><p height="1em" width="0pt">Указатель p1 содержит прямой адрес со значением 0x1234. Указатель p2 содержит адрес переменной i. Обратите внимание, что оба указателя имеют размер 8 байт (или 4 байта, если они 32-разрядные).</p><p height="1em" width="0pt"> <i>4.8.3 Тип данных битового поля</i></p><p height="1em" width="0pt">А<i>битовое поле</i>представляет собой непрерывную последовательность битов. Битовые поля позволяют структурировать данные на битовом уровне. Например, 32-битные данные могут содержать несколько битовых полей, которые представляют несколько разных фрагментов информации, таких как биты 0–4.</p><p height="1em" width="0pt">указывает размер структуры данных, биты 5-6 определяют разрешения и так далее. Структуры данных на уровне битов являются общими для низкоуровневого программирования.</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>структура</b>битовое_поле {</p><p height="1em" width="0pt"><b>инт</b>данные1:8;</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">79</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">Битовое поле</p><p height="1em" width="0pt"><b>Рисунок 4.8.3:</b>Числовой</p><p height="1em" width="0pt">Данные</p><p height="1em" width="0pt">Типы (Источник: Рисунок 4-6, Том</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Длина поля</p><p height="1em" width="0pt">Наименее</p><p height="1em" width="0pt">Значительный</p><p height="1em" width="0pt">Кусочек</p><p height="1em" width="0pt"><b>инт</b>данные2:8;</p><p height="1em" width="0pt"><b>инт</b>данные3:8;</p><p height="1em" width="0pt"><b>инт</b>данные4:8;</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt"><b>структура</b>бит_поле2 {</p><p height="1em" width="0pt"><b>инт</b>данные1:8;</p><p height="1em" width="0pt"><b>инт</b>данные2:8;</p><p height="1em" width="0pt"><b>инт</b>данные3:8;</p><p height="1em" width="0pt"><b>инт</b>данные4:8;</p><p height="1em" width="0pt"><b>уголь</b>данные5:4;</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt"><b>структура</b>normal_struct {</p><p height="1em" width="0pt"><b>инт</b>данные1;</p><p height="1em" width="0pt"><b>инт</b>данные2;</p><p height="1em" width="0pt"><b>инт</b>данные3;</p><p height="1em" width="0pt"><b>инт</b>данные4;</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt"><b>структура</b>normal_struct<b>нс</b>"="</p><p height="1em" width="0pt">.данные1 =<b>0x12345678</b>,</p><p height="1em" width="0pt">.данные2 =<b>0x9abcdef0</b>,</p><p height="1em" width="0pt">.данные3 =<b>0x12345678</b>,</p><p height="1em" width="0pt">.данные4 =<b>0x9abcdef0</b>,</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt">80</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>в я</b>= 0x12345678;</p><p height="1em" width="0pt"><b>структура</b>битовое_поле<b>бойфренд</b>"="</p><p height="1em" width="0pt">.данные1 =<b>0x12</b>,</p><p height="1em" width="0pt">.данные2 =<b>0x34</b>,</p><p height="1em" width="0pt">.данные3 =<b>0x56</b>,</p><p height="1em" width="0pt">.данные4 =<b>0x78</b></p><p height="1em" width="0pt">};</p><p height="1em" width="0pt"><b>структура</b>битовое_поле2<b>bf2</b>"="</p><p height="1em" width="0pt">.данные1 =<b>0x12</b>,</p><p height="1em" width="0pt">.данные2 =<b>0x34</b>,</p><p height="1em" width="0pt">.данные3 =<b>0x56</b>,</p><p height="1em" width="0pt">.данные4 =<b>0x78</b>,</p><p height="1em" width="0pt">.данные5 =<b>0xf</b></p><p height="1em" width="0pt">};</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i>Каждой переменной и ее значению присваивается уникальный цвет в листинге ассемблера ниже:</p><p height="1em" width="0pt">0804a018 <нс>:</p><p height="1em" width="0pt">804а018: 78 56</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a070 <_end+0x34></p><p height="1em" width="0pt">804a01a: 34 12</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">ал, 0x12</p><p height="1em" width="0pt">804a01c: f0 de bc 9a 78 56 34</p><p height="1em" width="0pt">заблокировать fidivr WORD PTR [edx+ebx*4+0x12345678]</p><p height="1em" width="0pt">804а023: 12</p><p height="1em" width="0pt">804a024: f0 de bc 9a 78 56 34</p><p height="1em" width="0pt">заблокировать fidivr WORD PTR [edx+ebx*4+0x12345678]</p><p height="1em" width="0pt">804a02b: 12</p><p height="1em" width="0pt">0804a028 <я>:</p><p height="1em" width="0pt">804а028: 78 56</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a080 <_end+0x44></p><p height="1em" width="0pt">804a02a: 34 12</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">ал, 0x12</p><p height="1em" width="0pt">0804a02c <bf>:</p><p height="1em" width="0pt">804a02c: 12 34 56</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">dh,BYTE PTR [esi+edx*2]</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">81</p><p height="1em" width="0pt">804a02f: 78 12</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a043 <_end+0x7></p><p height="1em" width="0pt">0804a030 <bf2>:</p><p height="1em" width="0pt">804a030: 12 34 56</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">dh,BYTE PTR [esi+edx*2]</p><p height="1em" width="0pt">804a033: 78 0f</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a044 <_end+0x8></p><p height="1em" width="0pt">804a035: 00 00</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [eax],al</p><p height="1em" width="0pt">804а037:00</p><p height="1em" width="0pt">.байт 0x0</p><p height="1em" width="0pt">Пример кода создает 4 переменные: ns, i, bf, bf2. В определении структур normal_struct и bit_field указано 4 целых числа. bit_field указывает дополнительную информацию рядом с именем его члена, разделенную двоеточием, например.</p><p height="1em" width="0pt">.data1 : 8. Эта дополнительная информация представляет собой разрядность каждой битовой группы.</p><p height="1em" width="0pt">Это означает, что, несмотря на то, что он определен как int, .data1 потребляет только 8 бит информации. Если дополнительные элементы данных указаны после .data1, возможны два сценария:</p><p height="1em" width="0pt">Если новые элементы данных помещаются в оставшиеся биты после .data, которые составляют 24 бита7, то общий размер структуры bit_field по-прежнему составляет 4 байта или 7. Поскольку .data1 объявлен как int, 32</p><p height="1em" width="0pt">биты по-прежнему распределены, но .data1 может</p><p height="1em" width="0pt">32 бита.</p><p height="1em" width="0pt">доступ только к 8 битам информации.</p><p height="1em" width="0pt">Если новые элементы данных не подходят, оставшиеся 24 бита (3 байта) все еще выделяются. Однако новым членам данных выделяются совершенно новые хранилища без использования предыдущих 24 бит.</p><p height="1em" width="0pt">В примере 4 члена данных: .data1, .data2, .data3 и .data4, каждый из которых может получить доступ к 8 битам информации, а вместе могут получить доступ ко всем 4 байтам целого числа, сначала объявленного .data1. Как видно из сгенерированного ассемблерного кода, значения bf следуют естественному порядку, как написано в коде C: 12 34 56 78, поскольку каждое значение является отдельным членом. Напротив, значение i представляет собой число в целом, поэтому оно подчиняется правилу прямого порядка следования байтов и, таким образом, содержит значение 78 56 34 12. Обратите внимание, что 804a02f — это адрес последнего байта в bf, но рядом с ним число 12, несмотря на то, что 78 является последним числом в нем. Это дополнительное число 12 не принадлежит значению bf. objdump просто путают, что 78 - это код операции; 78 соответствует инструкции js и требует операнда.</p><p height="1em" width="0pt">По этой причине objdump захватывает любой следующий байт после 78 и помещает его туда. objdump — это, в конце концов, инструмент для отображения ассемблерного кода. Лучшим инструментом для использования является gdb, который мы изучим в следующей главе. Но для этой главы достаточно objdump.</p><p height="1em" width="0pt">82</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">В отличие от bf, каждый член данных в ns полностью выделяется как целое число, 4</p><p height="1em" width="0pt">байт каждый, всего 16 байт. Как мы видим, битовое поле и обычная структура отличаются: данные структуры битового поля находятся на уровне битов, тогда как обычная структура работает на уровне байтов.</p><p height="1em" width="0pt">Наконец, структура bf28 такая же, как у bf9, за исключением того, что она содержит одно 8-битное_поле2.</p><p height="1em" width="0pt">9 битовое_поле</p><p height="1em" width="0pt">больше член данных: .data5, и определяется как char. По этой причине еще 4 байта выделены только для .data5, даже несмотря на то, что он может получить доступ только к 4 битам информации, и окончательное значение bf2: 12 34 56 78 0f 00 00 00. Остальные 3 байта должны быть доступны среднее значение указателя или приведение к другому типу данных, который может полностью получить доступ ко всем 4 байтам.</p><p height="1em" width="0pt"><b>Упражнение 4.8.1.</b>Что происходит, когда определение структуры bit_field и переменной bf изменяется на:</p><p height="1em" width="0pt">структура битового_поля {</p><p height="1em" width="0pt">целые данные1:8;</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt">структура битового_поля bf = {</p><p height="1em" width="0pt">.данные1 = 0x1234,</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt">Каково будет значение .data1?</p><p height="1em" width="0pt"><b>Упражнение 4.8.2.</b>Что происходит, когда определение структуры bit_field2 изменяется на:</p><p height="1em" width="0pt">структура битовое_поле2 {</p><p height="1em" width="0pt">целые данные1:8;</p><p height="1em" width="0pt">целые данные5:32;</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt">Какова структура переменной типа bit_field2?</p><p height="1em" width="0pt"> <i>4.8.4 Строковые типы данных</i></p><p height="1em" width="0pt">Хотя они имеют одно и то же имя, строка, определенная x86, отличается от строки в C. x86 определяет строку как<i>«непрерывные последовательности битов, байтов,</i> <i>слова или двойные слова»</i>. С другой стороны, C определяет строку как массив 1-байтовых символов с нулем в качестве последнего элемента массива.</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">83</p><p height="1em" width="0pt">делать<i>строка с завершающим нулем</i>. Это означает, что строки в x86 являются массивами, а не строками C. Программист может определить массив байтов, слов или двойных слов с помощью char или uint8_t, short или uint16_t и int или uint32_t, за исключением массива битов. Однако такую ​​функцию можно легко реализовать, поскольку битовый массив — это, по сути, любой массив байтов, слов или двойных слов, но работающий на битовом уровне.</p><p height="1em" width="0pt">Следующий код демонстрирует, как определить типы данных массива (строки):<i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdint.h></p><p height="1em" width="0pt">uint8_t<b>а8[2]</b>= {0x12, 0x34};</p><p height="1em" width="0pt">uint16_t<b>а16[2]</b>= {0x1234, 0x5678};</p><p height="1em" width="0pt">uint32_t<b>а32[2]</b>= {0x12345678, 0x9abcdef0};</p><p height="1em" width="0pt">uint64_t<b>а64[2]</b>= {0x123456789abcdef0, 0x123456789abcdef0</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">0804a018 <a8>:</p><p height="1em" width="0pt">804a018: 12 34 00</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">dh,BYTE PTR [eax+eax*1]</p><p height="1em" width="0pt">804a01b: 00 34 12</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [edx+edx*1],dh</p><p height="1em" width="0pt">0804a01c <a16>:</p><p height="1em" width="0pt">804a01c: 34 12</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">ал, 0x12</p><p height="1em" width="0pt">804а01е: 78 56</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a076 <_end+0x3a></p><p height="1em" width="0pt">0804a020 <a32>:</p><p height="1em" width="0pt">804а020: 78 56</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a078 <_end+0x3c></p><p height="1em" width="0pt">804а022: 34 12</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">ал, 0x12</p><p height="1em" width="0pt">804a024: f0 de bc 9a f0 de bc</p><p height="1em" width="0pt">заблокировать fidivr WORD PTR [edx+ebx*4-0x65432110]</p><p height="1em" width="0pt">804a02b: 9а</p><p height="1em" width="0pt">0804a028 <a64>:</p><p height="1em" width="0pt">804a028: f0 de bc 9a 78 56 34</p><p height="1em" width="0pt">заблокировать fidivr WORD PTR [edx+ebx*4+0x12345678]</p><p height="1em" width="0pt">804a02f: 12</p><p height="1em" width="0pt">804a030: f0 de bc 9a 78 56 34</p><p height="1em" width="0pt">заблокировать fidivr WORD PTR [edx+ebx*4+0x12345678]</p><p height="1em" width="0pt">84</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">804а037: 12</p><p height="1em" width="0pt">Несмотря на то, что a8 представляет собой массив из 2 элементов, каждый из которых имеет длину 1 байт, он по-прежнему занимает 4 байта. Опять же, чтобы обеспечить естественное выравнивание для лучшей производительности, gcc дополняет лишние нулевыми байтами. Как показано в ассемблерном листинге, фактическое значение a8 равно 12 34 00 00, где a8[0] равно 12, а a8[1]</p><p height="1em" width="0pt">равняется 34.</p><p height="1em" width="0pt">Затем идет a16 с 2 элементами по 2 байта каждый. Поскольку 2 элемента составляют всего 4 байта, что соответствует естественному выравниванию, gcc не дополняет ни одного байта. Значение a16 равно 34 12 78 56, где a16[0] равно 34 12.</p><p height="1em" width="0pt">и a16[1] равно 78 56. Обратите внимание, что objdump снова перепутан, так как de — это код операции для инструкции fidivr (за исключением обратного деления), которая требует другого операнда, поэтому objdump захватывает любые следующие байты, которые имеют для него смысл. для создания «операнда». Только выделенные значения принадлежат a32.</p><p height="1em" width="0pt">Далее идет a32, с 2 элементами по 4 байта. Как и в приведенных выше массивах, значение a32[0] равно 78 56 34 12, значение a32[1] равно f0 de bc 9a, именно то, что назначено в коде C.</p><p height="1em" width="0pt">Наконец, это a64, тоже с 2 элементами, но по 8 байт. Общий размер a64 составляет 16 байт, что соответствует естественному выравниванию, поэтому байты заполнения не добавляются. Значения a64[0] и a64[1] одинаковы: f0</p><p height="1em" width="0pt">de bc 9a 78 56 34 12, который был неверно истолкован в инструкции fidivr.</p><p height="1em" width="0pt">а8:</p><p height="1em" width="0pt">12 | 34</p><p height="1em" width="0pt"><b>Рисунок 4.8.4:</b>а8,</p><p height="1em" width="0pt">а16,</p><p height="1em" width="0pt">а32 и</p><p height="1em" width="0pt">а16:</p><p height="1em" width="0pt">34 12</p><p height="1em" width="0pt">| 78 56</p><p height="1em" width="0pt">макеты памяти a64</p><p height="1em" width="0pt">а32:</p><p height="1em" width="0pt">78 56 34 12</p><p height="1em" width="0pt">| f0 де бк 9а</p><p height="1em" width="0pt">а64:</p><p height="1em" width="0pt">f0 де бк 9а 78 56 34 12</p><p height="1em" width="0pt">| f0 де бк 9а 78 56 34 12</p><p height="1em" width="0pt">Однако помимо одномерных массивов, которые напрямую отображаются на тип аппаратной строки, C предоставляет собственный синтаксис для многомерных массивов:<i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdint.h></p><p height="1em" width="0pt">uint8_t<b>а2[2][2]</b>"="</p><p height="1em" width="0pt">{0x12, 0x34},</p><p height="1em" width="0pt">{0x56, 0x78}</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">85</p><p height="1em" width="0pt">uint8_t<b>а3[2][2][2]</b>"="</p><p height="1em" width="0pt">{{0x12, 0x34},</p><p height="1em" width="0pt">{0x56, 0x78}},</p><p height="1em" width="0pt">{{0x9a, 0xbc},</p><p height="1em" width="0pt">{0xde, 0xff}},</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">0804a018 <a2>:</p><p height="1em" width="0pt">804a018: 12 34 56</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">dh,BYTE PTR [esi+edx*2]</p><p height="1em" width="0pt">804a01b: 78 12</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">804a02f <_end+0x7></p><p height="1em" width="0pt">0804a01c <a3>:</p><p height="1em" width="0pt">804a01c: 12 34 56</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">dh,BYTE PTR [esi+edx*2]</p><p height="1em" width="0pt">804a01f: 78 9а</p><p height="1em" width="0pt">js</p><p height="1em" width="0pt">8049fbb <_DYNAMIC+0xa7></p><p height="1em" width="0pt">804a021: до н.э.</p><p height="1em" width="0pt">.byte 0xbc</p><p height="1em" width="0pt">804a022: де ифф</p><p height="1em" width="0pt">фдиврп ул(7),ул</p><p height="1em" width="0pt">Технически многомерные массивы похожи на обычные массивы: в конце концов, общий размер преобразуется в плоские выделенные байты. Массив 2 x 2 занимает 4 байта; массиву 2 × 2 × 2 выделяется 8 байт, как видно из ассемблерного листинга a210 и a3. В низкоуровневом ассемблерном коде 10 Опять перепутал objdump и поставил</p><p height="1em" width="0pt">число 12 рядом с 78 в листинге a3.</p><p height="1em" width="0pt">представление одинаково между a[4] и a[2][2]. Однако в высокоуровневом коде C разница огромна. Синтаксис многомерного массива позволяет программисту мыслить концепциями более высокого уровня вместо того, чтобы вручную переводить концепции высокого уровня в код низкого уровня и одновременно работать с концепциями высокого уровня в голове.</p><p height="1em" width="0pt"><b>Пример 4.8.1.</b>Следующий двумерный массив может содержать список из 2 имен длиной 10:</p><p height="1em" width="0pt"><b>уголь</b>имена[2][10] = {</p><p height="1em" width="0pt">"Джон␣Доу",</p><p height="1em" width="0pt">"Джейн␣Доу"</p><a id="filepos283477" /><p height="1em" width="0pt">86</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">};</p><p height="1em" width="0pt">Чтобы получить доступ к имени, мы просто корректируем индекс столбца11, например. имена [0], 11 Левый индекс называется индексом столбца</p><p height="1em" width="0pt">поскольку он изменяет индекс на основе</p><p height="1em" width="0pt">имена[1]. Чтобы получить доступ к отдельному символу в имени, мы используем столбец строки.</p><p height="1em" width="0pt">index12 например. имена[0][0] дают символ «J», имена[0][1] дают 12 То же самое с индексом столбца, справа</p><p height="1em" width="0pt">индекс называется индексом строки, поскольку он</p><p height="1em" width="0pt">символ «о» и так далее.</p><p height="1em" width="0pt">изменяет индекс на основе строки.</p><p height="1em" width="0pt">Без такого синтаксиса нам нужно создать 20-байтовый массив, например. имена[20], и всякий раз, когда мы хотим получить доступ к персонажу, например. чтобы проверить, содержит ли имя число, нам нужно вычислить индекс вручную.</p><p height="1em" width="0pt">Это будет отвлекать, так как нам постоянно нужно переключать мысли между реальной проблемой и проблемой перевода.</p><p height="1em" width="0pt">Поскольку это повторяющийся шаблон, C абстрагируется от этой проблемы с помощью синтаксиса для определения и управления многомерным массивом. На этом примере мы можем ясно увидеть силу абстракции, которую может дать нам язык. Было бы идеально, если бы программист обладал такой мощью, чтобы определять любой синтаксис, подходящий для стоящей перед ним задачи.</p><p height="1em" width="0pt">Не многие языки предоставляют такую ​​возможность. К счастью, с помощью макроса C мы можем частично достичь этой цели.</p><p height="1em" width="0pt">Во всех случаях массив гарантированно генерирует непрерывные байты памяти, независимо от его размеров.</p><p height="1em" width="0pt"><b>Упражнение 4.8.3.</b>В чем разница между многомерным массивом и массивом указателей или даже указателями указателей?</p><p height="1em" width="0pt"><b>4.9</b></p><p height="1em" width="0pt"><b>Изучите скомпилированный код</b></p><p height="1em" width="0pt">В этом разделе будет рассмотрено, как компилятор преобразует высокоуровневый код в ассемблерный код, который может выполнять ЦП, и показано, как общие шаблоны ассемблера помогают создавать синтаксис более высокого уровня. Параметр -S добавлен в objdump, чтобы лучше продемонстрировать связь между высокоуровневым и низкоуровневым кодом.</p><p height="1em" width="0pt">В этом разделе в команду objdump добавлена ​​опция --no-show-raw-insn, чтобы исключить коды операций для ясности:</p><p height="1em" width="0pt">$ objdump --no-show-raw-insn -M intel -S -D <объектный файл> | меньше</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">87</p><p height="1em" width="0pt"> <i>4.9.1 Передача данных</i></p><p height="1em" width="0pt">В предыдущем разделе показано, как создаются различные типы данных и как они размещаются в памяти. После выделения памяти для переменных они должны быть доступны и доступны для записи. Команды передачи данных перемещают данные (байты, слова, двойные слова или четверные слова) между памятью и регистрами и между регистрами, эффективно читая из источника хранения и записывая в другой источник хранения.</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdint.h></p><p height="1em" width="0pt">int32_t я = 0x12345678;</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>инт</b>дж = я;</p><p height="1em" width="0pt"><b>инт</b>к = 0xabcdef;</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">080483db <основной>:</p><p height="1em" width="0pt">#include <stdint.h></p><p height="1em" width="0pt">int32_t я = 0x12345678;</p><p height="1em" width="0pt">int main(int argc, char *argv[]) {</p><p height="1em" width="0pt">80483дб:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">80483dc:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">80483де:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">интервал j = я;</p><p height="1em" width="0pt">80483e1:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, дс: 0x804a018</p><p height="1em" width="0pt">80483e6:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x8],eax</p><p height="1em" width="0pt">интервал k = 0xabcdef;</p><p height="1em" width="0pt">80483e9:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x4],0xabcdef</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">80483f0:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">80483f5:</p><p height="1em" width="0pt">оставлять</p><p height="1em" width="0pt">88</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">80483f6:</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">80483f7:</p><p height="1em" width="0pt">хчг</p><p height="1em" width="0pt">топор, топор</p><p height="1em" width="0pt">80483f9:</p><p height="1em" width="0pt">хчг</p><p height="1em" width="0pt">топор, топор</p><p height="1em" width="0pt">80483fb:</p><p height="1em" width="0pt">хчг</p><p height="1em" width="0pt">топор, топор</p><p height="1em" width="0pt">80483fd:</p><p height="1em" width="0pt">хчг</p><p height="1em" width="0pt">топор, топор</p><p height="1em" width="0pt">80483ff:</p><p height="1em" width="0pt">нет</p><p height="1em" width="0pt">Общее перемещение данных выполняется с помощью инструкции mov. Обратите внимание, что несмотря на то, что инструкция называется mov, она фактически копирует данные из одного места назначения в другое.</p><p height="1em" width="0pt">Красная инструкция копирует данные из регистра esp в регистр ebp. Эта инструкция mov перемещает данные между регистрами и получает код операции 89.</p><p height="1em" width="0pt">Синие инструкции копируют данные из одной области памяти (переменная i) в другую (переменная j). Не существует перемещения данных из памяти в память; для этого требуются две инструкции mov: одна для копирования данных из ячейки памяти в регистр, а другая для копирования данных из регистра в целевую ячейку памяти.</p><p height="1em" width="0pt">Розовая инструкция копирует немедленное значение в память. Наконец, зеленая инструкция копирует немедленные данные в регистр.</p><p height="1em" width="0pt"> <i>4.9.2 Выражения</i></p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>инт</b>выражение(<b>инт</b>я,<b>инт</b>к)</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt"><b>инт</b>добавить = я + j;</p><p height="1em" width="0pt"><b>инт</b>суб = я - j;</p><p height="1em" width="0pt"><b>инт</b>мул = я * j;</p><p height="1em" width="0pt"><b>инт</b>дел = я / j;</p><p height="1em" width="0pt"><b>инт</b>мод = я % j;</p><p height="1em" width="0pt"><b>инт</b>отрицательный = -я;</p><p height="1em" width="0pt"><b>инт</b>и = я и j;</p><p height="1em" width="0pt"><b>инт</b>или = я | дж;</p><p height="1em" width="0pt"><b>инт</b>xor = я ^ j;</p><p height="1em" width="0pt"><b>инт</b>не = ~ я;</p><p height="1em" width="0pt"><b>инт</b>шл = i << 8;</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">89</p><p height="1em" width="0pt"><b>инт</b>шр = я >> 8;</p><p height="1em" width="0pt"><b>уголь</b>равно1 = (я == j);</p><p height="1em" width="0pt"><b>инт</b>равно2 = (я == j);</p><p height="1em" width="0pt"><b>уголь</b>больше = (i > j);</p><p height="1em" width="0pt"><b>уголь</b>меньше = (i < j);</p><p height="1em" width="0pt"><b>уголь</b>больше_равно = (я >= j);</p><p height="1em" width="0pt"><b>уголь</b>меньше_равно = (я <= j);</p><p height="1em" width="0pt"><b>инт</b>логическое_и = я && j;</p><p height="1em" width="0pt"><b>инт</b>логическое_или = я || дж;</p><p height="1em" width="0pt">++я;</p><p height="1em" width="0pt">--я;</p><p height="1em" width="0pt"><b>инт</b>i1 = i++;</p><p height="1em" width="0pt"><b>инт</b>i2 = ++i;</p><p height="1em" width="0pt"><b>инт</b>i3 = i--;</p><p height="1em" width="0pt"><b>инт</b>я4 = --я;</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i>Полный список сборок очень длинный. По этой причине мы исследуем выражение за выражением.</p><p height="1em" width="0pt"> <i>Выражение:</i>инт добавить = я + j;</p><p height="1em" width="0pt">80483e1:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">edx,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">80483e4:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">80483e7:</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">еакс, эдкс</p><p height="1em" width="0pt">80483e9:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x34],eax</p><p height="1em" width="0pt">Ассемблерный код прост: переменные i и j сохраняются в eax и edx соответственно, затем добавляются вместе с инструкцией добавления, и окончательный результат сохраняется в eax. Затем результат сохраняется в локальную переменную add, которая находится по адресу [ebp-0x34].</p><p height="1em" width="0pt">90</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>Выражение:</i>инт суб = я - j;</p><p height="1em" width="0pt">80483эк:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">80483эф:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">80483f2:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x30],eax</p><p height="1em" width="0pt">Подобно инструкции сложения, x86 предоставляет дополнительную инструкцию для вычитания. Следовательно, gcc переводит вычитание в подинструкцию, при этом eax перезагружается с i, так как eax все еще содержит результат предыдущего выражения. Затем j вычитается из i. После вычитания значение сохраняется в переменной sub по адресу [ebp-0x30].</p><p height="1em" width="0pt"> <i>Выражение:</i>инт мул = я * j;</p><p height="1em" width="0pt">80483f5:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">80483f8:</p><p height="1em" width="0pt">имул</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">80483fc:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x34],eax</p><p height="1em" width="0pt">Как и в инструкции sub, перезагружается только eax, так как он содержит результат предыдущего вычисления. imul выполняет знаковое умножение13. eax 13 Беззнаковое умножение выполняется mul</p><p height="1em" width="0pt">инструкция.</p><p height="1em" width="0pt">сначала загружается i, затем умножается на j и сохраняется обратно в eax, а затем сохраняется в переменной mul по адресу [ebp-0x34].</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал дел = я / j;</p><p height="1em" width="0pt">80483ff:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048402:</p><p height="1em" width="0pt">компакт-диск</p><p height="1em" width="0pt">8048403:</p><p height="1em" width="0pt">Идив</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0xc]</p><p height="1em" width="0pt">8048406:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x30],eax</p><p height="1em" width="0pt">Как и imul, idiv выполняет деление по знаку. Но, в отличие от imul выше, idiv принимает только один операнд:</p><p height="1em" width="0pt">1. Сначала i перезагружается в eax.</p><p height="1em" width="0pt">2. Затем cdq преобразует значение двойного слова в eax в значение четверного слова, хранящееся в паре регистров edx:eax, путем копирования знака (31-й бит) значения в eax в каждую битовую позицию в edx. Пара edx:eax — делимое, то есть переменная i, а операнд idiv — делитель, то есть переменная j.</p><p height="1em" width="0pt">3. После вычисления результат сохраняется в пару регистров edx:eax, где частное находится в eax, а остаток в edx. Частное хранится в переменной div по адресу [ebp-0x30].</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">91</p><p height="1em" width="0pt"> <i>Выражение:</i>int mod = я % j;</p><p height="1em" width="0pt">8048409:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">804840с:</p><p height="1em" width="0pt">компакт-диск</p><p height="1em" width="0pt">804840d:</p><p height="1em" width="0pt">Идив</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0xc]</p><p height="1em" width="0pt">8048410:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x2c],edx</p><p height="1em" width="0pt">Та же инструкция idiv также выполняет операцию по модулю, поскольку она также вычисляет остаток и сохраняет его в переменной mod по адресу [ebp-0x2c].</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал отрицательный = -i;</p><p height="1em" width="0pt">8048413:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048416:</p><p height="1em" width="0pt">отрицательный</p><p height="1em" width="0pt">эакс</p><p height="1em" width="0pt">8048418:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x28],eax</p><p height="1em" width="0pt">neg заменяет значение операнда (операнд назначения) его дополнительным кодом до двух (эта операция эквивалентна вычитанию операнда из 0). В этом примере значение i в eax заменяется на -i с помощью инструкции neg. Затем новое значение сохраняется в переменной neg по адресу [ebp-0x28].</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал и = я и j;</p><p height="1em" width="0pt">804841б:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">804841e:</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">8048421:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x24],eax</p><p height="1em" width="0pt">и выполняет побитовую операцию И над двумя операндами и сохраняет результат в операнде назначения, который является переменной и в</p><p height="1em" width="0pt">[ebp-0x24].</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал или = я | дж;</p><p height="1em" width="0pt">8048424:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048427:</p><p height="1em" width="0pt">или</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">804842а:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x20],eax</p><p height="1em" width="0pt">Подобно инструкции и, или выполняет побитовую операцию ИЛИ над двумя операндами и сохраняет результат в операнде назначения, который в данном случае является переменной или в [ebp-0x20].</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал xor = я ^ j;</p><p height="1em" width="0pt">92</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">804842д:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048430:</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">8048433:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x1c],eax</p><p height="1em" width="0pt">Подобно инструкции and/or, xor выполняет побитовую операцию XOR над двумя операндами и сохраняет результат в целевом операнде, которым является переменная xor в [ebp-0x1c].</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал не = ~ я;</p><p height="1em" width="0pt">8048436:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048439:</p><p height="1em" width="0pt">нет</p><p height="1em" width="0pt">эакс</p><p height="1em" width="0pt">804843б:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x18],eax</p><p height="1em" width="0pt">not выполняет побитовую операцию НЕ (каждая 1 устанавливается на 0, а каждый 0 устанавливается на 1) над операндом назначения и сохраняет результат в ячейке операнда назначения, которая является переменной not в [ebp-0x18].</p><p height="1em" width="0pt"> <i>Выражение:</i>инт шл = я << 8;</p><p height="1em" width="0pt">804843e:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048441:</p><p height="1em" width="0pt">шл</p><p height="1em" width="0pt">еакс, 0x8</p><p height="1em" width="0pt">8048444:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x14],eax</p><p height="1em" width="0pt">shl (логический сдвиг влево) сдвигает биты в операнде назначения влево на число битов, указанное в операнде-источнике. В этом случае eax сохраняет i, а shl сдвигает eax на 8 бит влево. Другое название shl — сал.<i>(</i>арифметический сдвиг влево). Оба могут использоваться как синонимы. Наконец, результат сохраняется в переменной shl по адресу [ebp-0x14].</p><p height="1em" width="0pt">Вот наглядная демонстрация инструкций shl/sal и shr: После сдвига влево самый правый бит устанавливается для флага переноса в регистре EFLAGS.</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал шр = я >> 8;</p><p height="1em" width="0pt">8048447:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">804844а:</p><p height="1em" width="0pt">сар</p><p height="1em" width="0pt">еакс, 0x8</p><p height="1em" width="0pt">804844д:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x10],eax</p><p height="1em" width="0pt">sar похож на shl/sal, но сдвигает биты вправо и расширяет бит знака. Для сдвига вправо shr и sar — ​​это две разные инструкции. shr отличается от sar тем, что не расширяет бит знака. Наконец, результат сохраняется в переменной shr по адресу [ebp-0x10].</p><a id="filepos302537" /><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">93</p><p height="1em" width="0pt">Начальное состояние</p><p height="1em" width="0pt">Начальное состояние</p><p height="1em" width="0pt">CF</p><p height="1em" width="0pt">CF</p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt"><b>1</b>0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1 1<b>1</b></p><p height="1em" width="0pt"><b>1</b>0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1 1<b>1</b></p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">После 1-битной инструкции SHL/SAL</p><p height="1em" width="0pt">После 1-битной инструкции SHR</p><p height="1em" width="0pt"><b>1</b></p><p height="1em" width="0pt">0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1 1<b>1</b>0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1<b>1</b></p><p height="1em" width="0pt"><b>1</b></p><p height="1em" width="0pt">После 1-битной инструкции SHL/SAL</p><p height="1em" width="0pt">После 10-битной инструкции SHR</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1 1<b>1</b>0 0 0 0 0 0 0 0 0 0 0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0 0 0 0 0 0 0 0 0 0<b>1</b>0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt"><b>(а)</b>SHL/SAL (Источник: рис. 7-6, том 1)</p><p height="1em" width="0pt"><b>(б)</b>SHR (Источник: рис. 7-7, том 1)</p><p height="1em" width="0pt"><b>Рисунок 4.9.1:</b>Сдвиг</p><p height="1em" width="0pt">инструкции</p><p height="1em" width="0pt">(красный — начальный бит, синий — конечный</p><p height="1em" width="0pt">На рисунке<a href="#filepos302537">4.9.1(б</a>), обратите внимание, что изначально бит знака равен 1, но бит af.)</p><p height="1em" width="0pt">при 1-битном и 10-битном сдвиге смещенные биты заполняются нулями.</p><p height="1em" width="0pt">Исходное состояние (положительный операнд)</p><p height="1em" width="0pt">Операнд</p><p height="1em" width="0pt">CF</p><p height="1em" width="0pt"><b>Рисунок 4.9.2:</b>Инструкция SAR</p><p height="1em" width="0pt"><b>0</b>1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1<b>1</b></p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">Операция (Источник:</p><p height="1em" width="0pt">Рисунок 7-8,</p><p height="1em" width="0pt">Том 1)</p><p height="1em" width="0pt">После 1-битной инструкции SAR</p><p height="1em" width="0pt">0<b>0</b>1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1</p><p height="1em" width="0pt"><b>1</b></p><p height="1em" width="0pt">Исходное состояние (отрицательный операнд)</p><p height="1em" width="0pt">Операнд</p><p height="1em" width="0pt"><b>1</b>1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1<b>1</b></p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">После 10-битной инструкции SAR</p><p height="1em" width="0pt">1<b>1</b>1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1</p><p height="1em" width="0pt"><b>1</b></p><p height="1em" width="0pt">С sar бит знака (самый значащий бит) сохраняется. То есть, если бит знака равен 0, новые биты всегда получают значение 0; если знаковый бит равен 1, новые биты всегда получают значение 1.</p><p height="1em" width="0pt"> <i>Выражение:</i>char equal1 = (i == j);</p><p height="1em" width="0pt">8048450:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048453:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">8048456:</p><p height="1em" width="0pt">сеть</p><p height="1em" width="0pt">все</p><p height="1em" width="0pt">8048459:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">БАЙТ PTR [ebp-0x41],al</p><p height="1em" width="0pt">94</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">cmp и варианты вариантов инструкции набора составляют все логические сравнения. В этом выражении cmp сравнивает переменные i и j; затем sete сохраняет значение 1 в регистр al, если сравнение из cmp ранее равно, или сохраняет 0 в противном случае. Общее название вариантов инструкции set называется SETcc. Суффикс cc обозначает проверяемое условие в регистре EFLAGS. Приложение Б в томе 1,<i>«Коды состояний EFLAGS»</i>, перечисляет условия, которые можно проверить с помощью этой инструкции. Наконец, результат сохраняется в переменной equal1 по адресу [ebp-0x41].</p><p height="1em" width="0pt"> <i>Выражение:</i>int equal2 = (я == j);</p><p height="1em" width="0pt">804845с:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">804845f:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">8048462:</p><p height="1em" width="0pt">сеть</p><p height="1em" width="0pt">все</p><p height="1em" width="0pt">8048465:</p><p height="1em" width="0pt">мовзкс</p><p height="1em" width="0pt">эакс, аль</p><p height="1em" width="0pt">8048468:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0xc],eax</p><p height="1em" width="0pt">Подобно сравнению на равенство, это выражение также сравнивает на равенство, за исключением того, что результат сохраняется в типе int.</p><p height="1em" width="0pt">По этой причине добавлена ​​еще одна инструкция: movzx инструкция, вариант mov, которая копирует результат в операнд назначения и заполняет оставшиеся байты 0. В этом случае, поскольку eax имеет ширину 4 байта, после копирования первого байта в al, остальные байты eax заполняются 0, чтобы гарантировать, что eax содержит то же значение, что и al.</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">34</p><p height="1em" width="0pt">56</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt"><b>Рисунок 4.9.3:</b>movzx инструкция</p><p height="1em" width="0pt"><b>(а)</b>eax перед movzx</p><p height="1em" width="0pt"><b>(б)</b>после movzx eax, al</p><p height="1em" width="0pt"> <i>Выражение:</i>char больше = (i > j);</p><p height="1em" width="0pt">804846б:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">804846е:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">8048471:</p><p height="1em" width="0pt">установка</p><p height="1em" width="0pt">все</p><p height="1em" width="0pt">8048474:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">БАЙТ PTR [ebp-0x40],al</p><p height="1em" width="0pt">Аналогично сравнению на равенство, но используется setg для<b>г</b>вместо этого большее сравнение.</p><p height="1em" width="0pt"> <i>Выражение:</i>char меньше = (i <j);</p><p height="1em" width="0pt">8048477:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">95</p><p height="1em" width="0pt">804847а:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">804847d:</p><p height="1em" width="0pt">успокоиться</p><p height="1em" width="0pt">все</p><p height="1em" width="0pt">8048480:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">БАЙТ PTR [ebp-0x3f],al</p><p height="1em" width="0pt">Применяется для<b>л</b>Эсс сравнение.</p><p height="1em" width="0pt"> <i>Выражение:</i>символ больше_равно = (я >= j); 8048483:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048486:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">8048489:</p><p height="1em" width="0pt">установка</p><p height="1em" width="0pt">все</p><p height="1em" width="0pt">804848с:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">БАЙТ PTR [ebp-0x3e],al</p><p height="1em" width="0pt">Прикладная установка для<b>г</b>больше или<b>е</b>качественное сравнение.</p><p height="1em" width="0pt"> <i>Выражение:</i>char less_equal = (i <= j);</p><p height="1em" width="0pt">804848f:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048492:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">8048495:</p><p height="1em" width="0pt">поселиться</p><p height="1em" width="0pt">все</p><p height="1em" width="0pt">8048498:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">БАЙТ PTR [ebp-0x3d],al</p><p height="1em" width="0pt">Применяется для<b>л</b>меньше или<b>е</b>качественное сравнение.</p><p height="1em" width="0pt"> <i>Выражение:</i>int logical_and = (i && j); 804849б:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0x8],0x0</p><p height="1em" width="0pt">804849f:</p><p height="1em" width="0pt">Дже</p><p height="1em" width="0pt">80484ae <выражение+0xd3></p><p height="1em" width="0pt">80484a1:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0xc],0x0</p><p height="1em" width="0pt">80484a5:</p><p height="1em" width="0pt">Дже</p><p height="1em" width="0pt">80484ae <выражение+0xd3></p><p height="1em" width="0pt">80484a7:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x1</p><p height="1em" width="0pt">80484ac:</p><p height="1em" width="0pt">джмп</p><p height="1em" width="0pt">80484b3 <выражение+0xd8></p><p height="1em" width="0pt">80484ae:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">80484b3:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x8],eax</p><p height="1em" width="0pt">Логический оператор И && — это один из синтаксисов, который полностью реализован в программном обеспечении14 с более простыми инструкциями. Алгоритм от ас-14 То есть нет эквивалентной сборки-</p><p height="1em" width="0pt">bly инструкция реализована на жестком</p><p height="1em" width="0pt">код сборки прост:</p><p height="1em" width="0pt">посуда.</p><p height="1em" width="0pt">1. Сначала проверьте, равно ли i 0, с помощью инструкции по адресу 0x804849b.</p><p height="1em" width="0pt">(a) Если верно, перейти к 0x80484ae и установить eax в 0.</p><p height="1em" width="0pt">(b) Установите для переменной logical_and значение 0, так как это следующая инструкция после 0x80484ae.</p><p height="1em" width="0pt">96</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">2. Если i не равно 0, проверьте, равно ли j 0, с помощью инструкции по адресу 0x80484a1.</p><p height="1em" width="0pt">(a) Если верно, перейти к 0x80484ae и установить eax в 0.</p><p height="1em" width="0pt">(b) Установите для переменной logical_and значение 0, так как это следующая инструкция после 0x80484ae.</p><p height="1em" width="0pt">3. Если и i, и j не равны 0, результат, безусловно, равен 1 или истине.</p><p height="1em" width="0pt">(a) Установите его в соответствии с инструкцией по адресу 0x80484a7.</p><p height="1em" width="0pt">(b) Затем перейдите к инструкции по адресу 0x80484b3, чтобы установить для переменной logical_and по адресу [ebp-0x8] значение 1.</p><p height="1em" width="0pt"> <i>Выражение:</i>int логическое_или = (я || j);</p><p height="1em" width="0pt">80484b6:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0x8],0x0</p><p height="1em" width="0pt">80484ба:</p><p height="1em" width="0pt">jne</p><p height="1em" width="0pt">80484c2 <выражение+0xe7></p><p height="1em" width="0pt">80484bc:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0xc],0x0</p><p height="1em" width="0pt">80484c0:</p><p height="1em" width="0pt">Дже</p><p height="1em" width="0pt">80484c9 <выражение+0xee></p><p height="1em" width="0pt">80484c2:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x1</p><p height="1em" width="0pt">80484c7:</p><p height="1em" width="0pt">джмп</p><p height="1em" width="0pt">80484ce <выражение+0xf3></p><p height="1em" width="0pt">80484c9:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">80484ce:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x4],eax</p><p height="1em" width="0pt">Логический оператор ИЛИ || аналогично логическому и выше. Понимание алгоритма оставлено в качестве упражнения для читателей.</p><p height="1em" width="0pt"> <i>Выражение:</i>++я; и я; (или я++ и я--)</p><p height="1em" width="0pt">80484d1:</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0x8],0x1</p><p height="1em" width="0pt">80484d5:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0x8],0x1</p><p height="1em" width="0pt">Синтаксис инкремента и декремента подобен логическому И и логическому ИЛИ в том, что он сделан из существующей инструкции, то есть сложения.</p><p height="1em" width="0pt">Разница в том, что ЦП на самом деле имеет встроенную инструкцию, но gcc решил не использовать эту инструкцию, потому что inc и dec вызывают ошибку.<i>частичная остановка регистра флага</i>, происходит, когда инструкция изменяет часть регистра флагов, и следующая инструкция зависит от результата флагов (<i>раздел 3.5.2.6</i>,<a href="#filepos805320">Интел</a>Руководство по оптимизации,<a href="#filepos805320">2016б).</a>Руководство даже предлагает заменить inc и dec инструкциями add и sub (раздел<i>3.5.1.1</i>,<a href="#filepos805320">Интел</a>Руководство по оптимизации,<a href="#filepos805320">2016б).</a></p><p height="1em" width="0pt"> <i>Выражение:</i>интервал i1 = i++;</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">97</p><p height="1em" width="0pt">80484d9:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">80484dc:</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">edx,[eax+0x1]</p><p height="1em" width="0pt">80484df:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp+0x8],edx</p><p height="1em" width="0pt">80484e2:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x10],eax</p><p height="1em" width="0pt">Сначала i копируется в eax по адресу 80484d9. Тогда значение eax + 0x1</p><p height="1em" width="0pt">копируется в edx как<i>фактический адрес</i>в 80484dc. Леа (<i>нагрузка</i> <i>фактический адрес</i>) копирует адрес памяти в регистр. Согласно Тому 2 операнд-источник — это адрес памяти, указанный в одном из режимов адресации процессора. Это означает, что исходный операнд должен быть указан в режимах адресации, определенных в 16-битных/32-битных таблицах ModR/M Byte,<a href="#filepos174261">4.5.1</a>и<a href="#filepos188918">4.5.2.</a></p><p height="1em" width="0pt">После загрузки увеличенного значения в edx значение i увеличивается на 1 в 80484df. Наконец,<i>предыдущий</i>Значение i сохраняется обратно в i1 по адресу [ebp-0x8] с помощью инструкции по адресу 80484e2.</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал i2 = ++i;</p><p height="1em" width="0pt">80484e5:</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0x8],0x1</p><p height="1em" width="0pt">80484e9:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">80484эк:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0xc],eax</p><p height="1em" width="0pt">Основные отличия этого синтаксиса приращения от предыдущего заключаются в следующем:</p><p height="1em" width="0pt">add используется вместо lea для прямого увеличения i.</p><p height="1em" width="0pt">новое увеличенное значение i сохраняется в i2 вместо старого значения.</p><p height="1em" width="0pt">выражение стоит всего 3 инструкции вместо 4.</p><p height="1em" width="0pt">Этот синтаксис префикс-инкремент работает быстрее, чем использовавшийся ранее пост-фикс. Может не иметь большого значения, какую версию использовать, если приращение используется только один раз или несколько сотен раз в небольшом цикле, но имеет значение, когда цикл выполняется миллионы или более раз. Кроме того, в зависимости от различных обстоятельств удобнее использовать один над другим, например. если i является индексом для доступа к массиву, мы хотим использовать старое значение для доступа к предыдущему элементу массива и новое увеличенное значение i для текущего элемента.</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал i3 = i--;</p><p height="1em" width="0pt">80484эф:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">98</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">80484f2:</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">edx,[eax-0x1]</p><p height="1em" width="0pt">80484f5:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp+0x8],edx</p><p height="1em" width="0pt">80484f8:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x8],eax</p><p height="1em" width="0pt">Аналогичен синтаксису i++ и оставлен читателям в качестве упражнения.</p><p height="1em" width="0pt"> <i>Выражение:</i>интервал i4 = --i;</p><p height="1em" width="0pt">80484fb:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0x8],0x1</p><p height="1em" width="0pt">80484ff:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">8048502:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x4],eax</p><p height="1em" width="0pt">Аналогичен синтаксису ++i и оставлен читателям в качестве упражнения.</p><p height="1em" width="0pt"><b>Упражнение 4.9.1.</b>Читать раздел<i>3.5.2.4</i>,<i>«Частичные регистрационные киоски»</i>чтобы понять регистрационные киоски в целом.</p><p height="1em" width="0pt"><b>Упражнение 4.9.2.</b>Читайте разделы из<i>7.3.1</i>к<i>7.3.7</i>в томе 1.</p><p height="1em" width="0pt"> <i>4.9.3 Стек</i></p><p height="1em" width="0pt">Стек — это непрерывный массив ячеек памяти, содержащий набор дискретных данных. Когда добавляется новый элемент, стек<i>растет вниз</i>в памяти в сторону меньших адресов и<i>сжимается</i>к большим адресам, когда элемент удален. x86 использует регистр esp для указания на вершину стека, на самый новый элемент. Стек может быть создан в любом месте основной памяти, так как esp может быть установлен на любой адрес памяти. x86</p><p height="1em" width="0pt">предоставляет две операции для управления стеками:</p><p height="1em" width="0pt">Инструкция push и ее варианты добавляют новый элемент в верхнюю часть стека. Инструкция pop, а ее варианты удаляют самый верхний элемент из стека.</p><p height="1em" width="0pt">0x10000</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10000</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10000</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10001</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10001</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10001</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10002</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10002</p><p height="1em" width="0pt">78</p><p height="1em" width="0pt">←</p><p height="1em" width="0pt">особенно</p><p height="1em" width="0pt">0x10002</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10003</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10003</p><p height="1em" width="0pt">56</p><p height="1em" width="0pt">0x10003</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">0x10004</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">←</p><p height="1em" width="0pt">особенно</p><p height="1em" width="0pt">0x10004</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">0x10004</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">←</p><p height="1em" width="0pt">особенно</p><p height="1em" width="0pt"><b>(а)</b>Исходное состояние по адресу 0x10004</p><p height="1em" width="0pt"><b>(б)</b>После</p><p height="1em" width="0pt">выполнение push-слова</p><p height="1em" width="0pt"><b>(с)</b>После исполнения поп-слова</p><p height="1em" width="0pt">0x5678</p><p height="1em" width="0pt"><b>Рисунок 4.9.4:</b>Операции стека</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">99</p><p height="1em" width="0pt"> <i>4.9.4 Автоматические переменные</i></p><p height="1em" width="0pt">Локальные переменные — это переменные, которые существуют в пределах области видимости. Область действия ограничивается парой фигурных скобок: {..}. Наиболее распространенная область определения локальных переменных — область действия функции. Однако область может быть безымянной, и переменные, созданные внутри безымянной области, не существуют вне ее области и ее внутренней области.</p><p height="1em" width="0pt"><b>Пример 4.9.1.</b>Объем функций:</p><p height="1em" width="0pt"><b>пустота</b>Фу () {</p><p height="1em" width="0pt"><b>инт</b>а;</p><p height="1em" width="0pt"><b>инт</b>б;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">a и b — локальные переменные функции foo.</p><p height="1em" width="0pt"><b>Пример 4.9.2.</b>Безымянная область:</p><p height="1em" width="0pt"><b>инт</b>Фу () {</p><p height="1em" width="0pt"><b>инт</b>я;</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt"><b>инт</b>а = 1;</p><p height="1em" width="0pt"><b>инт</b>б = 2;</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt"><b>возвращаться</b>я = а + б;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">a и b являются локальными для того места, где они определены, и локальными для своей внутренней дочерней области, которая возвращает i = a + b. Однако они не существуют в области действия функции, создающей i.</p><p height="1em" width="0pt">Когда создается локальная переменная, она помещается в стек; когда локальная переменная выходит за пределы области видимости, она выталкивается из стека и, таким образом, уничтожается.</p><p height="1em" width="0pt">Когда аргумент передается от вызывающего к вызываемому, он помещается в стек; когда вызываемый объект возвращается к вызывающему объекту, аргументы выводятся наружу</p><p height="1em" width="0pt">100</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">стек. Локальные переменные и аргументы автоматически выделяются при входе в функцию и уничтожаются после выхода из функции, поэтому она называется<i>автоматические переменные</i>.</p><p height="1em" width="0pt">Указатель базового фрейма указывает на начало текущего функционального фрейма и хранится в регистре ebp. Всякий раз, когда вызывается функция, ей выделяется собственное выделенное хранилище в стеке, называемое<i>кадр стека</i>. Фрейм стека — это место, где все локальные переменные и аргументы функции помещаются в стек15.</p><p height="1em" width="0pt">15 Данные и только данные являются исключительно</p><p height="1em" width="0pt">размещается в стеке навсегда в стеке</p><p height="1em" width="0pt">Когда функции нужна локальная переменная или аргумент, она использует кадр ebp. Здесь нет кода.</p><p height="1em" width="0pt">для доступа к переменной:</p><p height="1em" width="0pt">Все локальные переменные размещаются после указателя ebp. Таким образом, чтобы получить доступ к локальной переменной, из ebp вычитается число, чтобы добраться до местоположения переменной.</p><p height="1em" width="0pt">Все аргументы размещаются перед указателем ebp. Чтобы получить доступ к аргументу, к ebp добавляется число, чтобы добраться до местоположения аргумента.</p><p height="1em" width="0pt">Сам указатель ebp указывает на обратный адрес вызывающего объекта.</p><p height="1em" width="0pt">Предыдущий кадр</p><p height="1em" width="0pt">Текущий кадр</p><p height="1em" width="0pt">Аргументы функции</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">Локальные переменные</p><p height="1em" width="0pt"> <i>А1</i></p><p height="1em" width="0pt"> <i>А2</i></p><p height="1em" width="0pt"> <i>А3</i></p><p height="1em" width="0pt"> <i>........</i></p><p height="1em" width="0pt"> <i>Ан</i></p><p height="1em" width="0pt"> <i>Обратный адрес</i></p><p height="1em" width="0pt">Старый эбп</p><p height="1em" width="0pt"> <i>L1</i></p><p height="1em" width="0pt"> <i>L2</i></p><p height="1em" width="0pt"> <i>L3</i></p><p height="1em" width="0pt"> <i>........</i></p><p height="1em" width="0pt"> <i>Ln</i></p><p height="1em" width="0pt"><b>Рисунок 4.9.5:</b>Аргументы функции</p><p height="1em" width="0pt">А = Аргумент</p><p height="1em" width="0pt">и локальные переменные</p><p height="1em" width="0pt">L = локальная переменная</p><p height="1em" width="0pt">Вот пример, чтобы сделать это более конкретным:</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>инт</b>добавлять(<b>в</b>,<b>инт б</b>) {</p><p height="1em" width="0pt"><b>в я</b>"="<b>а</b>+<b>б</b>;</p><p height="1em" width="0pt"><b>возвращаться</b>я;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">080483db <добавить>:</p><p height="1em" width="0pt">#include <stdint.h></p><p height="1em" width="0pt">int добавить (int a, int b) {</p><p height="1em" width="0pt">80483дб:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><a id="filepos328376" /><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">101</p><p height="1em" width="0pt">80483dc:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">80483де:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">интервал я = а + б;</p><p height="1em" width="0pt">80483e1:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">edx,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">80483e4:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">80483e7:</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">еакс, эдкс</p><p height="1em" width="0pt">80483e9:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">DWORD PTR [ebp-0x4],eax</p><p height="1em" width="0pt">вернуть я;</p><p height="1em" width="0pt">80483эк:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp-0x4]</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">80483эф:</p><p height="1em" width="0pt">оставлять</p><p height="1em" width="0pt">80483f0:</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">В ассемблерном листинге [ebp-0x4] — это локальная переменная i, так как она выделена<i>после</i>ebp длиной 4 байта (int). С другой стороны, a и b являются аргументами, и к ним можно получить доступ с помощью ebp:</p><p height="1em" width="0pt">[ebp+0x8] обращается к файлу a.</p><p height="1em" width="0pt">[ebp+0xc] доступ b.</p><p height="1em" width="0pt">Для доступа к аргументам действует правило: чем ближе переменная в стеке к ebp, тем ближе она к имени функции.</p><p height="1em" width="0pt">ebp+0xc</p><p height="1em" width="0pt">эбп+0x8</p><p height="1em" width="0pt">эбп+0x4</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">04</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">09</p><p height="1em" width="0pt">0а</p><p height="1em" width="0pt">0b</p><p height="1em" width="0pt">0с</p><p height="1em" width="0pt">0д</p><p height="1em" width="0pt">0e</p><p height="1em" width="0pt">0f</p><p height="1em" width="0pt">0x10000</p><p height="1em" width="0pt">б</p><p height="1em" width="0pt">а</p><p height="1em" width="0pt">Обратный адрес</p><p height="1em" width="0pt">Старый эбп</p><p height="1em" width="0pt">эбп+0x8</p><p height="1em" width="0pt">эбп+0x4</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">↓</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">04</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">09</p><p height="1em" width="0pt">0а</p><p height="1em" width="0pt">0b</p><p height="1em" width="0pt">0с</p><p height="1em" width="0pt">0д</p><p height="1em" width="0pt">0e</p><p height="1em" width="0pt">0f</p><p height="1em" width="0pt">0xffe0</p><p height="1em" width="0pt">Н</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt"><b>Рисунок 4.9.6:</b>Аргументы функции</p><p height="1em" width="0pt">N = здесь начинается следующая локальная переменная</p><p height="1em" width="0pt">и локальные переменные в памяти</p><p height="1em" width="0pt">Из рисунка видно, что a и b располагаются в памяти в точном порядке, как написано в C, относительно адреса возврата.</p><p height="1em" width="0pt"> <i>4.9.5 Вызов функции и возврат</i></p><p height="1em" width="0pt">102</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>добавлять(<b>инт</b>а,<b>инт</b>б) {</p><p height="1em" width="0pt"><b>инт</b>местный = 0x12345;</p><p height="1em" width="0pt"><b>возвращаться</b>а + б;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt">добавить (1,1);</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i>Для каждого вызова функции gcc помещает аргументы в стек в обратном порядке с инструкциями push. То есть аргументы, помещаемые в стек, находятся в зарезервированном порядке, как это написано в коде высокого уровня C, чтобы обеспечить относительный порядок между аргументами, как показано в предыдущем разделе, как аргументы функции и локальные переменные расположены. Затем gcc генерирует инструкцию вызова, которая затем неявно подталкивает адрес возврата перед передачей управления для добавления функции: 080483f2 <main>:</p><p height="1em" width="0pt">int main(int argc, char *argv[]) {</p><p height="1em" width="0pt">80483f2:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">80483f3:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">добавить (1,2);</p><p height="1em" width="0pt">80483f5:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">0x2</p><p height="1em" width="0pt">80483f7:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">0x1</p><p height="1em" width="0pt">80483f9:</p><p height="1em" width="0pt">вызов</p><p height="1em" width="0pt">80483дб <добавить></p><p height="1em" width="0pt">80483fe:</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">особенно, 0x8</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">8048401:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">8048406:</p><p height="1em" width="0pt">оставлять</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">103</p><p height="1em" width="0pt">8048407:</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">После завершения вызова функции добавления стек восстанавливается путем добавления 0x8 к указателю стека esp (что эквивалентно 2 инструкциям pop). Наконец, выполняется инструкция leave, и main возвращается с инструкцией ret.</p><p height="1em" width="0pt">Инструкция ret передает выполнение программы обратно вызывающей стороне инструкции сразу после инструкции call, инструкции добавления. Причина, по которой ret может вернуться в такое расположение, заключается в том, что адрес возврата неявно выдвигается инструкцией call, то есть адресом сразу после инструкции call; всякий раз, когда ЦП выполняет инструкцию ret, он извлекает адрес возврата, который находится сразу после всех аргументов в стеке: в конце функции gcc помещает инструкцию leave, чтобы очистить все пробелы, выделенные для локальных переменных, и восстановить указатель кадра на указатель кадра вызывающего объекта.</p><p height="1em" width="0pt">080483db <добавить>:</p><p height="1em" width="0pt">#include <stdio.h></p><p height="1em" width="0pt">int добавить (int a, int b) {</p><p height="1em" width="0pt">80483дб:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">80483dc:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">80483де:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">локальный интервал = 0x12345;</p><p height="1em" width="0pt">80483e1:</p><p height="1em" width="0pt">Двойное слово PTR [ebp-0x4], 0x12345</p><p height="1em" width="0pt">вернуть а + б;</p><p height="1em" width="0pt">80483e8:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">edx,DWORD PTR [ebp+0x8]</p><p height="1em" width="0pt">80483эб:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">eax,DWORD PTR [ebp+0xc]</p><p height="1em" width="0pt">80483ee:</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">еакс, эдкс</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">80483f0:</p><p height="1em" width="0pt">оставлять</p><p height="1em" width="0pt">80483f1:</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt"><b>Упражнение 4.9.3.</b>Приведенный выше код, сгенерированный gcc для вызова функции, на самом деле является стандартным методом, определенным x86. Прочитайте главу 6,<i>"Производить</i> <i>Вызовы, прерывания и исключения»,</i>Руководство Intel том 1.</p><p height="1em" width="0pt">104</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>4.9.6 Цикл</i></p><p height="1em" width="0pt">Цикл просто сбрасывает указатель инструкции на уже выполненную инструкцию и начинает с нее все сначала. Цикл — это всего лишь одно из применений инструкции jmp. Однако, поскольку зацикливание является широко распространенным шаблоном, в C он получил собственный синтаксис.</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>для</b>(<b>инт</b>я = 0; я < 10; я++) {</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">080483db <основной>:</p><p height="1em" width="0pt">#include <stdio.h></p><p height="1em" width="0pt">int main(int argc, char *argv[]) {</p><p height="1em" width="0pt">80483дб:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">80483dc:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">80483де:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">для (целое я = 0; я < 10; я ++) {</p><p height="1em" width="0pt">80483e1:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">Двойное слово PTR [ebp-0x4], 0x0</p><p height="1em" width="0pt">80483e8:</p><p height="1em" width="0pt">джмп</p><p height="1em" width="0pt">80483ee <основной+0x13></p><p height="1em" width="0pt">80483еа:</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">Двойное слово PTR [ebp-0x4],0x1</p><p height="1em" width="0pt">80483ee:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">Двойное слово PTR [ebp-0x4],0x9</p><p height="1em" width="0pt">80483f2:</p><p height="1em" width="0pt">джле</p><p height="1em" width="0pt">80483ea <основной+0xf></p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">80483f4: b8 00 00 00 00</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">80483f9: с9</p><p height="1em" width="0pt">оставлять</p><p height="1em" width="0pt">80483fa: c3</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">80483фб: 66 90</p><p height="1em" width="0pt">хчг</p><p height="1em" width="0pt">топор, топор</p><p height="1em" width="0pt">80483fd: 66 90</p><p height="1em" width="0pt">хчг</p><p height="1em" width="0pt">топор, топор</p><p height="1em" width="0pt">сборка x86 и c</p><p height="1em" width="0pt">105</p><p height="1em" width="0pt">80483ff: 90</p><p height="1em" width="0pt">нет</p><p height="1em" width="0pt">Цвета отмечают код высокого уровня, соответствующий ассемблерному коду: 1. Красная инструкция инициализирует i значением 0.</p><p height="1em" width="0pt">2. Зеленые инструкции сравнивают i с 10 с помощью jle и сравнивают его с 9. Если это правда, перейти к 80483ea для другой итерации.</p><p height="1em" width="0pt">3. Синяя инструкция увеличивает i на 1, позволяя циклу завершиться, как только будет выполнено условие завершения.</p><p height="1em" width="0pt"><b>Упражнение 4.9.4.</b>Почему инструкция увеличения (синяя инструкция) появляется перед инструкциями сравнения (зеленая инструкция)?</p><p height="1em" width="0pt"><b>Упражнение 4.9.5.</b>Какой ассемблерный код можно сгенерировать для while и do...while?</p><p height="1em" width="0pt"> <i>4.9.7 Условный</i></p><p height="1em" width="0pt">Опять же, условное выражение в C с конструкцией if...else... — это просто еще одно скрытое применение инструкции jmp. Это также широко распространенный шаблон, получивший собственный синтаксис в C.</p><p height="1em" width="0pt"> <i>Источник</i></p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) {</p><p height="1em" width="0pt"><b>инт</b>я = 0;</p><p height="1em" width="0pt"><b>если</b>(аргумент) {</p><p height="1em" width="0pt">я = 1;</p><p height="1em" width="0pt">}<b>еще</b>{</p><p height="1em" width="0pt">я = 0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>Сборка</i></p><p height="1em" width="0pt">int main(int argc, char *argv[]) {</p><p height="1em" width="0pt">80483дб:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">106</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">80483dc:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">80483де:</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">интервал я = 0;</p><p height="1em" width="0pt">80483e1:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">Двойное слово PTR [ebp-0x4], 0x0</p><p height="1em" width="0pt">если (аргумент) {</p><p height="1em" width="0pt">80483e8:</p><p height="1em" width="0pt">cmp</p><p height="1em" width="0pt">Двойное слово PTR [ebp+0x8],0x0</p><p height="1em" width="0pt">80483эк:</p><p height="1em" width="0pt">Дже</p><p height="1em" width="0pt">80483f7 <основной+0x1c></p><p height="1em" width="0pt">я = 1;</p><p height="1em" width="0pt">80483ee:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">Двойное слово PTR [ebp-0x4],0x1</p><p height="1em" width="0pt">80483f5:</p><p height="1em" width="0pt">джмп</p><p height="1em" width="0pt">80483fe <основной+0x23></p><p height="1em" width="0pt">} еще {</p><p height="1em" width="0pt">я = 0;</p><p height="1em" width="0pt">80483f7:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">Двойное слово PTR [ebp-0x4], 0x0</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">80483fe:</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">8048403:</p><p height="1em" width="0pt">оставлять</p><p height="1em" width="0pt">8048404:</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">Сгенерированный ассемблерный код следует тому же порядку, что и соответствующий синтаксис высокого уровня:</p><p height="1em" width="0pt">красные инструкции представляют собой ветвь.</p><p height="1em" width="0pt">синие инструкции представляют еще ветвь.</p><p height="1em" width="0pt">зеленая инструкция является точкой выхода для ветвей if и else.</p><p height="1em" width="0pt">если ветвь сначала сравнивает, является ли argc<i>ЛОЖЬ</i>(равно 0) с инструкцией cmp. Если это правда, он переходит к другой ветке по адресу 80483f7. В противном случае, если переход продолжается с кодом своего перехода, который является следующей инструкцией по адресу 80483ee для копирования 1 в i. Наконец, он пропускает ветвь else и переходит к 80483fe, то есть следующей инструкции, которая проходит мимо конструкции if..else....</p><p height="1em" width="0pt">иначе ветвь вводится, когда инструкция cmp из if ветвь верна.</p><p height="1em" width="0pt">Ветвь else начинается с 80483f7, что является первой инструкцией ветки else. Инструкция копирует 0 в i и естественным образом переходит к следующей инструкции, проходящей мимо конструкции if...else... без какого-либо перехода.</p><a id="filepos344661" /><p height="1em" width="0pt"><b>5</b></p><p height="1em" width="0pt">Анатомия программы</p><p height="1em" width="0pt">Каждая программа состоит из кода и данных, и только эти два компонента составляют программу. Однако, если программа состоит исключительно из кода и собственных данных, с точки зрения операционной системы (а также человека) она не знает в программе, какой блок двоичного кода является программой, а какой просто необработанными данными, где в программе начать выполнение, какую область памяти следует защитить и какую можно изменить. По этой причине каждая программа содержит дополнительные метаданные, чтобы сообщить операционной системе, как обращаться с программой.</p><p height="1em" width="0pt">Когда исходный файл компилируется, сгенерированный машинный код сохраняется в<i>объектный файл</i>, который является просто блоком двоичного кода. Один или несколько объектных файлов</p><p height="1em" width="0pt"> <i><b>объектный файл</b></i></p><p height="1em" width="0pt">могут быть объединены для получения<i>исполняемый двоичный файл</i>, что является полным</p><p height="1em" width="0pt"> <i><b>исполняемый двоичный файл</b></i></p><p height="1em" width="0pt">программа, работающая в операционной системе.</p><p height="1em" width="0pt">readelf — это программа, которая распознает и отображает метаданные ELF двоичного файла, будь то объектный файл или исполняемый двоичный файл.<i><b>ЭЛЬФ</b></i>, или<i><b>Е</b></i><i>исполняемый</i> <i>и</i><i><b>л</b></i><i>чернильный</i><i><b>Ф</b></i><i>формат</i>, — это содержимое в самом начале исполняемого файла, предоставляющее операционной системе необходимую информацию для загрузки в основную память и запуска исполняемого файла. ELF можно представить как оглавление книги. В книге оглавление перечисляет номера страниц основных разделов, подразделов, иногда даже рисунков и таблиц для облегчения поиска. Точно так же ELF перечисляет различные разделы, используемые для кода и данных, и адреса памяти каждого символа вместе с другими данными.</p><p height="1em" width="0pt">108</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">формирование.</p><p height="1em" width="0pt">Двоичный файл ELF состоит из:</p><p height="1em" width="0pt">Ан<i>заголовок ELF</i>: самый первый раздел исполняемого файла, описывающий</p><p height="1em" width="0pt"> <i><b>заголовок ELF</b></i></p><p height="1em" width="0pt">организация файла.</p><p height="1em" width="0pt">А<i>таблица заголовка программы</i>: представляет собой массив структур фиксированного размера, определяющих</p><p height="1em" width="0pt"> <i><b>таблица заголовка программы</b></i></p><p height="1em" width="0pt">записывает сегменты исполняемого файла.</p><p height="1em" width="0pt">А<i>таблица заголовка раздела</i>: это массив структур фиксированного размера, который описывает</p><p height="1em" width="0pt"> <i><b>таблица заголовка раздела</b></i></p><p height="1em" width="0pt">разделы исполняемого файла.</p><p height="1em" width="0pt"> <i>Сегменты и раздел</i>s являются основным содержимым двоичного файла ELF, который</p><p height="1em" width="0pt"> <i><b>Сегменты и раздел</b></i><b>с</b></p><p height="1em" width="0pt">представляют собой код и данные, разделенные на куски различного назначения.</p><p height="1em" width="0pt">А<i>сегмент</i>представляет собой композицию из нуля или более разделов и напрямую загружается операционной системой во время выполнения.</p><p height="1em" width="0pt">А<i>раздел</i>представляет собой блок двоичного кода, который либо:</p><p height="1em" width="0pt"><b>–</b>фактический программный код и данные, доступные в памяти во время выполнения программы.</p><p height="1em" width="0pt"><b>–</b>метаданные о других разделах используются только в процессе компоновки и исчезают из финального исполняемого файла.</p><p height="1em" width="0pt">Linker использует разделы для построения сегментов.</p><p height="1em" width="0pt">заголовок ELF</p><p height="1em" width="0pt"><b>Рисунок 5.0.1:</b>ЭЛЬФ - Связывание</p><p height="1em" width="0pt">Представление против исполняемого представления (Источник:</p><p height="1em" width="0pt">Таблица заголовка программы</p><p height="1em" width="0pt">Википедия)</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">{ .родата</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">{ .данные</p><p height="1em" width="0pt">Таблица заголовка раздела</p><p height="1em" width="0pt">Позже мы скомпилируем наше ядро ​​как исполняемый файл ELF с GCC и явно укажем, как создаются сегменты и куда они загружаются.</p><a id="filepos348998" /><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">109</p><p height="1em" width="0pt">в памяти с помощью<i>скрипт компоновщика</i>, текстовый файл, указывающий, как компоновщик должен генерировать двоичный файл. А пока мы подробно рассмотрим анатомию исполняемого файла ELF.</p><p height="1em" width="0pt"><b>5.1</b></p><p height="1em" width="0pt"><b>Справочные документы:</b></p><p height="1em" width="0pt">Спецификация ELF поставляется в виде справочной страницы в Linux:</p><p height="1em" width="0pt"> <i><b>спецификация ЭЛЬФ</b></i></p><p height="1em" width="0pt">$ мужчина эльф</p><p height="1em" width="0pt">Это полезный ресурс для понимания и реализации ELF. Однако после того, как вы закончите эту главу, пользоваться ею будет гораздо проще, поскольку в спецификации смешаны детали реализации.</p><p height="1em" width="0pt">Спецификация по умолчанию является общей, за которой следует каждая реализация ELF. Однако каждая платформа предоставляет дополнительные функции, уникальные только для нее. Спецификация ELF для x86 в настоящее время поддерживается на Github HJ Lu:<a href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI">https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI.</a></p><p height="1em" width="0pt">Детали, зависящие от платформы, называются «специфичными для процессора» в общей спецификации ELF. Мы не будем исследовать эти детали, а изучим общие детали, которых достаточно для создания двоичного образа ELF для нашей операционной системы.</p><p height="1em" width="0pt"><b>5.2</b></p><p height="1em" width="0pt"><b>заголовок ELF</b></p><p height="1em" width="0pt">Чтобы увидеть информацию заголовка ELF:</p><p height="1em" width="0pt">$ readelf -h привет</p><p height="1em" width="0pt">Выход:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Заголовок ЭЛЬФ:</p><p height="1em" width="0pt">Магия:</p><p height="1em" width="0pt">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">Сорт:</p><p height="1em" width="0pt">ЭЛЬФ64</p><p height="1em" width="0pt">Данные:</p><p height="1em" width="0pt">дополнение до 2, прямой порядок байтов</p><p height="1em" width="0pt">110</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Версия:</p><p height="1em" width="0pt">1 (текущий)</p><p height="1em" width="0pt">ОС/ABI:</p><p height="1em" width="0pt">UNIX — Система V</p><p height="1em" width="0pt">Версия АБИ:</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Тип:</p><p height="1em" width="0pt">EXEC (исполняемый файл)</p><p height="1em" width="0pt">Машина:</p><p height="1em" width="0pt">Усовершенствованные микроустройства X86-64</p><p height="1em" width="0pt">Версия:</p><p height="1em" width="0pt">0x1</p><p height="1em" width="0pt">Адрес точки входа:</p><p height="1em" width="0pt">0x400430</p><p height="1em" width="0pt">Начало заголовков программы:</p><p height="1em" width="0pt">64 (байт в файл)</p><p height="1em" width="0pt">Начало заголовков разделов:</p><p height="1em" width="0pt">6648 (байт в файл)</p><p height="1em" width="0pt">Флаги:</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt">Размер этого заголовка:</p><p height="1em" width="0pt">64 (байта)</p><p height="1em" width="0pt">Размер заголовков программы:</p><p height="1em" width="0pt">56 (байт)</p><p height="1em" width="0pt">Количество заголовков программы:</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">Размер заголовков разделов:</p><p height="1em" width="0pt">64 (байта)</p><p height="1em" width="0pt">Количество заголовков разделов:</p><p height="1em" width="0pt">31</p><p height="1em" width="0pt">Индекс таблицы строк заголовка раздела: 28</p><p height="1em" width="0pt">Пройдемся по каждому полю:</p><p height="1em" width="0pt"> <i><b>Магия</b></i>Отображает необработанные байты, которые являются уникальными адресами файла в формате ELF.</p><p height="1em" width="0pt">исполняемый двоичный файл. Каждый байт дает краткую информацию.</p><p height="1em" width="0pt">В примере у нас есть следующие магические байты:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Магия:</p><p height="1em" width="0pt">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">Исследуйте байт за байтом:</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">111</p><p height="1em" width="0pt"><b>Байт</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">7ф 45 4в 46</p><p height="1em" width="0pt">Предопределенные значения. Первый байт всегда</p><p height="1em" width="0pt">7F, оставшиеся 3 байта представляют</p><p height="1em" width="0pt">строка «ЭЛЬФ».</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">См. поле «Класс» ниже.</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">См. поле данных ниже.</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">См. поле «Версия» ниже.</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">См. поле OS/ABI ниже.</p><p height="1em" width="0pt">00 00 00 00 00</p><p height="1em" width="0pt">Байты заполнения. Эти байты не используются</p><p height="1em" width="0pt">00 00 00</p><p height="1em" width="0pt">и всегда установлены на 0. Байты заполнения</p><p height="1em" width="0pt">добавлен для правильного выравнивания и</p><p height="1em" width="0pt">зарезервировано для использования в будущем, когда больше</p><p height="1em" width="0pt">нужна информация.</p><p height="1em" width="0pt"> <i><b>Сорт</b></i>Байт в магическом поле. Он указывает класс или емкость файла.</p><p height="1em" width="0pt">Возможные значения:</p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Недопустимый класс</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">32-битные объекты</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">64-битные объекты</p><p height="1em" width="0pt"> <i><b>Данные</b></i>Байт в магическом поле. Он определяет кодировку данных, специфичных для процессора, в объектном файле.</p><p height="1em" width="0pt">Возможные значения:</p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Неверная кодировка данных</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Little endian, дополнение до 2</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">Большой порядок байтов, дополнение до 2</p><p height="1em" width="0pt"> <i><b>Версия</b></i>Байт в Магии. Он указывает номер версии заголовка ELF.</p><p height="1em" width="0pt">Возможные значения:</p><p height="1em" width="0pt">112</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Неверная версия</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Текущая версия</p><p height="1em" width="0pt"> <i><b>ОС/ABI</b></i>Байт в магическом поле. Он указывает ABI целевой операционной системы. Первоначально это был байт заполнения.</p><p height="1em" width="0pt">Возможные значения: обратитесь к последнему документу ABI, так как это длинный список различных операционных систем.</p><p height="1em" width="0pt"> <i><b>Тип</b></i>Идентифицирует тип объектного файла.</p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Нет типа файла</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Перемещаемый файл</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">Запускаемый файл</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">Общий объектный файл</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">Основной файл</p><p height="1em" width="0pt">0xff00</p><p height="1em" width="0pt">Зависит от процессора, нижняя граница</p><p height="1em" width="0pt">0xffff</p><p height="1em" width="0pt">Зависит от процессора, верхняя граница</p><p height="1em" width="0pt">Значения от 0xff00 до 0xffff зарезервированы процессором для определения дополнительных типов файлов, значимых для него.</p><p height="1em" width="0pt"> <i><b>Машина</b></i>Указывает требуемое значение архитектуры для файла ELF, например.</p><p height="1em" width="0pt">x86_64, MIPS, SPARC и т.д. В примере машина x86_64</p><p height="1em" width="0pt">архитектура.</p><p height="1em" width="0pt">Возможные значения: Пожалуйста, обратитесь к последнему документу ABI, так как это длинный список различных архитектур.</p><p height="1em" width="0pt"> <i><b>Версия</b></i>Указывает номер версии текущей<i>объектный файл</i>(не версия заголовка ELF, как указано в поле Версия выше).</p><p height="1em" width="0pt"> <i><b>Адрес точки входа</b></i>Указывает адрес памяти, где будет выполняться самый первый код. Адрес основной функции используется по умолчанию в обычной прикладной программе, но это может быть любая функция, если явно указать имя функции для gcc. Для операционной системы, которую мы собираемся написать, это единственное наиболее важное поле, которое нам нужно получить для начальной загрузки нашего ядра, а все остальное можно игнорировать.</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">113</p><p height="1em" width="0pt"> <i><b>Начало заголовков программы</b></i>Смещение таблицы заголовков программы в байтах. В примере это число составляет 64 байта, что означает, что 65-й байт, или <начальный адрес> + 64, является начальным адресом таблицы заголовков программы. То есть, если программа загружена в памяти по адресу 0x10000, то начальный адрес 0x10000 (самый первый байт поля Magic, где находится значение 0x7f) и начальный адрес таблицы заголовков программы 0x10000 + 0x40 = 0x10040.</p><p height="1em" width="0pt"> <i><b>Начало заголовков разделов</b></i>Смещение таблицы заголовков разделов в байтах, аналогично началу заголовков программ. В примере это 6648 байт в файле.</p><p height="1em" width="0pt"> <i><b>Флаги</b></i>Хранить специфические для процессора флаги, связанные с файлом. Когда программа загружается, на машине x86 регистр EFLAGS устанавливается в соответствии с этим значением. В примере значение равно 0x0, что означает EFLAGS.</p><p height="1em" width="0pt">реестр в чистом состоянии.</p><p height="1em" width="0pt"> <i><b>Размер этого заголовка</b></i>Указывает общий размер размера заголовка ELF в байтах.</p><p height="1em" width="0pt">В примере это 64 байта, что эквивалентно началу заголовков программы. Обратите внимание, что эти два числа не обязательно эквивалентны, так как таблица заголовков программы может располагаться далеко от заголовка ELF.</p><p height="1em" width="0pt">Единственным фиксированным компонентом в исполняемом бинарном файле ELF является ELF.</p><p height="1em" width="0pt">заголовок, который появляется в самом начале файла.</p><p height="1em" width="0pt"> <i><b>Размер заголовков программы</b></i>Задает размер<i>каждый</i>заголовок программы в байтах. В примере это 64 байта.</p><p height="1em" width="0pt"> <i><b>Количество заголовков программы</b></i>Указывает общее количество заголовков программы. В примере файл имеет всего 9 заголовков программ.</p><p height="1em" width="0pt"> <i><b>Размер заголовков разделов</b></i>Задает размер<i>каждый</i>заголовок секции в байтах. В примере это 64 байта.</p><p height="1em" width="0pt"> <i><b>Количество заголовков разделов</b></i>Указывает общее количество заголовков разделов. В примере в файле всего 31 заголовок раздела. В таблице заголовков разделов первая запись в таблице всегда является пустым разделом.</p><p height="1em" width="0pt"> <i><b>Индекс таблицы строк заголовков разделов</b></i>Указывает индекс заголовка в таблице заголовков разделов, который указывает на раздел, содержащий все</p><a id="filepos360914" /><p height="1em" width="0pt">114</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">строки с завершающим нулем. В примере индекс равен 28, что означает, что это 28-я запись в таблице.</p><p height="1em" width="0pt"><b>5.3</b></p><p height="1em" width="0pt"><b>Таблица заголовка раздела</b></p><p height="1em" width="0pt">Как мы уже знаем, код и данные составляют программу. Однако не все типы кода и данных имеют одинаковое назначение. По этой причине вместо большого фрагмента кода и данных они делятся на более мелкие фрагменты, и каждый фрагмент должен удовлетворять следующим условиям (согласно gABI): каждый раздел в объектном файле имеет ровно один заголовок раздела, описывающий его. Но заголовки разделов могут существовать без раздела.</p><p height="1em" width="0pt">Каждый раздел занимает одну непрерывную (возможно, пустую) последовательность байтов в файле. Это означает, что нет двух областей байтов, которые являются одним и тем же разделом.</p><p height="1em" width="0pt">Разделы в файле не могут перекрываться. Ни один байт в файле не находится более чем в одном разделе.</p><p height="1em" width="0pt">В объектном файле может быть неактивное пространство. Различные заголовки и разделы могут не «покрывать» каждый байт в объектном файле. Содержимое неактивных данных не указано.</p><p height="1em" width="0pt">Чтобы получить все заголовки из исполняемого двоичного файла, например. привет, используйте следующую команду:</p><p height="1em" width="0pt">$ readelf -S привет</p><p height="1em" width="0pt">Вот пример вывода (не беспокойтесь, если вы его не понимаете. Просто бегло просмотрите его, чтобы ознакомиться с ним. Мы достаточно скоро его разберем):</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Имеется 31 заголовок раздела, начиная со смещения 0x19c8: Заголовки разделов:</p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">115</p><p height="1em" width="0pt">[ 0]</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">00000000</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">[ 1] .интерп</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400238</p><p height="1em" width="0pt">00000238</p><p height="1em" width="0pt">000000000000001c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 2] .note.ABI-тег</p><p height="1em" width="0pt">ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">0000000000400254</p><p height="1em" width="0pt">00000254</p><p height="1em" width="0pt">0000000000000020</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 3] .note.gnu.build-i ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">0000000000400274</p><p height="1em" width="0pt">00000274</p><p height="1em" width="0pt">0000000000000024</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 4] .gnu.хэш</p><p height="1em" width="0pt">GNU_HASH</p><p height="1em" width="0pt">0000000000400298</p><p height="1em" width="0pt">00000298</p><p height="1em" width="0pt">000000000000001c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[ 5] .dynsym</p><p height="1em" width="0pt">ДИНСИМ</p><p height="1em" width="0pt">00000000004002b8</p><p height="1em" width="0pt">000002b8</p><p height="1em" width="0pt">0000000000000048</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[ 6 ] .динстр</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">0000000000400300</p><p height="1em" width="0pt">00000300</p><p height="1em" width="0pt">0000000000000038</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 7] .gnu.версия</p><p height="1em" width="0pt">ВЕРСИМ</p><p height="1em" width="0pt">0000000000400338</p><p height="1em" width="0pt">00000338</p><p height="1em" width="0pt">0000000000000006</p><p height="1em" width="0pt">0000000000000002</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">[8] .gnu.version_r</p><p height="1em" width="0pt">ВЕРНЕЕД</p><p height="1em" width="0pt">0000000000400340</p><p height="1em" width="0pt">00000340</p><p height="1em" width="0pt">0000000000000020</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[ 9] .рела.дин</p><p height="1em" width="0pt">РЕЛА</p><p height="1em" width="0pt">0000000000400360</p><p height="1em" width="0pt">00000360</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[10] .rela.plt</p><p height="1em" width="0pt">РЕЛА</p><p height="1em" width="0pt">0000000000400378</p><p height="1em" width="0pt">00000378</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">ИИ</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">24</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[11] .инит</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400390</p><p height="1em" width="0pt">00000390</p><p height="1em" width="0pt">000000000000001а</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[12] .плт</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004003b0</p><p height="1em" width="0pt">000003b0</p><p height="1em" width="0pt">0000000000000020</p><p height="1em" width="0pt">0000000000000010</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">[13] .plt.гот</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004003d0</p><p height="1em" width="0pt">000003d0</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[14] .текст</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004003e0</p><p height="1em" width="0pt">000003e0</p><p height="1em" width="0pt">0000000000000192</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">[15] .фини</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400574</p><p height="1em" width="0pt">00000574</p><p height="1em" width="0pt">0000000000000009</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[16] .родата</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400580</p><p height="1em" width="0pt">00000580</p><p height="1em" width="0pt">0000000000000004</p><p height="1em" width="0pt">0000000000000004</p><p height="1em" width="0pt">ЯВЛЯЮСЬ</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">116</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">[17] .eh_frame_hdr</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400584</p><p height="1em" width="0pt">00000584</p><p height="1em" width="0pt">000000000000003c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[18] .eh_frame</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004005c0</p><p height="1em" width="0pt">000005c0</p><p height="1em" width="0pt">0000000000000114</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[19] .init_array</p><p height="1em" width="0pt">INIT_ARRAY</p><p height="1em" width="0pt">0000000000600e10</p><p height="1em" width="0pt">00000e10</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[20] .fini_array</p><p height="1em" width="0pt">FINI_ARRAY</p><p height="1em" width="0pt">0000000000600e18</p><p height="1em" width="0pt">00000e18</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[21] .jcr</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000600e20</p><p height="1em" width="0pt">00000e20</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[22] .динамический</p><p height="1em" width="0pt">ДИНАМИЧЕСКИЙ</p><p height="1em" width="0pt">0000000000600e28</p><p height="1em" width="0pt">00000e28</p><p height="1em" width="0pt">00000000000001d0</p><p height="1em" width="0pt">0000000000000010</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[23] .гот</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000600ff8</p><p height="1em" width="0pt">00000ff8</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[24] .got.plt</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000601000</p><p height="1em" width="0pt">00001000</p><p height="1em" width="0pt">0000000000000020</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[25] .данные</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000601020</p><p height="1em" width="0pt">00001020</p><p height="1em" width="0pt">0000000000000010</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[26] .bss</p><p height="1em" width="0pt">НОБИТЫ</p><p height="1em" width="0pt">0000000000601030</p><p height="1em" width="0pt">00001030</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[27] .комментарий</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">00001030</p><p height="1em" width="0pt">0000000000000034</p><p height="1em" width="0pt">0000000000000001</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[28] .shstrtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">000018b6</p><p height="1em" width="0pt">000000000000010c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[29] .симтаб</p><p height="1em" width="0pt">СИМТАБ</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">00001068</p><p height="1em" width="0pt">00000000000000648</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">30</p><p height="1em" width="0pt">47</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[30] .strtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">000016b0</p><p height="1em" width="0pt">0000000000000206</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Ключ к флагам:</p><p height="1em" width="0pt">W (запись), A (распределение), X (выполнение), M (объединение), S (строки), l (большой размер), I (информация), L (порядок ссылок), G (группа), T (TLS), E (исключить), x (неизвестно) O (требуется дополнительная обработка ОС) o (зависит от ОС), p (зависит от процессора) Первая строка:</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">117</p><p height="1em" width="0pt">Имеется 31 заголовок раздела, начиная со смещения 0x19c8.</p><p height="1em" width="0pt">суммирует общее количество разделов в файле, а где адрес, где он начинается. Затем идет список по разделам со следующим заголовком, который также является форматом вывода каждого раздела:<b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">В каждом разделе есть две строки с разными полями:</p><p height="1em" width="0pt"><b>№</b>Указатель каждого раздела.</p><p height="1em" width="0pt"><b>Имя</b>Название каждого раздела.</p><p height="1em" width="0pt"><b>Тип</b>Это поле (в заголовке раздела) определяет тип каждого раздела.</p><p height="1em" width="0pt">Типы используются для классификации разделов.</p><p height="1em" width="0pt"><b>Адрес</b>Старт<i>виртуальный</i>адрес каждой секции. Обратите внимание, что адреса являются виртуальными только тогда, когда программа работает в ОС с включенной поддержкой виртуальной памяти. В нашей ОС мы работаем на голом железе, все адреса будут физическими.</p><p height="1em" width="0pt"><b>Компенсировать</b>это расстояние в байтах от первого байта файла до начала объекта, такого как раздел или сегмент в контексте двоичного файла ELF.</p><p height="1em" width="0pt"><b>Размер</b>Размер в байтах каждой секции.</p><p height="1em" width="0pt"><b>EntSize</b>Некоторые разделы содержат таблицу записей фиксированного размера, например таблицу символов. Для такого раздела этот член дает размер в байтах каждой записи. Элемент содержит 0, если в разделе нет таблицы записей фиксированного размера.</p><p height="1em" width="0pt"><b>Флаги</b>описывает атрибуты раздела. Флаги вместе с типом определяют назначение секции. Две секции могут быть одного типа, но служить разным целям. Например, хотя .data и .text имеют один и тот же тип, .data содержит инициализированные данные программы, а</p><p height="1em" width="0pt">118</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">.text содержит исполняемые инструкции программы. По этой причине,</p><p height="1em" width="0pt">.data предоставляется разрешение на чтение и запись, но не исполняемый. Любая попытка выполнить код в .data отвергается работающей ОС: в Linux такое использование недопустимого раздела дает<i>ошибка сегментации</i>.</p><p height="1em" width="0pt">ELF предоставляет информацию для включения ОС с таким механизмом защиты. Впрочем, работая на голом железе, ничего не мешает делать. Наша ОС может выполнять код в секции данных и наоборот, писать в секцию кода.</p><p height="1em" width="0pt"><b>Таблица 5.3.1:</b>Флаги раздела</p><p height="1em" width="0pt"><b>Флаг</b></p><p height="1em" width="0pt"><b>Описания</b></p><p height="1em" width="0pt">Вт</p><p height="1em" width="0pt">Байты в этом разделе доступны для записи во время выполнения.</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">Память для этого раздела выделяется во время выполнения процесса. Некоторые разделы управления не находятся в образе памяти объектного файла; этот атрибут отключен для этих разделов.</p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">Раздел содержит исполняемые инструкции.</p><p height="1em" width="0pt">М</p><p height="1em" width="0pt">Данные<i>в разделе</i>могут быть объединены для устранения дублирования. Каждый элемент в разделе сравнивается с другими элементами в разделах с тем же именем, типом и флагами.</p><p height="1em" width="0pt">Элементы, которые имели бы одинаковые значения во время выполнения программы, могут быть объединены.</p><p height="1em" width="0pt">С</p><p height="1em" width="0pt">Элементы данных в разделе состоят из строк символов, заканчивающихся нулем. Размер каждого символа указан в шапке раздела.<i><b>EntSize</b></i>поле.</p><p height="1em" width="0pt">л</p><p height="1em" width="0pt">Специальный большой раздел для архитектуры x86_64. Этот флаг указан не в Generic ABI, а в x86_64 ABI.</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt"><i><b>Информация</b></i>Поле заголовка этого раздела содержит индекс заголовка раздела. В противном случае число является индексом чего-то другого.</p><p height="1em" width="0pt">л</p><p height="1em" width="0pt">Сохраняйте порядок разделов при связывании. Если этот раздел объединяется с другими разделами в выходном файле, он должен отображаться в том же относительном порядке по отношению к этим разделам, что и связанный раздел по отношению к разделам, с которыми объединен связанный раздел. Применить, когда<i><b>Связь</b></i>поле заголовка этого раздела ссылается на другой раздел (связанный раздел)</p><p height="1em" width="0pt">г</p><p height="1em" width="0pt">Этот раздел является членом (возможно, единственным) группы разделов.</p><p height="1em" width="0pt">Т</p><p height="1em" width="0pt">Этот раздел содержит<b>Т</b>хлеб-<b>л</b>местный<b>С</b>torage, что означает, что каждый поток имеет свой отдельный экземпляр этих данных. Поток — это отдельный поток выполнения кода. Программа может иметь несколько потоков, которые упаковывают разные фрагменты кода и выполняются отдельно в одно и то же время.</p><p height="1em" width="0pt">Мы узнаем больше о потоках при написании нашего ядра.</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">119</p><p height="1em" width="0pt">Е</p><p height="1em" width="0pt">Редактор ссылок должен исключить этот раздел из исполняемой и совместно используемой библиотек, которые он создает, когда эти объекты не подлежат дальнейшему перемещению.</p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">Неизвестный флаг для readelf. Это происходит потому, что процесс связывания можно выполнить вручную с помощью компоновщика, такого как GNU ld (мы вернемся позже). То есть флаги разделов можно указать вручную, а некоторые флаги предназначены для настраиваемого ELF, о котором не знает readelf с открытым исходным кодом.</p><p height="1em" width="0pt">О</p><p height="1em" width="0pt">Этот раздел требует специальной обработки для конкретной ОС (помимо стандартных правил компоновки), чтобы избежать некорректного поведения. Редактор ссылок встречает разделы, заголовки которых содержат специфичные для ОС значения, которые он не распознает по значениям типа или флагов, определенным стандартом ELF, редактор ссылок должен объединить эти разделы.</p><p height="1em" width="0pt">о</p><p height="1em" width="0pt">Все биты, включенные в этот флаг, зарезервированы для семантики конкретной операционной системы.</p><p height="1em" width="0pt">п</p><p height="1em" width="0pt">Все биты, включенные в этот флаг, зарезервированы для семантики конкретного процессора. Если значения указаны, приложение процессора поясняет их.</p><p height="1em" width="0pt"> <i><b>Ссылка и информация</b></i>числа, которые ссылаются на индексы разделов, записи таблицы символов, записи хеш-таблицы. Поле Link содержит только индекс раздела, а поле Info содержит индекс раздела, запись таблицы символов или запись хэш-таблицы, в зависимости от типа раздела.</p><p height="1em" width="0pt">Позже, при написании нашей ОС, мы вручную создадим образ ядра, явно связав объектные файлы (созданные gcc) через сценарий компоновщика.</p><p height="1em" width="0pt">Мы укажем расположение разделов в памяти, указав, по каким адресам они появятся в конечном образе. Но мы не будем назначать какой-либо флаг раздела и позволим компоновщику позаботиться об этом. Тем не менее, знать, какой флаг делает то, что полезно.</p><p height="1em" width="0pt"><b>Выровнять</b>это значение, которое обеспечивает смещение раздела, должно быть кратно значению. Допускаются только 0 и положительные целые степени двойки.</p><p height="1em" width="0pt">Значения 0 и 1 означают, что секция не имеет ограничений по выравниванию.</p><p height="1em" width="0pt"><b>Пример 5.3.1.</b>Вывод раздела .interp:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">[ 1] .интерп</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400238</p><p height="1em" width="0pt">00000238</p><p height="1em" width="0pt">000000000000001c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt"> <i>№</i>1.</p><a id="filepos384929" /><p height="1em" width="0pt">120</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>Тип</i>это PROGBITS, что означает, что этот раздел является частью программы.</p><p height="1em" width="0pt"> <i>Адрес</i>равен 0x0000000000400238, что означает, что программа загружается по этому адресу виртуальной памяти во время выполнения.</p><p height="1em" width="0pt"> <i>Компенсировать</i>0x00000238<i>байты</i>в файл.</p><p height="1em" width="0pt"> <i>Размер</i>0x000000000000001c в байтах.</p><p height="1em" width="0pt"> <i>EntSize</i>равен 0, что означает, что в этом разделе нет записи фиксированного размера.</p><p height="1em" width="0pt"> <i>Флаги</i>являются A (распределяемыми), что означает, что этот раздел потребляет память во время выполнения.</p><p height="1em" width="0pt"> <i>Информация</i>и Link равны 0 и 0, что означает, что этот раздел не связан ни с одним разделом или записью в какой-либо таблице.</p><p height="1em" width="0pt"> <i>Выровнять</i>равен 1, что означает отсутствие выравнивания.</p><p height="1em" width="0pt"><b>Пример 5.3.2.</b>Вывод раздела .text:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">[14] .текст</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004003e0</p><p height="1em" width="0pt">000003e0</p><p height="1em" width="0pt">0000000000000192</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt"> <i>№</i>14.</p><p height="1em" width="0pt"> <i>Тип</i>это PROGBITS, что означает, что этот раздел является частью программы.</p><p height="1em" width="0pt"> <i>Адрес</i>равен 0x00000000004003e0, что означает, что программа загружается по этому адресу виртуальной памяти во время выполнения.</p><p height="1em" width="0pt"> <i>Компенсировать</i>0x000003e0<i>байты</i>в файл.</p><p height="1em" width="0pt"> <i>Размер</i>0x0000000000000192 в байтах.</p><p height="1em" width="0pt"> <i>EntSize</i>равен 0, что означает, что в этом разделе нет записи фиксированного размера.</p><p height="1em" width="0pt"> <i>Флаги</i>являются A (распределяемый) и X (исполняемый), что означает, что этот раздел потребляет память и может выполняться как код во время выполнения.</p><p height="1em" width="0pt"> <i>Информация</i>и Link равны 0 и 0, что означает, что этот раздел не связан ни с одним разделом или записью в какой-либо таблице.</p><p height="1em" width="0pt"> <i>Выровнять</i>равно 16, что означает, что начальный адрес раздела должен делиться на 16 или 0x10. Действительно, это: 0x3e0/0x10 = 0x3e.</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">121</p><p height="1em" width="0pt"><b>5.4</b></p><p height="1em" width="0pt"><b>Подробно разобраться в разделе</b></p><p height="1em" width="0pt">В этом разделе мы узнаем различные подробности о типах разделов и целях специальных разделов, например. .bss, .text, .data и т. д., просматривая каждый раздел один за другим. Мы также рассмотрим содержимое каждого раздела в виде шестнадцатеричного дампа с помощью команд:</p><p height="1em" width="0pt">$ readelf -x <имя раздела|номер раздела> <файл> Например, если вы хотите просмотреть содержимое раздела с индексом 25 (раздел .bss в образце вывода) в файле hello: $ readelf -x 25 hello</p><p height="1em" width="0pt">Аналогично, использование имени вместо индекса работает:</p><p height="1em" width="0pt">$ readelf -x .data привет</p><p height="1em" width="0pt">Если раздел содержит строки, например. в таблице строковых символов флаг -x можно заменить на -p.</p><p height="1em" width="0pt"> <i><b>НУЛЕВОЙ</b></i>помечает заголовок раздела как неактивный и не имеет связанного раздела. Раздел NULL всегда является первой записью в таблице заголовков разделов.</p><p height="1em" width="0pt">Это означает, что любой полезный раздел начинается с 1.</p><p height="1em" width="0pt"><b>Пример 5.4.1.</b>Пример вывода раздела NULL:<b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">[ 0]</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">0000000000000000 00000000</p><p height="1em" width="0pt">0000000000000000 0000000000000000</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Изучив содержимое, раздел пуст:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">В разделе ” нет данных для дампа.</p><p height="1em" width="0pt">122</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i><b>ПРИМЕЧАНИЕ</b></i>отмечает раздел со специальной информацией, которую другие программы будут проверять на соответствие, совместимость и т. д. поставщиком или сборщиком системы.</p><p height="1em" width="0pt"><b>Пример 5.4.2.</b>В образце вывода у нас есть 2 раздела ПРИМЕЧАНИЕ:<b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">[ 2] .note.ABI-тег</p><p height="1em" width="0pt">ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">0000000000400254</p><p height="1em" width="0pt">00000254</p><p height="1em" width="0pt">0000000000000020</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 3] .note.gnu.build-i ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">0000000000400274</p><p height="1em" width="0pt">00000274</p><p height="1em" width="0pt">0000000000000024</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">Изучите 2-й раздел с помощью команды:</p><p height="1em" width="0pt">$ readelf -x 2 привет</p><p height="1em" width="0pt">у нас есть:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Шестнадцатеричный дамп раздела ‘.note.ABI-tag’:</p><p height="1em" width="0pt">0x00400254 04000000 10000000 01000000 474e5500 ............GNU.</p><p height="1em" width="0pt">0x00400264 00000000 02000000 06000000 20000000 ............ ...</p><p height="1em" width="0pt"> <i><b>PROGBITS</b></i>указывает раздел, содержащий основное содержание программы, либо код, либо данные.</p><p height="1em" width="0pt"><b>Пример 5.4.3.</b>Разделов PROGBITS много:<b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">[ 1] .интерп</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400238</p><p height="1em" width="0pt">00000238</p><p height="1em" width="0pt">000000000000001c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">[11] .инит</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400390</p><p height="1em" width="0pt">00000390</p><p height="1em" width="0pt">000000000000001а</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[12] .плт</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004003b0</p><p height="1em" width="0pt">000003b0</p><p height="1em" width="0pt">0000000000000020</p><p height="1em" width="0pt">0000000000000010</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">[13] .plt.гот</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004003d0</p><p height="1em" width="0pt">000003d0</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">123</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[14] .текст</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004003e0</p><p height="1em" width="0pt">000003e0</p><p height="1em" width="0pt">0000000000000192</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">[15] .фини</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400574</p><p height="1em" width="0pt">00000574</p><p height="1em" width="0pt">0000000000000009</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[16] .родата</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400580</p><p height="1em" width="0pt">00000580</p><p height="1em" width="0pt">0000000000000004</p><p height="1em" width="0pt">0000000000000004</p><p height="1em" width="0pt">ЯВЛЯЮСЬ</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[17] .eh_frame_hdr</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000400584</p><p height="1em" width="0pt">00000584</p><p height="1em" width="0pt">000000000000003c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[18] .eh_frame</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000004005c0</p><p height="1em" width="0pt">000005c0</p><p height="1em" width="0pt">0000000000000114</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">[23] .гот</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000600ff8</p><p height="1em" width="0pt">00000ff8</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[24] .got.plt</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000601000</p><p height="1em" width="0pt">00001000</p><p height="1em" width="0pt">0000000000000020</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[25] .данные</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000601020</p><p height="1em" width="0pt">00001020</p><p height="1em" width="0pt">0000000000000010</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[27] .комментарий</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">00001030</p><p height="1em" width="0pt">0000000000000034</p><p height="1em" width="0pt">0000000000000001</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Для нашей операционной системы нам нужен только следующий раздел:</p><p height="1em" width="0pt"> <i>.текст</i>Этот раздел содержит весь скомпилированный код программы.</p><p height="1em" width="0pt"> <i>.данные</i>Этот раздел содержит инициализированные данные программы. Поскольку данные инициализируются фактическими значениями, gcc выделяет раздел с фактическим байтом в исполняемом двоичном файле.</p><p height="1em" width="0pt"> <i>.родата</i>Этот раздел содержит данные только для чтения, такие как строки фиксированного размера в программе, например. «Привет, мир» и другие.</p><p height="1em" width="0pt"> <i>.bss</i>В этом разделе шорты для<i><b>Б</b></i><i>замок</i><i><b>С</b></i><i>инициировано</i><i><b>С</b></i><i>символ</i>, содержит неинициализированные данные программы. В отличие от других разделов, для этого раздела не выделяется место в образе исполняемого бинарника на диске.</p><p height="1em" width="0pt">Раздел выделяется только тогда, когда программа загружается в основную память.</p><p height="1em" width="0pt">124</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Другие разделы в основном нужны для динамического связывания, то есть связывания кода во время выполнения для совместного использования многими программами. Для включения такой функции необходимо представить ОС как среду выполнения.</p><p height="1em" width="0pt">Поскольку мы запускаем нашу ОС на «голом железе», мы эффективно создаем такую ​​среду. Для простоты мы не будем добавлять динамическое связывание в нашу ОС.</p><p height="1em" width="0pt"> <i><b>СИМТАБ и ДИНСИМ</b></i>Эти разделы содержат таблицу символов. А<i>таблица символов</i>представляет собой массив записей, описывающих символы в программе. А<i>символ</i>это имя, присвоенное объекту в программе. Типы этих сущностей также являются типами символов, и это возможные типы сущности:</p><p height="1em" width="0pt"><b>Пример 5.4.4.</b>В образце выходных данных разделы 5 и 29 представляют собой таблицы символов:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">[ 5] .dynsym</p><p height="1em" width="0pt">ДИНСИМ</p><p height="1em" width="0pt">00000000004002b8</p><p height="1em" width="0pt">000002b8</p><p height="1em" width="0pt">0000000000000048</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">...</p><p height="1em" width="0pt">[29] .симтаб</p><p height="1em" width="0pt">СИМТАБ</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">00001068</p><p height="1em" width="0pt">00000000000000648</p><p height="1em" width="0pt">0000000000000018</p><p height="1em" width="0pt">30</p><p height="1em" width="0pt">47</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">Чтобы отобразить таблицу символов:</p><p height="1em" width="0pt">$ readelf -с привет</p><p height="1em" width="0pt">Вывод состоит из 2 таблиц символов, соответствующих двум разделам выше, .dynsym и .symtab:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Таблица символов «.dynsym» содержит 4 записи:</p><p height="1em" width="0pt">Номер:</p><p height="1em" width="0pt">Ценить</p><p height="1em" width="0pt">Размер Тип</p><p height="1em" width="0pt">Связывать</p><p height="1em" width="0pt">Вис</p><p height="1em" width="0pt">Имя NDX</p><p height="1em" width="0pt">0: 0000000000000000</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">МЕСТНЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND</p><p height="1em" width="0pt">1: 0000000000000000</p><p height="1em" width="0pt">0 ФУНКЦИЯ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND puts@GLIBC_2.2.5 (2)</p><p height="1em" width="0pt">2: 0000000000000000</p><p height="1em" width="0pt">0 ФУНКЦИЯ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND __libc_start_main@GLIBC_2.2.5 (2)</p><p height="1em" width="0pt">3: 0000000000000000</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">СЛАБЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND __gmon_start__</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">125</p><p height="1em" width="0pt">Таблица символов '.symtab' содержит 67 записей:</p><p height="1em" width="0pt">Номер:</p><p height="1em" width="0pt">Ценить</p><p height="1em" width="0pt">Размер Тип</p><p height="1em" width="0pt">Связывать</p><p height="1em" width="0pt">Вис</p><p height="1em" width="0pt">Имя NDX</p><p height="1em" width="0pt">..........................................</p><p height="1em" width="0pt">59: 0000000000601040</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">26 _конец</p><p height="1em" width="0pt">60: 0000000000400430</p><p height="1em" width="0pt">42 ФУНКЦИЯ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">14 _старт</p><p height="1em" width="0pt">61: 0000000000601038</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">26 __bss_start</p><p height="1em" width="0pt">62: 0000000000400526</p><p height="1em" width="0pt">32 ФУНКЦИИ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">14 основных</p><p height="1em" width="0pt">63: 00000000000000000</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">СЛАБЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND _Jv_RegisterClasses</p><p height="1em" width="0pt">64: 0000000000601038</p><p height="1em" width="0pt">0 ОБЪЕКТ</p><p height="1em" width="0pt">ГЛОБАЛЬНЫЙ СКРЫТЫЙ</p><p height="1em" width="0pt">25 __TMC_END__</p><p height="1em" width="0pt">65: 00000000000000000</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">СЛАБЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND _ITM_registerTMCloneTable</p><p height="1em" width="0pt">66: 00000000004003c8</p><p height="1em" width="0pt">0 ФУНКЦИЯ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">11 _инит</p><p height="1em" width="0pt"> <i>TLS</i>символ связан с объектом Thread-Local Storage.</p><p height="1em" width="0pt"> <i>Число</i>это индекс записи в таблице.</p><p height="1em" width="0pt"> <i>Ценить</i>адрес виртуальной памяти, где находится символ.</p><p height="1em" width="0pt"> <i>Размер</i>размер объекта, связанного с символом.</p><p height="1em" width="0pt"> <i>Тип</i>является типом символа в соответствии с таблицей.</p><p height="1em" width="0pt"> <i>НЕТИП</i>Тип символа не указан.</p><p height="1em" width="0pt"> <i>ОБЪЕКТ</i>символ связан с объектом данных. В C любое определение переменной имеет тип OBJECT.</p><p height="1em" width="0pt"> <i>ФУНКЦИЯ</i>Символ связан с функцией или другим исполняемым кодом.</p><p height="1em" width="0pt"> <i>РАЗДЕЛ</i>символ связан с разделом и существует в основном для перемещения.</p><p height="1em" width="0pt"> <i>ФАЙЛ</i>Символ — это имя исходного файла, связанного с исполняемым двоичным файлом.</p><p height="1em" width="0pt"> <i>ОБЩИЙ</i>символ помечает неинициализированную переменную. То есть, когда переменная в C определяется как глобальная переменная без начального значения или как внешняя переменная с использованием ключевого слова extern. Другими словами, эти переменные остаются в разделе .bss.</p><p height="1em" width="0pt"> <i>Связывать</i>является областью действия символа.</p><p height="1em" width="0pt"> <i><b>МЕСТНЫЙ</b></i>являются символами, видимыми только в объектных файлах, в которых они определены. В C модификатор static помечает символ (например,</p><p height="1em" width="0pt">переменная/функция) как локальная только для файла, который ее определяет.</p><p height="1em" width="0pt">126</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Пример 5.4.5.</b>Если мы определим переменные и функции с модификатором static:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>статический интервал</b>глобальная_статическая_вар = 0;</p><p height="1em" width="0pt"><b>статическая пустота</b>local_func () {</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt"><b>статический интервал</b>локальная_статическая_вар = 0;</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Затем мы получаем статические переменные, перечисленные как локальные символы после компиляции:</p><p height="1em" width="0pt">$ gcc -m32 привет.c -о привет</p><p height="1em" width="0pt">$ readelf -с привет</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Таблица символов «.dynsym» содержит 5 записей:</p><p height="1em" width="0pt">Номер:</p><p height="1em" width="0pt">Ценить</p><p height="1em" width="0pt">Размер Тип</p><p height="1em" width="0pt">Связывать</p><p height="1em" width="0pt">Вис</p><p height="1em" width="0pt">Имя NDX</p><p height="1em" width="0pt">0: 00000000</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">МЕСТНЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND</p><p height="1em" width="0pt">1: 00000000</p><p height="1em" width="0pt">0 ФУНКЦИЯ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND puts@GLIBC_2.0 (2)</p><p height="1em" width="0pt">2: 00000000</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">СЛАБЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND __gmon_start__</p><p height="1em" width="0pt">3: 00000000</p><p height="1em" width="0pt">0 ФУНКЦИЯ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND __libc_start_main@GLIBC_2.0 (2)</p><p height="1em" width="0pt">4: 080484bc</p><p height="1em" width="0pt">4 ОБЪЕКТ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">16 _IO_stdin_used</p><p height="1em" width="0pt">Таблица символов '.symtab' содержит 72 записи:</p><p height="1em" width="0pt">Номер:</p><p height="1em" width="0pt">Ценить</p><p height="1em" width="0pt">Размер Тип</p><p height="1em" width="0pt">Связывать</p><p height="1em" width="0pt">Вис</p><p height="1em" width="0pt">Имя NDX</p><p height="1em" width="0pt">0: 00000000</p><p height="1em" width="0pt">0 НЕТИП</p><p height="1em" width="0pt">МЕСТНЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">UND</p><p height="1em" width="0pt">......... вывод опущен .........</p><p height="1em" width="0pt">38: 0804a020</p><p height="1em" width="0pt">4 ОБЪЕКТ</p><p height="1em" width="0pt">МЕСТНЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">26 global_static_var</p><p height="1em" width="0pt">39: 0804840б</p><p height="1em" width="0pt">6 ФУНКЦИИ</p><p height="1em" width="0pt">МЕСТНЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">14 локальная_функция</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">127</p><p height="1em" width="0pt">40: 0804a024</p><p height="1em" width="0pt">4 ОБЪЕКТ</p><p height="1em" width="0pt">МЕСТНЫЙ</p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">26 локальная_статическая_вар.1938</p><p height="1em" width="0pt">......... вывод опущен .........</p><p height="1em" width="0pt"> <i><b>ГЛОБАЛЬНЫЙ</b></i><i>являются</i>символы, доступные другим объектным файлам при компоновке. Эти символы в основном представляют собой нестатические функции и нестатические глобальные данные. Модификатор extern помечает символ как внешне определенный в другом месте, но доступен в конечном исполняемом двоичном файле, поэтому переменная extern также считается ГЛОБАЛЬНОЙ.</p><p height="1em" width="0pt"><b>Пример 5.4.6.</b>Как и в приведенном выше примере LOCAL, в выходных данных перечислено множество символов GLOBAL, таких как main:</p><p height="1em" width="0pt">Номер:</p><p height="1em" width="0pt">Ценить</p><p height="1em" width="0pt">Размер Тип</p><p height="1em" width="0pt">Связывать</p><p height="1em" width="0pt">Вис</p><p height="1em" width="0pt">Имя NDX</p><p height="1em" width="0pt">......... вывод опущен .........</p><p height="1em" width="0pt">66: 080483e1</p><p height="1em" width="0pt">10 ФУНКЦ.</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">14 основных</p><p height="1em" width="0pt">......... вывод опущен .........</p><p height="1em" width="0pt"> <i><b>СЛАБЫЙ</b></i>являются символами, определения которых могут быть переопределены. Обычно компилятор сообщает о символе с несколькими определениями как об ошибке. Однако это ограничение является слабым, когда определение явно помечено как слабое, что означает, что реализация по умолчанию может быть заменена другим определением во время компоновки.</p><p height="1em" width="0pt"><b>Пример 5.4.7.</b>Предположим, у нас есть реализация функции add по умолчанию:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt">__атрибут__((слабый))<b>инт</b>добавлять(<b>инт</b>а,<b>инт</b>б) {</p><p height="1em" width="0pt">printf("Внимание: функция не реализована.\n")</p><p height="1em" width="0pt">;</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">128</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">printf("добавить(1,2) равно %d\n", добавить(1,2));</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">__attribute__((weak)) — это атрибут функции. А<i>функция на-</i></p><p height="1em" width="0pt"> <i><b>атрибут функции</b></i></p><p height="1em" width="0pt"> <i>дань</i>это дополнительная информация для компилятора, позволяющая обрабатывать функцию не так, как обычную функцию. В этом примере слабый атрибут заставляет функцию добавлять слабую функцию, что означает, что реализация по умолчанию может быть заменена другим определением во время компоновки. Атрибут функции — это функция компилятора, а не стандарта C.</p><p height="1em" width="0pt">Если мы не предоставляем другое определение функции в другом файле (должно быть в другом файле, иначе gcc сообщает об ошибке), тогда применяется реализация по умолчанию. Когда функция add вызывается, она печатает только сообщение: «предупреждение: функция не реализована» и возвращает 0:</p><p height="1em" width="0pt">$ ./привет</p><p height="1em" width="0pt">предупреждение: функция не реализована.</p><p height="1em" width="0pt">добавить (1,2) равно 0</p><p height="1em" width="0pt">Однако, если мы предоставим другое определение в другом файле, например. математика.с: математика.с</p><p height="1em" width="0pt"><b>инт</b>добавлять(<b>инт</b>а,<b>инт</b>б) {</p><p height="1em" width="0pt"><b>возвращаться</b>а + б;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">и скомпилируйте два файла вместе:</p><p height="1em" width="0pt">$ gcc math.c hello.c -o привет</p><p height="1em" width="0pt">Затем при запуске hello предупреждающее сообщение не выводится и возвращается правильное значение.</p><p height="1em" width="0pt">Слабый символ — это механизм, обеспечивающий реализацию по умолчанию, но заменяемый, когда доступна лучшая реализация (например, более специализированная и оптимизированная) во время компоновки.</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">129</p><p height="1em" width="0pt"> <i>Вис</i>это видимость символа. Доступны следующие значения:<b>Таблица 5.4.1:</b>Видимость символа</p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">Видимость определяется типом привязки asymbol.</p><p height="1em" width="0pt">Глобальные и слабые символы видны за пределами их определяющего компонента (исполняемого файла или общего объекта).</p><p height="1em" width="0pt">Местные символы скрыты. См. СКРЫТО ниже.</p><p height="1em" width="0pt">СКРЫТЫЙ</p><p height="1em" width="0pt">Символ скрыт, если его имя не видно никакой другой программе, кроме запущенной программы.</p><p height="1em" width="0pt">ЗАЩИЩЕНО</p><p height="1em" width="0pt">Символ защищен, когда он используется за пределами его работающей программы или общей библиотеки и не может быть переопределен. То есть может быть только одно определение для этого символа во всех запущенных программах, которые его используют. Ни одна программа не может определить собственное определение одного и того же символа.</p><p height="1em" width="0pt">ВНУТРЕННИЙ</p><p height="1em" width="0pt">Видимость зависит от процессора и определяется ABI для конкретного процессора.</p><p height="1em" width="0pt"> <i>NDX</i>— это индекс раздела, в котором находится символ. Помимо фиксированных номеров индексов, которые представляют индексы разделов, индекс имеет следующие специальные значения:</p><p height="1em" width="0pt"><b>Таблица 5.4.2:</b>Индекс символа</p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">АБС</p><p height="1em" width="0pt">Индекс не будет изменен никаким перемещением символа.</p><p height="1em" width="0pt">COM</p><p height="1em" width="0pt">Индекс относится к нераспределенному общему блоку.</p><p height="1em" width="0pt">UND</p><p height="1em" width="0pt">Символ не определен в текущем объектном файле, что означает, что символ зависит от фактического определения в другом файле. Неопределенные символы появляются, когда объектный файл ссылается на символы, доступные во время выполнения из общей библиотеки.</p><p height="1em" width="0pt">ЛОРЕСЕРВ</p><p height="1em" width="0pt">LORESERVE – нижняя граница запасных показателей. Его значение равно 0xff00.</p><p height="1em" width="0pt">АРЕНДА</p><p height="1em" width="0pt">HIREVERSE — верхняя граница резервных показателей. Его значение равно 0xffff.</p><p height="1em" width="0pt">Операционная система резервирует эксклюзивные индексы между LORESERVE и HIRESERVE, которые не сопоставляются ни с одним фактическим заголовком раздела.</p><p height="1em" width="0pt">СИНДЕКС</p><p height="1em" width="0pt">Индекс больше, чем LORESERVE. Фактическое значение будет содержаться в разделе SYMTAB_SHNDX, где каждая запись представляет собой сопоставление между символом, чье поле Ndx является значением XINDEX, и фактическим значением индекса.</p><p height="1em" width="0pt">130</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Другие</p><p height="1em" width="0pt">Иногда появляются такие значения, как ANSI_COM, LARGE_COM, SCOM, SUND. Это означает, что индекс зависит от процессора.</p><p height="1em" width="0pt"> <i>Имя</i>это имя символа.</p><p height="1em" width="0pt"><b>Пример 5.4.8.</b>Прикладная программа C всегда начинается с символа main. Запись для main в таблице символов в разделе .symtab:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Номер:</p><p height="1em" width="0pt">Ценить</p><p height="1em" width="0pt">Размер Тип</p><p height="1em" width="0pt">Связывать</p><p height="1em" width="0pt">Вис</p><p height="1em" width="0pt">Имя NDX</p><p height="1em" width="0pt">62:</p><p height="1em" width="0pt">0000000000400526</p><p height="1em" width="0pt">32 ФУНКЦИИ</p><p height="1em" width="0pt">ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</p><p height="1em" width="0pt">14 основных</p><p height="1em" width="0pt">Запись показывает, что:</p><p height="1em" width="0pt">main является 62-й записью в таблице.</p><p height="1em" width="0pt">main начинается с адреса 0x0000000000400526.</p><p height="1em" width="0pt">main занимает 32 байта.</p><p height="1em" width="0pt">main - это функция.</p><p height="1em" width="0pt">main находится в глобальной области видимости.</p><p height="1em" width="0pt">main виден другим объектным файлам, которые его используют.</p><p height="1em" width="0pt">main находится внутри 14-го раздела, который называется .text. Это логично, поскольку</p><p height="1em" width="0pt">.text содержит весь программный код.</p><p height="1em" width="0pt"> <i><b>СТРТАБ</b></i>содержат таблицу строк с завершающим нулем, называемую<i>таблица строк</i>. Первый и последний байт этого раздела всегда являются символом NULL. Раздел таблицы строк существует потому, что строка может повторно использоваться более чем в одном разделе для представления символов и имен разделов, поэтому такие программы, как readelf или objdump, могут отображать различные объекты в программе, например. имена переменных, функций, разделов в удобочитаемом тексте вместо его необработанного шестнадцатеричного адреса.</p><p height="1em" width="0pt"><b>Пример 5.4.9.</b>В образце вывода разделы 28 и 30 принадлежат STRTAB.</p><p height="1em" width="0pt">тип:</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">131</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">[28] .shstrtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">000018b6</p><p height="1em" width="0pt">000000000000010c</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[30] .strtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">000016b0</p><p height="1em" width="0pt">0000000000000206</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt"> <i>.shstrtab</i>содержит все имена разделов.</p><p height="1em" width="0pt"> <i>.strtab</i>содержит символы, например. имена переменных, имена функций, имена структур и т. д. в программе C, но не строки C фиксированного размера, заканчивающиеся нулем; строки C хранятся в разделе .rodata.</p><p height="1em" width="0pt"><b>Пример 5.4.10.</b>Строки в этих разделах можно проверить с помощью команды:</p><p height="1em" width="0pt">$ readelf -p 29 привет</p><p height="1em" width="0pt">Вывод показывает все имена разделов со смещением (также строковым индексом) в .shstrtab таблицы слева:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Строковый дамп раздела ‘.shstrtab’:</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1]</p><p height="1em" width="0pt">.симтаб</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">9]</p><p height="1em" width="0pt">.strtab</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">11]</p><p height="1em" width="0pt">.shstrtab</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1б]</p><p height="1em" width="0pt">.интерп</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">23]</p><p height="1em" width="0pt">.note.ABI-тег</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">31]</p><p height="1em" width="0pt">.note.gnu.build-id</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">44]</p><p height="1em" width="0pt">.gnu.хэш</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">4д]</p><p height="1em" width="0pt">.dynsym</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">56]</p><p height="1em" width="0pt">.dynstr</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">5д]</p><p height="1em" width="0pt">.gnu.версия</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">6б]</p><p height="1em" width="0pt">.gnu.version_r</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">7а]</p><p height="1em" width="0pt">.rela.dyn</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">84]</p><p height="1em" width="0pt">.rela.plt</p><p height="1em" width="0pt">132</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">8д]</p><p height="1em" width="0pt">.в этом</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">94]</p><p height="1em" width="0pt">.plt.получил</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">9д]</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">а3]</p><p height="1em" width="0pt">.фини</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">а9]</p><p height="1em" width="0pt">.родата</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">б1]</p><p height="1em" width="0pt">.eh_frame_hdr</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">БФ]</p><p height="1em" width="0pt">.eh_frame</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">с9]</p><p height="1em" width="0pt">.init_array</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">д5]</p><p height="1em" width="0pt">.fini_array</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">е1]</p><p height="1em" width="0pt">.jcr</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">е6]</p><p height="1em" width="0pt">.динамический</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">эф]</p><p height="1em" width="0pt">.got.plt</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">f8]</p><p height="1em" width="0pt">.данные</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">fe]</p><p height="1em" width="0pt">.bss</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">103]</p><p height="1em" width="0pt">.комментарий</p><p height="1em" width="0pt">Фактическая реализация таблицы строк представляет собой непрерывный массив строк, заканчивающихся нулем. Индекс строки — это позиция ее первого символа в массиве. Например, в приведенной выше таблице строк .symtab находится в индексе 1 в массиве (символ NULL находится в индексе 0). Длина .symtab равна 7 плюс символ NULL, который занимает всего 8 байт. Итак, .strtab начинается с индекса 9 и так далее.</p><p height="1em" width="0pt"><b>00</b></p><p height="1em" width="0pt"><b>01</b></p><p height="1em" width="0pt"><b>02</b></p><p height="1em" width="0pt"><b>03</b></p><p height="1em" width="0pt"><b>04</b></p><p height="1em" width="0pt"><b>05</b></p><p height="1em" width="0pt"><b>06</b></p><p height="1em" width="0pt"><b>07</b></p><p height="1em" width="0pt"><b>08</b></p><p height="1em" width="0pt"><b>09</b></p><p height="1em" width="0pt"><b>0а</b></p><p height="1em" width="0pt"><b>0b</b></p><p height="1em" width="0pt"><b>0с</b></p><p height="1em" width="0pt"><b>0д</b></p><p height="1em" width="0pt"><b>0e</b></p><p height="1em" width="0pt"><b>0f</b></p><p height="1em" width="0pt"><b>00000000</b></p><p height="1em" width="0pt">\0</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">с</p><p height="1em" width="0pt">у</p><p height="1em" width="0pt">м</p><p height="1em" width="0pt">т</p><p height="1em" width="0pt">а</p><p height="1em" width="0pt">б</p><p height="1em" width="0pt">\0</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">с</p><p height="1em" width="0pt">т</p><p height="1em" width="0pt">р</p><p height="1em" width="0pt">т</p><p height="1em" width="0pt">а</p><p height="1em" width="0pt">б</p><p height="1em" width="0pt"><b>00</b></p><p height="1em" width="0pt"><b>01</b></p><p height="1em" width="0pt"><b>02</b></p><p height="1em" width="0pt"><b>03</b></p><p height="1em" width="0pt"><b>04</b></p><p height="1em" width="0pt"><b>05</b></p><p height="1em" width="0pt"><b>06</b></p><p height="1em" width="0pt"><b>07</b></p><p height="1em" width="0pt"><b>08</b></p><p height="1em" width="0pt"><b>09</b></p><p height="1em" width="0pt"><b>0а</b></p><p height="1em" width="0pt"><b>0b</b></p><p height="1em" width="0pt"><b>0с</b></p><p height="1em" width="0pt"><b>0д</b></p><p height="1em" width="0pt"><b>0e</b></p><p height="1em" width="0pt"><b>0f</b></p><p height="1em" width="0pt"><b>00000010</b></p><p height="1em" width="0pt">\0</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">с</p><p height="1em" width="0pt">час</p><p height="1em" width="0pt">с</p><p height="1em" width="0pt">т</p><p height="1em" width="0pt">р</p><p height="1em" width="0pt">т</p><p height="1em" width="0pt">а</p><p height="1em" width="0pt">б</p><p height="1em" width="0pt">\0</p><p height="1em" width="0pt">.</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt">н</p><p height="1em" width="0pt">т</p><p height="1em" width="0pt">е</p><p height="1em" width="0pt">.... и так далее ....</p><p height="1em" width="0pt"><b>Рисунок 5.4.1:</b>Строковая таблица в</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt">из</p><p height="1em" width="0pt">.shstrtab. красный</p><p height="1em" width="0pt">номер - это начальный индекс</p><p height="1em" width="0pt">Точно так же вывод .strtab:</p><p height="1em" width="0pt">нить.</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Строковый дамп раздела ‘.strtab’:</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1]</p><p height="1em" width="0pt">crtstuff.c</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">в]</p><p height="1em" width="0pt">__JCR_LIST__</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">19]</p><p height="1em" width="0pt">отменить регистрацию_tm_clones</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">133</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">2д]</p><p height="1em" width="0pt">__do_global_dtors_aux</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">44]</p><p height="1em" width="0pt">завершено.7585</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">53]</p><p height="1em" width="0pt">__do_global_dtors_aux_fini_array_entry</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">7а]</p><p height="1em" width="0pt">кадр_манекен</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">86]</p><p height="1em" width="0pt">__frame_dummy_init_array_entry</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">а5]</p><p height="1em" width="0pt"><b>Привет</b></p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">объявление]</p><p height="1em" width="0pt">__КАДР_END__</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">бб]</p><p height="1em" width="0pt">__JCR_END__</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">с7]</p><p height="1em" width="0pt">__init_array_end</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">д8]</p><p height="1em" width="0pt">_ДИНАМИЧЕСКИЙ</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">е1]</p><p height="1em" width="0pt">__init_array_start</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">f4]</p><p height="1em" width="0pt">__GNU_EH_FRAME_HDR</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">107]</p><p height="1em" width="0pt">_GLOBAL_OFFSET_TABLE_</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">11д]</p><p height="1em" width="0pt">__libc_csu_fini</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">12д]</p><p height="1em" width="0pt">_ITM_deregisterTMCloneTable</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">149]</p><p height="1em" width="0pt">Дж</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">14б]</p><p height="1em" width="0pt">_edata</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">152]</p><p height="1em" width="0pt">__libc_start_main@@GLIBC_2.2.5</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">171]</p><p height="1em" width="0pt">__data_start</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">17д]</p><p height="1em" width="0pt">__gmon_start__</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">18д]</p><p height="1em" width="0pt">__dso_handle</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">19а]</p><p height="1em" width="0pt">_IO_stdin_used</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1а9]</p><p height="1em" width="0pt">__libc_csu_init</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1b9]</p><p height="1em" width="0pt">__bss_start</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1с5]</p><p height="1em" width="0pt"><b>основной</b></p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1ca]</p><p height="1em" width="0pt">_Jv_RegisterClasses</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1де]</p><p height="1em" width="0pt">__TMC_END__</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">1 шт.]</p><p height="1em" width="0pt">_ITM_registerTMCloneTable</p><p height="1em" width="0pt"> <i><b>ХЭШ</b></i>содержит хэш-таблицу символов, которая поддерживает доступ к таблице символов.</p><p height="1em" width="0pt"> <i><b>ДИНАМИЧЕСКИЙ</b></i>содержит информацию для динамической компоновки.</p><p height="1em" width="0pt"> <i><b>НОБИТЫ</b></i>похож на PROGBITS, но не занимает места.</p><p height="1em" width="0pt"><b>Пример 5.4.11.</b>Раздел .bss содержит неинициализированные данные, что означает</p><p height="1em" width="0pt">134</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">байты в секции могут иметь любое значение. Пока операционная система не загрузит раздел в оперативную память, нет необходимости выделять место для бинарного образа на диске, чтобы уменьшить размер бинарного файла. Вот подробности .bss из выходных данных примера:<b>Выход</b></p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">EntSize</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Связь</p><p height="1em" width="0pt">Информация</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">[26] .bss</p><p height="1em" width="0pt">НОБИТЫ</p><p height="1em" width="0pt">0000000000601038</p><p height="1em" width="0pt">00001038</p><p height="1em" width="0pt">0000000000000008</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[27] .комментарий</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0000000000000000</p><p height="1em" width="0pt">00001038</p><p height="1em" width="0pt">0000000000000034</p><p height="1em" width="0pt">0000000000000001</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">В приведенном выше выводе размер раздела составляет всего 8 байт, а смещения обоих разделов одинаковы, что означает, что .bss не использует ни байта исполняемого двоичного файла на диске.</p><p height="1em" width="0pt">Обратите внимание, что раздел .comment не имеет начального адреса. Это означает, что этот раздел отбрасывается, когда исполняемый двоичный файл загружается в память.</p><p height="1em" width="0pt"> <i><b>ОТНОС</b></i>содержит записи о перемещении без явных дополнений. Этот тип будет подробно объяснен в<a href="#filepos637501">8.1</a></p><p height="1em" width="0pt"> <i><b>РЕЛА</b></i>содержит записи о перемещении с явными дополнениями. Этот тип будет подробно объяснен в<a href="#filepos637501">8.1</a></p><p height="1em" width="0pt"> <i><b>INIT_ARRAY</b></i>представляет собой массив указателей на функции для инициализации программы.</p><p height="1em" width="0pt">Когда прикладная программа запускается, прежде чем перейти к main(), сначала выполняется код инициализации в .init и этом разделе. Первый элемент в этом массиве — указатель игнорируемой функции.</p><p height="1em" width="0pt">Это может не иметь смысла, когда мы можем включить код инициализации в функцию main(). Однако для общих объектных файлов, в которых нет функции main(), этот раздел гарантирует, что код инициализации из объектного файла будет выполняться перед любым другим кодом, чтобы обеспечить правильную среду для правильного выполнения основного кода. Это также делает объектный файл более модульным, так как основной код приложения не должен отвечать за инициализацию надлежащей среды для использования конкретного объектного файла, а сам объектный файл. Такое четкое разделение делает код чище.</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">135</p><p height="1em" width="0pt">Однако мы не будем использовать какие-либо разделы .init и INIT_ARRAY в нашей операционной системе для простоты, поскольку инициализация среды является частью домена операционной системы.</p><p height="1em" width="0pt"><b>Пример 5.4.12.</b>Чтобы использовать INIT_ARRAY, мы просто помечаем функцию конструктором атрибутов:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt">__атрибут__((конструктор))<b>статическая пустота</b>инициализация1 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">__атрибут__((конструктор))<b>статическая пустота</b>инициализация2 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("привет␣мир\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Программа автоматически вызывает конструктор, не вызывая его явно:</p><p height="1em" width="0pt">$ gcc -m32 привет.c -о привет</p><p height="1em" width="0pt">$ ./привет</p><p height="1em" width="0pt">init1</p><p height="1em" width="0pt">init2</p><p height="1em" width="0pt">Привет, мир</p><p height="1em" width="0pt"><b>Пример 5.4.13.</b>При желании конструктору можно назначить приоритет от 101 и выше. Приоритеты от 0 до 100 зарезервированы</p><p height="1em" width="0pt">136</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">для gcc. Если мы хотим, чтобы init2 запускался раньше, чем init1, мы даем ему более высокий приоритет:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt">__атрибут__((конструктор(102)))<b>статическая пустота</b>инициализация1 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">__атрибут__((конструктор(101)))<b>статическая пустота</b>инициализация2 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("привет␣мир\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Порядок вызова должен быть точно таким, как указано:</p><p height="1em" width="0pt">$ gcc -m32 привет.c -о привет</p><p height="1em" width="0pt">$ ./привет</p><p height="1em" width="0pt">init2</p><p height="1em" width="0pt">init1</p><p height="1em" width="0pt">Привет, мир</p><p height="1em" width="0pt"><b>Пример 5.4.14.</b>Мы можем добавить функции инициализации, используя другой метод:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">137</p><p height="1em" width="0pt"><b>пустота</b>инициализация1 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>пустота</b>инициализация2() {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"> <i>/* Без typedef init является определением функции</i> <i>указатель.</i></p><p height="1em" width="0pt"> <i>С typedef init является объявлением типа.*/</i></p><p height="1em" width="0pt"><b>недействительным</b>(*в этом)();</p><p height="1em" width="0pt">__attribute__((section(".init_array"))) init init_arr[2]</p><p height="1em" width="0pt">= {инициализация1, инициализация2};</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("привет␣мир!\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Раздел атрибутов («...») помещает функцию в определенный раздел, а не в .text по умолчанию. В данном примере это .init_array.</p><p height="1em" width="0pt">Имя раздела не обязательно совпадает со стандартным заголовком в файле ELF (например, .text или .init_array, но может быть любым.</p><p height="1em" width="0pt">Нестандартные имена разделов часто используются для управления окончательным двоичным макетом скомпилированной программы. Мы рассмотрим эту технику более подробно при изучении компоновщика GNU ld и процесса компоновки. Опять же, программа автоматически вызывает конструкторы, не вызывая их явно:</p><p height="1em" width="0pt">138</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">$ gcc -m32 привет.c -о привет</p><p height="1em" width="0pt">$ ./привет</p><p height="1em" width="0pt">init1</p><p height="1em" width="0pt">init2</p><p height="1em" width="0pt">Привет, мир!</p><p height="1em" width="0pt"> <i><b>FINI_ARRAY</b></i>представляет собой массив указателей на функции для завершения программы, вызываемые после выхода из main(). Если приложение аварийно завершает работу, например, из-за вызова abort() или сбоя, .finit_array игнорируется.</p><p height="1em" width="0pt"><b>Пример 5.4.15.</b>Деструктор автоматически вызывается после выхода из main(), если один или несколько доступны:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt">__атрибут__((деструктор))<b>статическая пустота</b>деструктор () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("привет␣мир\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">$ gcc -m32 привет.c -о привет</p><p height="1em" width="0pt">$ ./привет</p><p height="1em" width="0pt">Привет, мир</p><p height="1em" width="0pt">деструктор</p><p height="1em" width="0pt"> <i><b>PREINIT_ARRAY</b></i>представляет собой массив указателей на функции, которые вызываются перед всеми другими функциями инициализации в INIT_ARRAY.</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">139</p><p height="1em" width="0pt"><b>Пример 5.4.16.</b>Чтобы использовать .preinit_array, единственный способ поместить функции в этот раздел — использовать атрибут section(): hello.c</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>пустота</b>preinit1 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>пустота</b>преинит2 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>пустота</b>инициализация1 () {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>пустота</b>инициализация2() {</p><p height="1em" width="0pt">printf("%s\n", __FUNCTION__);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>недействительным</b>(*предварительно)();</p><p height="1em" width="0pt"><b>недействительным</b>(*в этом)();</p><p height="1em" width="0pt">__attribute__((section(".preinit_array"))) preinit preinit_arr[2] = {preinit1, preinit2};</p><p height="1em" width="0pt">__attribute__((section(".preinit_array"))) init init_arr</p><p height="1em" width="0pt">[2] = {инициализация1, инициализация2};</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("привет␣мир!\n");</p><p height="1em" width="0pt">140</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">$ gcc -m32 привет2.с -о привет2</p><p height="1em" width="0pt">$ ./привет2</p><p height="1em" width="0pt">preinit1</p><p height="1em" width="0pt">preinit2</p><p height="1em" width="0pt">init1</p><p height="1em" width="0pt">init2</p><p height="1em" width="0pt">Привет, мир!</p><p height="1em" width="0pt"> <i><b>ГРУППА</b></i>определяет группу разделов, которая является одним и тем же разделом, который появляется в разных объектных файлах, но при объединении в окончательный исполняемый двоичный файл сохраняется только одна копия, а остальные в других объектных файлах отбрасываются. Этот раздел относится только к объектным файлам C++, поэтому мы не будем рассматривать его дальше.</p><p height="1em" width="0pt"> <i><b>SYMTAB_SHNDX</b></i>это раздел, содержащий расширенные индексы разделов, связанные с таблицей символов. Этот раздел появляется только тогда, когда значение Ndx записи в таблице символов превышает значение LORESERVE.</p><p height="1em" width="0pt">Затем этот раздел сопоставляется между символом и фактическим значением индекса заголовка раздела.</p><p height="1em" width="0pt">Поняв типы разделов, мы можем понять число в полях «Ссылка» и «Информация»:</p><p height="1em" width="0pt"><b>Упражнение 5.4.1.</b>Убедитесь, что значение поля Link раздела SYMTAB является индексом раздела STRTAB.</p><p height="1em" width="0pt"><b>Упражнение 5.4.2.</b>Убедитесь, что значение поля «Информация» раздела SYMTAB равно индексу последнего локального символа + 1. Это означает, что в таблице символов, начиная с индекса, указанного в поле «Информация», локальный символ не появляется.</p><p height="1em" width="0pt"><b>Упражнение 5.4.3.</b>Убедитесь, что значение поля Info раздела REL является индексом раздела SYMTAB.</p><p height="1em" width="0pt"><b>Упражнение 5.4.4.</b>Убедитесь, что значение поля Link раздела REL является индексом раздела, в котором применяется перемещение. Например. если раздел — .rel.text, то перемещаемый раздел должен быть .text.</p><a id="filepos444786" /><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">141</p><p height="1em" width="0pt"><b>Тип</b></p><p height="1em" width="0pt"><b>Связь</b></p><p height="1em" width="0pt"><b>Информация</b></p><p height="1em" width="0pt">ДИНАМИЧЕСКИЙ</p><p height="1em" width="0pt">Записи в этом разделе используют раздел</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">индекс таблицы динамических строк.</p><p height="1em" width="0pt">ХЭШ</p><p height="1em" width="0pt">Индекс раздела таблицы символов</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">GNU_HASH</p><p height="1em" width="0pt">к которому относится хеш-таблица.</p><p height="1em" width="0pt">ОТНОС</p><p height="1em" width="0pt">Индекс раздела связанного</p><p height="1em" width="0pt">Индекс раздела, к которому</p><p height="1em" width="0pt">РЕЛА</p><p height="1em" width="0pt">таблица символов.</p><p height="1em" width="0pt">применяется переселение.</p><p height="1em" width="0pt">СИМТАБ</p><p height="1em" width="0pt">Индекс раздела связанного</p><p height="1em" width="0pt">На единицу больше, чем таблица символов</p><p height="1em" width="0pt">ДИНСИМ</p><p height="1em" width="0pt">строковая таблица.</p><p height="1em" width="0pt">индекс последнего локального символа.</p><p height="1em" width="0pt">ГРУППА</p><p height="1em" width="0pt">Индекс раздела связанного</p><p height="1em" width="0pt">Индекс символа записи в</p><p height="1em" width="0pt">таблица символов.</p><p height="1em" width="0pt">связанная таблица символов. Имя</p><p height="1em" width="0pt">указанная запись таблицы символов</p><p height="1em" width="0pt">обеспечивает подпись для раздела</p><p height="1em" width="0pt">группа.</p><p height="1em" width="0pt">SYMTAB_SHNDX</p><p height="1em" width="0pt">Индекс заголовка раздела</p><p height="1em" width="0pt">связанная таблица символов.</p><p height="1em" width="0pt"><b>Таблица 5.4.3:</b>Значения</p><p height="1em" width="0pt">из</p><p height="1em" width="0pt"> <i><b>Связь</b></i>и</p><p height="1em" width="0pt"> <i><b>Информация</b></i>зависит от</p><p height="1em" width="0pt"><b>5,5</b></p><p height="1em" width="0pt"><b>Таблица заголовка программы</b></p><p height="1em" width="0pt">типы секций. интерпретация</p><p height="1em" width="0pt">А<i>таблица заголовка программы</i>представляет собой массив заголовков программы, который определяет структуру памяти программы во время выполнения.</p><p height="1em" width="0pt">А<i>заголовок программы</i>представляет собой описание сегмента программы.</p><p height="1em" width="0pt">А<i>программный сегмент</i>представляет собой набор связанных разделов. Сегмент содержит ноль или более разделов. Операционная система при загрузке программы,<i>использовать только сегменты</i>, а не разделы. Чтобы просмотреть информацию таблицы заголовков программы, мы используем опцию -l с readelf: $ readelf -l <binary file></p><p height="1em" width="0pt">Как и раздел, заголовок программы также имеет типы:<i>ФДР</i>задает расположение и размер самой таблицы заголовков программы, как в файле, так и в образе памяти программы<i>ИНТЕРП</i>указывает расположение и размер имени пути с завершающим нулем для вызова в качестве интерпретатора для связывания библиотек времени выполнения.</p><p height="1em" width="0pt"> <i>НАГРУЗКА</i>указывает загружаемый сегмент. То есть этот сегмент загружается в основную память.</p><p height="1em" width="0pt">142</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>ДИНАМИЧЕСКИЙ</i>задает информацию о динамической компоновке.</p><p height="1em" width="0pt"> <i>ПРИМЕЧАНИЕ</i>определяет расположение и размер вспомогательной информации.</p><p height="1em" width="0pt"> <i>TLS</i>указывает<i>Шаблон Thread-Local Storage</i>, который формируется из объединения всех разделов с флагом TLS.</p><p height="1em" width="0pt"> <i>GNU_STACK</i>указывает, следует ли сделать стек программы исполняемым или нет. Ядро Linux использует этот тип.</p><p height="1em" width="0pt"><b>Таблица 5.5.1:</b>Разрешение сегмента</p><p height="1em" width="0pt"><b>Разрешение</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">Сегмент также имеет разрешение, которое представляет собой комбинацию этих 3 значений: R</p><p height="1em" width="0pt">Удобочитаемый</p><p height="1em" width="0pt">Вт</p><p height="1em" width="0pt">Доступно для записи</p><p height="1em" width="0pt">Читать (клавиша R)</p><p height="1em" width="0pt">Е</p><p height="1em" width="0pt">Исполняемый</p><p height="1em" width="0pt">Напиши (ж)</p><p height="1em" width="0pt">Выполнить (Е)</p><p height="1em" width="0pt"><b>Пример 5.5.1.</b>Команда для получения таблицы заголовков программы: $ readelf -l hello</p><p height="1em" width="0pt">Выход:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x400430</p><p height="1em" width="0pt">Имеется 9 заголовков программ, начиная со смещения 64.</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">Размер файла</p><p height="1em" width="0pt">МемСиз</p><p height="1em" width="0pt">Флаги</p><p height="1em" width="0pt">Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x0000000000000040 0x0000000000400040 0x0000000000400040</p><p height="1em" width="0pt">0x00000000000001f8 0x00000000000001f8</p><p height="1em" width="0pt">Р Е</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">ИНТЕРП</p><p height="1em" width="0pt">0x0000000000000238 0x0000000000400238 0x0000000000400238</p><p height="1em" width="0pt">0x000000000000001c 0x000000000000001c</p><p height="1em" width="0pt">р</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[Запрос интерпретатора программы: /lib64/ld-linux-x86-64.so.2]</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x0000000000000000 0x0000000000400000 0x0000000000400000</p><p height="1em" width="0pt">0x000000000000070c 0x000000000000070c</p><p height="1em" width="0pt">Р Е</p><p height="1em" width="0pt">200000</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">143</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x0000000000000e10 0x00000000000600e10 0x0000000000600e10</p><p height="1em" width="0pt">0x0000000000000228 0x0000000000000230</p><p height="1em" width="0pt">RW</p><p height="1em" width="0pt">200000</p><p height="1em" width="0pt">ДИНАМИЧЕСКИЙ</p><p height="1em" width="0pt">0x0000000000000e28 0x0000000000600e28 0x0000000000600e28</p><p height="1em" width="0pt">0x00000000000001d0 0x00000000000001d0</p><p height="1em" width="0pt">RW</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">0x0000000000000254 0x0000000000400254 0x0000000000400254</p><p height="1em" width="0pt">0x0000000000000044 0x0000000000000044</p><p height="1em" width="0pt">р</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">GNU_EH_FRAME</p><p height="1em" width="0pt">0x00000000000005e4 0x00000000004005e4 0x00000000004005e4</p><p height="1em" width="0pt">0x0000000000000034 0x0000000000000034</p><p height="1em" width="0pt">р</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">GNU_STACK</p><p height="1em" width="0pt">0x0000000000000000 0x00000000000000000 0x00000000000000000</p><p height="1em" width="0pt">0x0000000000000000 0x00000000000000000</p><p height="1em" width="0pt">RW</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">GNU_RELRO</p><p height="1em" width="0pt">0x0000000000000e10 0x00000000000600e10 0x0000000000600e10</p><p height="1em" width="0pt">0x00000000000001f0 0x00000000000001f0</p><p height="1em" width="0pt">р</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.интерп</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">.interp .note.ABI-тег .note.gnu.build-id .gnu.hash .dynsym .dynstr</p><p height="1em" width="0pt">.gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini</p><p height="1em" width="0pt">.rodata .eh_frame_hdr .eh_frame</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">.init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04</p><p height="1em" width="0pt">.динамический</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">.note.ABI-тег .note.gnu.build-id</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">.eh_frame_hdr</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">.init_array .fini_array .jcr .dynamic .got</p><p height="1em" width="0pt">В примере выходных данных сегмент LOAD появляется дважды:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x0000000000000000 0x0000000000400000 0x0000000000400000</p><p height="1em" width="0pt">0x000000000000070c 0x000000000000070c</p><p height="1em" width="0pt">Р Е</p><p height="1em" width="0pt">200000</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x0000000000000e10 0x00000000000600e10 0x0000000000600e10</p><p height="1em" width="0pt">0x0000000000000228 0x0000000000000230</p><p height="1em" width="0pt">RW</p><p height="1em" width="0pt">200000</p><p height="1em" width="0pt">Почему? Обратите внимание на разрешение:</p><p height="1em" width="0pt">верхний LOAD имеет разрешение на чтение и выполнение. Это<i>текст</i>сегмент-</p><a id="filepos454498" /><p height="1em" width="0pt">144</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">мент. Текстовый сегмент содержит инструкции только для чтения и данные только для чтения.</p><p height="1em" width="0pt">нижний LOAD имеет разрешение на чтение и запись. Это<i>данные</i>сегмент.</p><p height="1em" width="0pt">Это означает, что этот сегмент можно читать и записывать, но его нельзя использовать в качестве исполняемого кода по соображениям безопасности.</p><p height="1em" width="0pt">Затем LOAD содержит следующие разделы:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">.interp .note.ABI-тег .note.gnu.build-id .gnu.hash .dynsym .dynstr</p><p height="1em" width="0pt">.gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini</p><p height="1em" width="0pt">.rodata .eh_frame_hdr .eh_frame</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">.init_array .fini_array .jcr .dynamic .got .got.plt .data .bss Первое число — это индекс заголовка программы в таблице заголовков программ, а оставшийся текст — это список всех разделов в сегменте.</p><p height="1em" width="0pt">К сожалению, readelf не печатает индекс, поэтому пользователю необходимо вручную отслеживать, какой сегмент относится к какому индексу. Первый сегмент начинается с индекса 0, второй — с индекса 1 и так далее. LOAD — это сегменты с индексами 2 и 3. Как видно из двух списков разделов, большинство разделов являются загружаемыми и доступны во время выполнения.</p><p height="1em" width="0pt"><b>5.6</b></p><p height="1em" width="0pt"><b>Сегменты и разделы</b></p><p height="1em" width="0pt">Как упоминалось ранее, операционная система загружает сегменты программы, а не разделы. Однако возникает вопрос: почему операционная система вместо этого не использует разделы? В конце концов, раздел также содержит информацию, аналогичную сегменту программы, такую ​​как тип, адрес виртуальной памяти для загрузки, размер, атрибуты, флаги и выравнивание. Как объяснялось ранее, сегмент — это перспектива операционной системы, а секция — это перспектива компоновщика. Чтобы понять почему, заглянув в структуру сегмента, мы легко увидим:</p><p height="1em" width="0pt">Сегмент представляет собой набор разделов. Это означает, что разделы логически сгруппированы по своим атрибутам. Например, все разделы</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">145</p><p height="1em" width="0pt">в сегменте LOAD всегда загружаются операционной системой; все разделы имеют одинаковое разрешение: либо RE (Чтение + Выполнение) для исполняемых разделов, либо RW (Чтение + Запись) для разделов данных.</p><p height="1em" width="0pt">Группируя разделы в сегменты, операционной системе проще загружать разделы только один раз, загружая начало и конец сегмента, а не раздел за разделом.</p><p height="1em" width="0pt">Поскольку сегмент предназначен для загрузки программы, а раздел — для связывания программы, все разделы в сегменте<i>в пределах его начального и конечного адресов виртуальной памяти сегмента</i>.</p><p height="1em" width="0pt">Чтобы яснее понять последний пункт, рассмотрим пример связывания двух объектных файлов. Предположим, у нас есть два исходных файла:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("Привет, мир\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">и:</p><p height="1em" width="0pt">math.c</p><p height="1em" width="0pt"><b>инт</b>добавлять(<b>инт</b>а,<b>инт</b>б) {</p><p height="1em" width="0pt"><b>возвращаться</b>а + б;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Теперь скомпилируйте два исходных файла как<i>объектные файлы</i>: $ gcc -m32 -c math.c</p><p height="1em" width="0pt">$ gcc -m32 -c привет.с</p><p height="1em" width="0pt">Затем мы проверяем разделы math.o:</p><p height="1em" width="0pt">146</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">$ readelf -S math.o</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Имеется 11 заголовков разделов, начиная со смещения 0x1a8: Заголовки разделов:</p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Выключенный</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">ES Flg Lk Inf Al</p><p height="1em" width="0pt">[ 0]</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">00000000 000000 000000 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">[ 1] .текст</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000034 00000d 00</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 2] .данные</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000041 000000 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 3] .bss</p><p height="1em" width="0pt">НОБИТЫ</p><p height="1em" width="0pt">00000000 000041 000000 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 4 ] .комментарий</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000041 000035 01</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 5] .note.GNU-стек</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000076 000000 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 6] .eh_frame</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000078 000038 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 7] .rel.eh_frame</p><p height="1em" width="0pt">ОТНОС</p><p height="1em" width="0pt">00000000 00014c 000008 08</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[8] .shstrtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 000154 000053 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 9 ] .симтаб</p><p height="1em" width="0pt">СИМТАБ</p><p height="1em" width="0pt">00000000 0000b0 000090 10</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[10] .strtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 000140 00000c 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Ключ к флагам:</p><p height="1em" width="0pt">W (запись), A (распределение), X (выполнение), M (объединение), S (строки), I (информация), L (порядок ссылок), G (группа), T (TLS), E (исключение), x (неизвестно) O (требуется дополнительная обработка ОС) o (зависит от ОС), p (зависит от процессора) Как показано в выходных данных, адреса виртуальной памяти всех разделов каждого раздела устанавливаются равными 0. На этом этапе каждый объектный файл просто<i>блокировать</i> <i>бинарного</i>который содержит код и данные. Его существование должно служить в качестве материального контейнера для конечного продукта, который является исполняемым двоичным файлом. Таким образом, все виртуальные адреса в hello.o нулевые.</p><p height="1em" width="0pt">На данном этапе сегмент не существует:</p><p height="1em" width="0pt">$ readelf -l math.o</p><p height="1em" width="0pt">В этом файле нет заголовков программ.</p><p height="1em" width="0pt">То же самое происходит с другим объектным файлом:</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">147</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Имеется 13 заголовков разделов, начиная со смещения 0x224: Заголовки разделов:</p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Выключенный</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">ES Flg Lk Inf Al</p><p height="1em" width="0pt">[ 0]</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">00000000 000000 000000 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">[ 1] .текст</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000034 00002e 00</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 2] .отн.текст</p><p height="1em" width="0pt">ОТНОС</p><p height="1em" width="0pt">00000000 0001ac 000010 08</p><p height="1em" width="0pt">я 11</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 3] .данные</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000062 000000 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 4 ] .bss</p><p height="1em" width="0pt">НОБИТЫ</p><p height="1em" width="0pt">00000000 000062 000000 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 5 ] .родата</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 000062 00000c 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 6] .комментарий</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 00006e 000035 01</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 7] .note.GNU-стек</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 0000a3 000000 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[8] .eh_frame</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 0000a4 000044 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 9] .rel.eh_frame</p><p height="1em" width="0pt">ОТНОС</p><p height="1em" width="0pt">00000000 0001bc 000008 08</p><p height="1em" width="0pt">я 11</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[10] .shstrtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 0001c4 00005f 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[11] .симтаб</p><p height="1em" width="0pt">СИМТАБ</p><p height="1em" width="0pt">00000000 0000e8 0000b0 10</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[12] .strtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 000198 000013 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Ключ к флагам:</p><p height="1em" width="0pt">W (запись), A (распределение), X (выполнение), M (объединение), S (строки), I (информация), L (порядок ссылок), G (группа), T (TLS), E (исключение), x (неизвестно) O (требуется дополнительная обработка ОС) o (зависит от ОС), p (зависит от процессора) $ readelf -l hello.o</p><p height="1em" width="0pt">В этом файле нет заголовков программ.</p><p height="1em" width="0pt">Только когда объектные файлы объединяются в окончательный исполняемый двоичный файл, секции реализуются полностью:</p><p height="1em" width="0pt">$ gcc -m32 math.o привет.o -o привет</p><p height="1em" width="0pt">$ readelf -S привет.</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Имеется 31 заголовок раздела, начиная со смещения 0x1804: Заголовки разделов:</p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Выключенный</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">ES Flg Lk Inf Al</p><p height="1em" width="0pt">148</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">[ 0]</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">00000000 000000 000000 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">[ 1] .интерп</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">08048154 000154 000013 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 2] .note.ABI-тег</p><p height="1em" width="0pt">ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">08048168 000168 000020 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 3] .note.gnu.build-i ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">08048188 000188 000024 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 4] .gnu.хэш</p><p height="1em" width="0pt">GNU_HASH</p><p height="1em" width="0pt">080481ac 0001ac 000020 04</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 5] .dynsym</p><p height="1em" width="0pt">ДИНСИМ</p><p height="1em" width="0pt">080481cc 0001cc 000050 10</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 6 ] .динстр</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">0804821с 00021с 00004а 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 7] .gnu.версия</p><p height="1em" width="0pt">ВЕРСИМ</p><p height="1em" width="0pt">08048266 000266 00000а 02</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">[8] .gnu.version_r</p><p height="1em" width="0pt">ВЕРНЕЕД</p><p height="1em" width="0pt">08048270 000270 000020 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 9] .отн.дин</p><p height="1em" width="0pt">ОТНОС</p><p height="1em" width="0pt">08048290 000290 000008 08</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[10] .отн.плт</p><p height="1em" width="0pt">ОТНОС</p><p height="1em" width="0pt">08048298 000298 000010 08</p><p height="1em" width="0pt">ИИ</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">24</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[11] .инит</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">080482а8 0002а8 000023 00</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[12] .плт</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">080482d0 0002d0 000030 04</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0 16</p><p height="1em" width="0pt">[13] .plt.гот</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">08048300 000300 000008 00</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">[14] .текст</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">08048310 000310 0001a2 00</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0 16</p><p height="1em" width="0pt">[15] .фини</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">080484b4 0004b4 000014 00</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[16] .родата</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">080484c8 0004c8 000014 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[17] .eh_frame_hdr</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">080484дк 0004дк 000034 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[18] .eh_frame</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">08048510 000510 0000эк 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[19] .init_array</p><p height="1em" width="0pt">INIT_ARRAY</p><p height="1em" width="0pt">08049f08 000f08 000004 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[20] .fini_array</p><p height="1em" width="0pt">FINI_ARRAY</p><p height="1em" width="0pt">08049f0c 000f0c 000004 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[21] .jcr</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">08049f10 000f10 000004 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[22] .динамический</p><p height="1em" width="0pt">ДИНАМИЧЕСКИЙ</p><p height="1em" width="0pt">08049f14 000f14 0000e8 08</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[23] .гот</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">08049ffc 000ffc 000004 04</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[24] .got.plt</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0804a000 001000 000014 04</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[25] .данные</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">0804a014 001014 000008 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[26] .bss</p><p height="1em" width="0pt">НОБИТЫ</p><p height="1em" width="0pt">0804a01c 00101c 000004 00</p><p height="1em" width="0pt">Вашингтон</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[27] .комментарий</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 00101c 000034 01</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[28] .shstrtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 0016f8 00010a 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[29] .симтаб</p><p height="1em" width="0pt">СИМТАБ</p><p height="1em" width="0pt">00000000 001050 000470 10</p><p height="1em" width="0pt">30</p><p height="1em" width="0pt">48</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[30] .strtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 0014c0 000238 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Ключ к флагам:</p><p height="1em" width="0pt">W (запись), A (распределение), X (выполнение), M (объединение), S (строки), I (информация), L (порядок ссылок), G (группа), T (TLS), E (исключение), х (неизвестно)</p><p height="1em" width="0pt">анатомия программы</p><p height="1em" width="0pt">149</p><p height="1em" width="0pt">O (требуется дополнительная обработка ОС) o (зависит от ОС), p (зависит от процессора) Каждому загружаемому разделу назначается адрес, выделенный зеленым цветом. Причина, по которой каждый раздел получил свой собственный адрес, заключается в том, что на самом деле gcc<i>не</i> <i>объединить объект сам по себе, но вызывает компоновщик</i>лд. Компоновщик ld использует сценарий по умолчанию, который он может найти в системе, для создания исполняемого двоичного файла. В сценарии по умолчанию сегменту назначается начальный адрес 0x8048000.</p><p height="1em" width="0pt">и разделы принадлежат ему. Затем:</p><p height="1em" width="0pt">Адрес 1-го раздела = адрес начального сегмента + смещение раздела = 0x8048000 + 0x154 = 0x08048154</p><p height="1em" width="0pt">Адрес 2-го раздела = адрес начального сегмента + смещение раздела = 0x8048000 + 0x168 = 0x08048168</p><p height="1em" width="0pt">и так до последнего загружаемого раздела.</p><p height="1em" width="0pt">Действительно, конечный адрес сегмента является также конечным адресом конечной секции. Мы можем увидеть это, перечислив все сегменты: $ readelf -l hello</p><p height="1em" width="0pt">И проверьте, например, сегмент LOAD, который начинается с 0x08048000 и заканчивается на 0x08048000 + 0x005fc = 0x080485fc:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x8048310</p><p height="1em" width="0pt">Имеется 9 заголовков программ, начиная со смещения 52.</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000034 0x08048034 0x08048034 0x00120 0x00120 Ч Е 0x4</p><p height="1em" width="0pt">ИНТЕРП</p><p height="1em" width="0pt">0x000154 0x08048154 0x08048154 0x00013 0x00013 Ч</p><p height="1em" width="0pt">0x1</p><p height="1em" width="0pt">[Запрос интерпретатора программы: /lib/ld-linux.so.2]</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000000 0x08048000 0x08048000 0x005fc 0x005fc Р Е 0x1000</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000f08 0x08049f08 0x08049f08 0x00114 0x00118 ЧЗ</p><p height="1em" width="0pt">0x1000</p><p height="1em" width="0pt">ДИНАМИЧЕСКИЙ</p><p height="1em" width="0pt">0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 ЧЗ</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">ПРИМЕЧАНИЕ</p><p height="1em" width="0pt">0x000168 0x08048168 0x08048168 0x00044 0x00044 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">GNU_EH_FRAME</p><p height="1em" width="0pt">0x0004dc 0x080484dc 0x080484dc 0x00034 0x00034 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">GNU_STACK</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00000 0x00000 ЧЗ</p><p height="1em" width="0pt">0x10</p><p height="1em" width="0pt">150</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">GNU_RELRO</p><p height="1em" width="0pt">0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 Р</p><p height="1em" width="0pt">0x1</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.интерп</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">.interp .note.ABI-тег .note.gnu.build-id .gnu.hash .dynsym .dynstr</p><p height="1em" width="0pt">.gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini</p><p height="1em" width="0pt">.rodata .eh_frame_hdr .eh_frame</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">.init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04</p><p height="1em" width="0pt">.динамический</p><p height="1em" width="0pt">05</p><p height="1em" width="0pt">.note.ABI-тег .note.gnu.build-id</p><p height="1em" width="0pt">06</p><p height="1em" width="0pt">.eh_frame_hdr</p><p height="1em" width="0pt">07</p><p height="1em" width="0pt">08</p><p height="1em" width="0pt">.init_array .fini_array .jcr .dynamic .got</p><p height="1em" width="0pt">Последний раздел в первом сегменте LOAD — это .eh_frame. Раздел .eh_frame начинается с 0x0804851, поскольку начальный адрес — 0x08048000, смещение в файле — 0x510. Конечный адрес .eh_frame должен быть: 0x08048000 + 0x510 + 0xec = 0x080485fc, поскольку размер сегмента равен 0xec. Это то же самое, что и конечный адрес первого сегмента LOAD выше: 0x08048000 + 0x5ec = 0x080485fc.</p><p height="1em" width="0pt">Глава<a href="#filepos635813">8</a>подробно изучу весь этот процесс.</p><a id="filepos481111" /><p height="1em" width="0pt"><b>6</b></p><p height="1em" width="0pt">Проверка и отладка во время выполнения</p><p height="1em" width="0pt">А<i>отладчик</i>это программа, которая позволяет проверять работающую программу.</p><p height="1em" width="0pt"> <i><b>отладчик</b></i></p><p height="1em" width="0pt">Отладчик может запускать и выполнять программу, а затем останавливаться на определенной строке для проверки состояния программы в этот момент. Точка, в которой отладчик останавливается (но не останавливается), называется<i>точка останова</i>.</p><p height="1em" width="0pt">Мы будем использовать<i><b>ГДБ - Г</b></i><i>НУ</i><i><b>Д</b></i><i>е</i><i><b>б</b></i><i>уггер</i>для отладки нашего ядра.<i>gdb</i>это имя программы.<i>gdb</i>может выполнять четыре основных действия: Запустить программу, указав все, что может повлиять на ее поведение.</p><p height="1em" width="0pt">Сделайте так, чтобы ваша программа останавливалась при определенных условиях.</p><p height="1em" width="0pt">Изучите, что произошло, когда ваша программа остановилась. Измените что-то в своей программе, чтобы вы могли экспериментировать с исправлением последствий одной ошибки и продолжать изучать другую.<b>6.1</b></p><p height="1em" width="0pt"><b>Пример программы</b></p><p height="1em" width="0pt">Должна быть существующая программа для отладки. Для образовательных целей в этой главе достаточно старой доброй программы «Hello World»: hello.c</p><a id="filepos482462" /><p height="1em" width="0pt">152</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Компилируем с отладочной информацией с опцией -g:$gcc -m32 -g hello.c -o hello</p><p height="1em" width="0pt">Наконец, мы запускаем gdb с программой в качестве аргумента:</p><p height="1em" width="0pt">$ gdb привет</p><p height="1em" width="0pt"><b>6.2</b></p><p height="1em" width="0pt"><b>Статическая проверка программы</b></p><p height="1em" width="0pt">Прежде чем проверять программу во время выполнения, gdb сначала загружает ее. При загрузке в память (но без запуска) можно извлечь много полезной информации для проверки. Команды в этом разделе можно использовать до запуска программы. Однако их также можно использовать во время работы программы, и они могут отображать еще больше информации.</p><p height="1em" width="0pt"> <i>6.2.1 Команда: информационная цель/информационный файл/информационные файлы</i></p><p height="1em" width="0pt">Эта команда выводит информацию об отлаживаемой цели. А<i>цель</i>это программа отладки.</p><p height="1em" width="0pt"><b>Пример 6.2.1.</b>Вывод команды из программы hello, локальная цель в деталях:</p><p height="1em" width="0pt">(gdb) информационная цель</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">153</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Символы из "/tmp/hello".</p><p height="1em" width="0pt">Локальный исполняемый файл:</p><p height="1em" width="0pt">‘/tmp/hello’, тип файла elf32-i386.</p><p height="1em" width="0pt">Точка входа: 0x8048310</p><p height="1em" width="0pt">0x08048154 - 0x08048167 — это .interp</p><p height="1em" width="0pt">0x08048168 - 0x08048188 является .note.ABI-тегом</p><p height="1em" width="0pt">0x08048188 - 0x080481ac — это .note.gnu.build-id</p><p height="1em" width="0pt">0x080481ac — 0x080481cc — это .gnu.hash</p><p height="1em" width="0pt">0x080481cc — 0x0804821c — это .dynsym</p><p height="1em" width="0pt">0x0804821c — 0x08048266 — это .dynstr</p><p height="1em" width="0pt">0x08048266 - 0x08048270 — это .gnu.version</p><p height="1em" width="0pt">0x08048270 - 0x08048290 — это .gnu.version_r</p><p height="1em" width="0pt">0x08048290 - 0x08048298 — это .real.syn</p><p height="1em" width="0pt">0x08048298 — 0x080482a8 — это .rel.plt</p><p height="1em" width="0pt">0x080482a8 — 0x080482cb — это .init</p><p height="1em" width="0pt">0x080482d0 — 0x08048300 — это .plt</p><p height="1em" width="0pt">0x08048300 - 0x08048308 — это .plt.got</p><p height="1em" width="0pt">0x08048310 — 0x080484a2 — это .текст</p><p height="1em" width="0pt">0x080484a4 - 0x080484b8 — это .fini</p><p height="1em" width="0pt">0x080484b8 — 0x080484cd — это .rodata</p><p height="1em" width="0pt">0x080484d0 — 0x080484fc — это .eh_frame_hdr</p><p height="1em" width="0pt">0x080484fc — 0x080485c8 — это .eh_frame</p><p height="1em" width="0pt">0x08049f08 — 0x08049f0c — это .init_array</p><p height="1em" width="0pt">0x08049f0c — 0x08049f10 — это .fini_array</p><p height="1em" width="0pt">0x08049f10 — 0x08049f14 — это .jcr</p><p height="1em" width="0pt">0x08049f14 - 0x08049ffc является .динамическим</p><p height="1em" width="0pt">0x08049ffc — 0x0804a000 — это .got</p><p height="1em" width="0pt">0x0804a000 - 0x0804a014 — это .got.plt</p><p height="1em" width="0pt">0x0804a014 - 0x0804a01c — это .данные</p><p height="1em" width="0pt">0x0804a01c — 0x0804a020 — это .bss</p><p height="1em" width="0pt">На выходе отображаются отчеты:</p><p height="1em" width="0pt">Путь к файлу символов. А<i>файл символов</i>файл, содержащий отладочную информацию. Обычно это тот же файл, что и бинарный, но</p><p height="1em" width="0pt">154</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">принято разделять исполняемый двоичный файл и его отладочную информацию на 2 файла, особенно для удаленной отладки. В примере это строка:</p><p height="1em" width="0pt">Символы из "/tmp/hello".</p><p height="1em" width="0pt">Путь к программе отладки и тип ее файла. В примере это строка:</p><p height="1em" width="0pt">Локальный исполняемый файл:</p><p height="1em" width="0pt">‘/tmp/hello’, тип файла elf32-i386.</p><p height="1em" width="0pt">Точка входа в программу отладки. То есть самый первый код, который запускает программа. В примере это строка:</p><p height="1em" width="0pt">Точка входа: 0x8048310</p><p height="1em" width="0pt">Список разделов с начальным и конечным адресами. В примере это оставшийся вывод.</p><p height="1em" width="0pt"><b>Пример 6.2.2.</b>Если программа отладки работает на другом компьютере, это удаленная цель, и gdb выводит только краткую информацию: (gdb) info target</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Удаленная последовательная цель в протоколе, специфичном для gdb:</p><p height="1em" width="0pt">Отладка цели по последовательной линии.</p><p height="1em" width="0pt"> <i>6.2.2 Команда: информационные разделы обслуживания</i></p><p height="1em" width="0pt">Эта команда похожа на info target, но дает дополнительную информацию о разделах программы, в частности, о смещении файла и флагах каждого раздела.</p><p height="1em" width="0pt"><b>Пример 6.2.3.</b>Вот вывод при запуске программы hello:</p><p height="1em" width="0pt">(gdb) основные информационные разделы</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">155</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Исполняемый файл:</p><p height="1em" width="0pt">‘/tmp/hello’, тип файла elf64-x86-64.</p><p height="1em" width="0pt">[0]</p><p height="1em" width="0pt">0x00400238->0x00400254 по адресу 0x00000238: .interp ALLOC LOAD READONLY DATA HAS_CONTENTS</p><p height="1em" width="0pt">[1]</p><p height="1em" width="0pt">0x00400254->0x00400274 по адресу 0x00000254: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS</p><p height="1em" width="0pt">[2]</p><p height="1em" width="0pt">0x00400274->0x00400298 по адресу 0x00000274: .note.gnu.build-id ALLOC ЗАГРУЗИТЬ ДАННЫЕ ТОЛЬКО ДЛЯ ЧТЕНИЯ HAS_CONTENTS</p><p height="1em" width="0pt">[3]</p><p height="1em" width="0pt">0x00400298->0x004002b4 по адресу 0x00000298: .gnu.hash ALLOC ЗАГРУЗИТЬ ДАННЫЕ ТОЛЬКО ДЛЯ ЧТЕНИЯ HAS_CONTENTS</p><p height="1em" width="0pt">[4]</p><p height="1em" width="0pt">0x004002b8->0x00400318 по адресу 0x000002b8: .dynsym ALLOC ALLOC LOAD READONLY DATA HAS_CONTENTS</p><p height="1em" width="0pt">[5]</p><p height="1em" width="0pt">0x00400318->0x00400355 по адресу 0x00000318: .dynstr ALLOC ALLOC LOAD READONLY DATA HAS_CONTENTS</p><p height="1em" width="0pt">[6]</p><p height="1em" width="0pt">0x00400356->0x0040035e по адресу 0x00000356: .gnu.version ALLOC ЗАГРУЗИТЬ ДАННЫЕ ТОЛЬКО ДЛЯ ЧТЕНИЯ HAS_CONTENTS</p><p height="1em" width="0pt">[7]</p><p height="1em" width="0pt">0x00400360->0x00400380 по адресу 0x00000360: .gnu.version_r ALLOC ЗАГРУЗИТЬ ДАННЫЕ ТОЛЬКО ДЛЯ ЧТЕНИЯ HAS_CONTENTS</p><p height="1em" width="0pt">....остальный вывод опущен....</p><p height="1em" width="0pt">Вывод аналогичен информационной цели, но с более подробной информацией. Рядом с именами разделов находятся флаги разделов, которые являются атрибутами раздела.</p><p height="1em" width="0pt">Здесь мы видим, что разделы с флагом LOAD относятся к сегменту LOAD.</p><p height="1em" width="0pt">Команду можно комбинировать с флагами раздела для отфильтрованных выходов:<i>АЛЛОБЖ</i>отображает разделы для всех загруженных объектных файлов, включая разделяемые библиотеки. Общие библиотеки отображаются только тогда, когда программа уже запущена.</p><p height="1em" width="0pt"> <i>имена разделов</i>отображает только именованные разделы.</p><p height="1em" width="0pt"><b>Пример 6.2.4.</b>Команда:</p><p height="1em" width="0pt">(gdb) maint информационные разделы .text .data .bss</p><p height="1em" width="0pt">отображает только разделы .text, .data и .bss:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Исполняемый файл:</p><p height="1em" width="0pt">‘/tmp/hello’, тип файла elf64-x86-64.</p><p height="1em" width="0pt">[13]</p><p height="1em" width="0pt">0x00400430->0x004005c2 по адресу 0x00000430: .text ALLOC LOAD READONLY CODE HAS_CONTENTS</p><p height="1em" width="0pt">[24]</p><p height="1em" width="0pt">0x00601028->0x00601038 по адресу 0x00001028: .data ALLOC LOAD DATA HAS_CONTENTS</p><p height="1em" width="0pt">[25]</p><p height="1em" width="0pt">0x00601038 -> 0x00601040 по адресу 0x00001038: .bss ALLOC</p><p height="1em" width="0pt"> <i>раздел-флаги</i>отображает только разделы с указанными флагами разделов. Обратите внимание, что эти флаги раздела специфичны для gdb, хотя он основан на атрибутах раздела, определенных ранее. В настоящее время gdb понимает следующие флаги:</p><p height="1em" width="0pt">156</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>ALLOC</i>Раздел будет иметь место, выделенное в процессе при загрузке.</p><p height="1em" width="0pt">Установить для всех разделов, кроме тех, которые содержат отладочную информацию.</p><p height="1em" width="0pt"> <i>НАГРУЗКА</i>Секция будет загружена из файла в память дочернего процесса. Установить для предварительно инициализированного кода и данных, очистить для разделов .bss.</p><p height="1em" width="0pt"> <i>РЕЛОК</i>Раздел необходимо переместить перед загрузкой.</p><p height="1em" width="0pt"> <i>ТОЛЬКО ДЛЯ ЧТЕНИЯ</i>Раздел не может быть изменен дочерним процессом.</p><p height="1em" width="0pt"> <i>КОД</i>Раздел содержит только исполняемый код.</p><p height="1em" width="0pt"> <i>ДАННЫЕ</i>Раздел содержит только данные (без исполняемого кода).</p><p height="1em" width="0pt"> <i>ПЗУ</i>Раздел будет находиться в ПЗУ.</p><p height="1em" width="0pt"> <i>КОНСТРУКТОР</i>Секция содержит данные для списков конструкторов/деструкторов.</p><p height="1em" width="0pt"> <i>HAS_CONTENTS</i>Раздел не пуст.</p><p height="1em" width="0pt"> <i>НИКОГДА_ЗАГРУЗИТЬ</i>Указание компоновщику не выводить секцию.</p><p height="1em" width="0pt"> <i>COFF_SHARED_LIBRARY</i>Уведомление компоновщика о том, что раздел содержит информацию о совместно используемой библиотеке COFF. COFF — это формат объектных файлов, похожий на ELF. В то время как ELF — это формат файла для исполняемого двоичного файла, COFF — это формат файла для объектного файла.</p><p height="1em" width="0pt"> <i>IS_COMMON</i>Раздел содержит общие символы.</p><p height="1em" width="0pt"><b>Пример 6.2.5.</b>Мы можем ограничить вывод только отображением разделов, содержащих код, с помощью команды:</p><p height="1em" width="0pt">(gdb) maint информационные разделы CODE</p><p height="1em" width="0pt">Выход:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Исполняемый файл:</p><p height="1em" width="0pt">‘/tmp/hello’, тип файла elf64-x86-64.</p><p height="1em" width="0pt">[10]</p><p height="1em" width="0pt">0x004003c8->0x004003e2 по адресу 0x000003c8: .init ALLOC LOAD READONLY CODE HAS_CONTENTS</p><p height="1em" width="0pt">[11]</p><p height="1em" width="0pt">0x004003f0->0x00400420 по адресу 0x000003f0: .plt ALLOC LOAD READONLY CODE HAS_CONTENTS</p><p height="1em" width="0pt">[12]</p><p height="1em" width="0pt">0x00400420->0x00400428 по адресу 0x00000420: .plt.got ALLOC LOAD READONLY CODE HAS_CONTENTS</p><p height="1em" width="0pt">[13]</p><p height="1em" width="0pt">0x00400430->0x004005c2 по адресу 0x00000430: .text ALLOC LOAD READONLY CODE HAS_CONTENTS</p><p height="1em" width="0pt">[14]</p><p height="1em" width="0pt">0x004005c4->0x004005cd по адресу 0x000005c4: .fini ALLOC LOAD READONLY CODE HAS_CONTENTS</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">157</p><p height="1em" width="0pt"> <i>6.2.3 Команда: информационные функции</i></p><p height="1em" width="0pt">Эти команды перечисляют все имена функций и их загруженные адреса. Имена можно фильтровать с помощью регулярного выражения.</p><p height="1em" width="0pt"><b>Пример 6.2.6.</b>Запустив команду, мы получим следующий вывод: (gdb) info functions</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Все определенные функции:</p><p height="1em" width="0pt">Файл hello.c:</p><p height="1em" width="0pt">int main(int, char **);</p><p height="1em" width="0pt">Неотладочные символы:</p><p height="1em" width="0pt">0x00000000004003c8</p><p height="1em" width="0pt">_в этом</p><p height="1em" width="0pt">0x0000000000400400</p><p height="1em" width="0pt">ставит@plt</p><p height="1em" width="0pt">0x0000000000400410</p><p height="1em" width="0pt">__libc_start_main@plt</p><p height="1em" width="0pt">0x0000000000400430</p><p height="1em" width="0pt">_начинать</p><p height="1em" width="0pt">0x0000000000400460</p><p height="1em" width="0pt">отменить регистрацию_tm_clones</p><p height="1em" width="0pt">0x00000000004004a0</p><p height="1em" width="0pt">register_tm_clones</p><p height="1em" width="0pt">0x00000000004004e0</p><p height="1em" width="0pt">__do_global_dtors_aux</p><p height="1em" width="0pt">0x0000000000400500</p><p height="1em" width="0pt">кадр_манекен</p><p height="1em" width="0pt">0x0000000000400550</p><p height="1em" width="0pt">__libc_csu_init</p><p height="1em" width="0pt">0x00000000004005c0</p><p height="1em" width="0pt">__libc_csu_fini</p><p height="1em" width="0pt">0x00000000004005c4</p><p height="1em" width="0pt">_фини</p><p height="1em" width="0pt"> <i>6.2.4 Команда: информационные переменные</i></p><p height="1em" width="0pt">Эта команда выводит список всех имен глобальных и статических переменных или отфильтровывает их с помощью регулярного выражения.</p><p height="1em" width="0pt"><b>Пример 6.2.7.</b>Если мы добавим глобальную переменную int i в образец исходной программы и перекомпилируем, а затем запустим команду, мы получим следующий вывод:</p><p height="1em" width="0pt">(gdb) информационные переменные</p><p height="1em" width="0pt">158</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Все определенные переменные:</p><p height="1em" width="0pt">Файл hello.c:</p><p height="1em" width="0pt">инт я;</p><p height="1em" width="0pt">Неотладочные символы:</p><p height="1em" width="0pt">0x00000000004005d0</p><p height="1em" width="0pt">_IO_stdin_used</p><p height="1em" width="0pt">0x00000000004005e4</p><p height="1em" width="0pt">__GNU_EH_FRAME_HDR</p><p height="1em" width="0pt">0x0000000000400708</p><p height="1em" width="0pt">__КАДР_END__</p><p height="1em" width="0pt">0x0000000000600e10</p><p height="1em" width="0pt">__frame_dummy_init_array_entry</p><p height="1em" width="0pt">0x0000000000600e10</p><p height="1em" width="0pt">__init_array_start</p><p height="1em" width="0pt">0x0000000000600e18</p><p height="1em" width="0pt">__do_global_dtors_aux_fini_array_entry</p><p height="1em" width="0pt">0x0000000000600e18</p><p height="1em" width="0pt">__init_array_end</p><p height="1em" width="0pt">0x0000000000600e20</p><p height="1em" width="0pt">__JCR_END__</p><p height="1em" width="0pt">0x0000000000600e20</p><p height="1em" width="0pt">__JCR_LIST__</p><p height="1em" width="0pt">0x0000000000600e28</p><p height="1em" width="0pt">_ДИНАМИЧЕСКИЙ</p><p height="1em" width="0pt">0x0000000000601000</p><p height="1em" width="0pt">_GLOBAL_OFFSET_TABLE_</p><p height="1em" width="0pt">0x0000000000601028</p><p height="1em" width="0pt">__data_start</p><p height="1em" width="0pt">0x0000000000601028</p><p height="1em" width="0pt">data_start</p><p height="1em" width="0pt">0x0000000000601030</p><p height="1em" width="0pt">__dso_handle</p><p height="1em" width="0pt">0x000000000060103c</p><p height="1em" width="0pt">__bss_start</p><p height="1em" width="0pt">0x000000000060103c</p><p height="1em" width="0pt">_edata</p><p height="1em" width="0pt">0x000000000060103c</p><p height="1em" width="0pt">завершенный</p><p height="1em" width="0pt">0x0000000000601040</p><p height="1em" width="0pt">__TMC_END__</p><p height="1em" width="0pt">0x0000000000601040</p><p height="1em" width="0pt">_конец</p><p height="1em" width="0pt"> <i>6.2.5 Команда: разобрать/разобрать</i></p><p height="1em" width="0pt">Эта команда отображает ассемблерный код исполняемого файла.</p><p height="1em" width="0pt"><b>Пример 6.2.8.</b>gdb может отображать ассемблерный код функции: (gdb) disassemble main</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">159</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Дамп ассемблерного кода функции main:</p><p height="1em" width="0pt">0x0804840b <+0>:</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">еккс,[esp+0x4]</p><p height="1em" width="0pt">0x0804840f <+4>:</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">esp, 0xffffffff0</p><p height="1em" width="0pt">0x08048412 <+7>:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">Двойное слово PTR [ecx-0x4]</p><p height="1em" width="0pt">0x08048415 <+10>: нажать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">0x08048416 <+11>: мов</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">0x08048418 <+13>: нажать</p><p height="1em" width="0pt">ecx</p><p height="1em" width="0pt">0x08048419 <+14>: суб</p><p height="1em" width="0pt">особенно, 0x4</p><p height="1em" width="0pt">0x0804841c <+17>: суб</p><p height="1em" width="0pt">особенно, 0xc</p><p height="1em" width="0pt">0x0804841f <+20>: нажать</p><p height="1em" width="0pt">0x80484c0</p><p height="1em" width="0pt">0x08048424 <+25>: вызов</p><p height="1em" width="0pt">0x80482e0 <puts@plt></p><p height="1em" width="0pt">0x08048429 <+30>: добавить</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">0x0804842c <+33>: мов</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">0x08048431 <+38>: мов</p><p height="1em" width="0pt">ecx,DWORD PTR [ebp-0x4]</p><p height="1em" width="0pt">0x08048434 <+41>: оставить</p><p height="1em" width="0pt">0x08048435 <+42>: лиа</p><p height="1em" width="0pt">особенно, [ecx-0x4]</p><p height="1em" width="0pt">0x08048438 <+45>: возврат</p><p height="1em" width="0pt">Конец дампа ассемблера.</p><p height="1em" width="0pt"><b>Пример 6.2.9.</b>Было бы полезнее, если бы был включен исходный код: (gdb) disassemble /s main</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Дамп ассемблерного кода функции main:</p><p height="1em" width="0pt">Привет:</p><p height="1em" width="0pt">4 {</p><p height="1em" width="0pt">0x0804840b <+0>: лиа</p><p height="1em" width="0pt">еккс,[esp+0x4]</p><p height="1em" width="0pt">0x0804840f <+4>: и</p><p height="1em" width="0pt">esp, 0xffffffff0</p><p height="1em" width="0pt">0x08048412 <+7>: нажать</p><p height="1em" width="0pt">Двойное слово PTR [ecx-0x4]</p><p height="1em" width="0pt">0x08048415 <+10>: нажать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">0x08048416 <+11>: мов</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">0x08048418 <+13>: нажать</p><p height="1em" width="0pt">ecx</p><p height="1em" width="0pt">0x08048419 <+14>: суб</p><p height="1em" width="0pt">особенно, 0x4</p><p height="1em" width="0pt">160</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">0x0804841c <+17>: суб</p><p height="1em" width="0pt">особенно, 0xc</p><p height="1em" width="0pt">0x0804841f <+20>: нажать</p><p height="1em" width="0pt">0x80484c0</p><p height="1em" width="0pt">0x08048424 <+25>: вызов</p><p height="1em" width="0pt">0x80482e0 <puts@plt></p><p height="1em" width="0pt">0x08048429 <+30>: добавить</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">0x0804842c <+33>: мов</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">7 }</p><p height="1em" width="0pt">0x08048431 <+38>: мов</p><p height="1em" width="0pt">ecx,DWORD PTR [ebp-0x4]</p><p height="1em" width="0pt">0x08048434 <+41>: оставить</p><p height="1em" width="0pt">0x08048435 <+42>: лиа</p><p height="1em" width="0pt">особенно, [ecx-0x4]</p><p height="1em" width="0pt">0x08048438 <+45>: возврат</p><p height="1em" width="0pt">Конец дампа ассемблера.</p><p height="1em" width="0pt">Теперь источник высокого уровня (выделен зеленым цветом) включен в состав дампа сборки. Каждая строка поддерживается соответствующим ассемблерным кодом под ней.</p><p height="1em" width="0pt"><b>Пример 6.2.10.</b>Если добавлен параметр /r, включаются необработанные инструкции в шестнадцатеричном формате, точно так же, как objdump отображает ассемблерный код по умолчанию: (gdb) дизассемблировать /rs main</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Дамп ассемблерного кода функции main:</p><p height="1em" width="0pt">Привет:</p><p height="1em" width="0pt">4 {</p><p height="1em" width="0pt">0x0804840b <+0>:</p><p height="1em" width="0pt">8д 4с 24 04</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">еккс,[esp+0x4]</p><p height="1em" width="0pt">0x0804840f <+4>:</p><p height="1em" width="0pt">83 e4 f0</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">esp, 0xffffffff0</p><p height="1em" width="0pt">0x08048412 <+7>:</p><p height="1em" width="0pt">фф 71 фк</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">Двойное слово PTR [ecx-0x4]</p><p height="1em" width="0pt">0x08048415 <+10>: 55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">0x08048416 <+11>: 89 e5</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">0x08048418 <+13>: 51</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ecx</p><p height="1em" width="0pt">0x08048419 <+14>: 83 эк 04</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0x4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">0x0804841c <+17>: 83 ек 0c</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0xc</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">161</p><p height="1em" width="0pt">0x0804841f <+20>: 68 c0 84 04 08 нажать</p><p height="1em" width="0pt">0x80484c0</p><p height="1em" width="0pt">0x08048424 <+25>: e8 b7 fe ff ff вызов</p><p height="1em" width="0pt">0x80482e0 <puts@plt></p><p height="1em" width="0pt">0x08048429 <+30>: 83 с4 10</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">0x0804842c <+33>: b8 00 00 00 00 мов</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">7 }</p><p height="1em" width="0pt">0x08048431 <+38>: 8b 4d fc</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">ecx,DWORD PTR [ebp-0x4]</p><p height="1em" width="0pt">0x08048434 <+41>: c9 оставить</p><p height="1em" width="0pt">0x08048435 <+42>: 8d 61 фк</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">особенно, [ecx-0x4]</p><p height="1em" width="0pt">0x08048438 <+45>: c3 возврат</p><p height="1em" width="0pt">Конец дампа ассемблера.</p><p height="1em" width="0pt"><b>Пример 6.2.11.</b>Также можно указать функцию в конкретном файле: (gdb) дизассемблировать /sr 'hello.c'::main</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Дамп ассемблерного кода функции main:</p><p height="1em" width="0pt">Привет:</p><p height="1em" width="0pt">4 {</p><p height="1em" width="0pt">0x0804840b <+0>:</p><p height="1em" width="0pt">8д 4с 24 04</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">еккс,[esp+0x4]</p><p height="1em" width="0pt">0x0804840f <+4>:</p><p height="1em" width="0pt">83 e4 f0</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">esp, 0xffffffff0</p><p height="1em" width="0pt">0x08048412 <+7>:</p><p height="1em" width="0pt">фф 71 фк</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">Двойное слово PTR [ecx-0x4]</p><p height="1em" width="0pt">0x08048415 <+10>: 55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">0x08048416 <+11>: 89 e5 мов</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">0x08048418 <+13>: 51</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ecx</p><p height="1em" width="0pt">0x08048419 <+14>: 83 эк 04</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0x4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">0x0804841c <+17>: 83 ек 0c</p><p height="1em" width="0pt">суб</p><p height="1em" width="0pt">особенно, 0xc</p><p height="1em" width="0pt">0x0804841f <+20>: 68 c0 84 04 08 нажать</p><p height="1em" width="0pt">0x80484c0</p><p height="1em" width="0pt">0x08048424 <+25>: e8 b7 fe ff ff вызов</p><p height="1em" width="0pt">0x80482e0 <puts@plt></p><p height="1em" width="0pt">0x08048429 <+30>: 83 с4 10</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">0x0804842c <+33>: b8 00 00 00 00 мов</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">7 }</p><p height="1em" width="0pt">162</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">0x08048431 <+38>: 8b 4d fc</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">ecx,DWORD PTR [ebp-0x4]</p><p height="1em" width="0pt">0x08048434 <+41>: c9 оставить</p><p height="1em" width="0pt">0x08048435 <+42>: 8d 61 фк</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">особенно, [ecx-0x4]</p><p height="1em" width="0pt">0x08048438 <+45>: c3 возврат</p><p height="1em" width="0pt">Конец дампа ассемблера.</p><p height="1em" width="0pt">Имя файла должно быть заключено в одинарные кавычки, а перед функцией должно стоять двойное двоеточие, например. 'hello.c'::main для указания дизассемблирования функции main в файле hello.c.</p><p height="1em" width="0pt"> <i>6.2.6 Команда: х</i></p><p height="1em" width="0pt">Эта команда проверяет содержимое заданного диапазона памяти.</p><p height="1em" width="0pt"><b>Пример 6.2.12.</b>Мы можем просмотреть необработанное содержимое в main: (gdb) x main</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x804840b <основной>: 0x04244c8d</p><p height="1em" width="0pt">По умолчанию без каких-либо аргументов команда печатает только содержимое одного адреса памяти. В данном случае это начальный адрес памяти в main.</p><p height="1em" width="0pt"><b>Пример 6.2.13.</b>С аргументами формата команда может распечатать диапазон памяти в определенном формате.</p><p height="1em" width="0pt">(gdb) x/20b основной</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x804840b <основной>:</p><p height="1em" width="0pt">0x8d 0x4c 0x24 0x04 0x83 0xe40xf0 0xff</p><p height="1em" width="0pt">0x8048413 <основной+8>:</p><p height="1em" width="0pt">0x71 0xfc 0x55 0x89 0xe5 0x510x83 0xec</p><p height="1em" width="0pt">0x804841b <основной+16>: 0x04 0x83 0xec 0x0c</p><p height="1em" width="0pt">Аргумент /20b main означает, что команда печатает 20 байт, где main начинается в памяти.</p><p height="1em" width="0pt">Общая форма аргумента формата: /<количество повторений><буква формата></p><a id="filepos510333" /><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">163</p><p height="1em" width="0pt">Если повторный счетчик не указан, по умолчанию gdb предоставляет счетчик как 1. Буква формата является одним из следующих значений:</p><p height="1em" width="0pt"><b>Письмо</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">о</p><p height="1em" width="0pt">Распечатайте содержимое памяти в<i>восьмеричный</i>формат.</p><p height="1em" width="0pt">Икс</p><p height="1em" width="0pt">Вывести содержимое памяти в шестнадцатеричном формате.</p><p height="1em" width="0pt">д</p><p height="1em" width="0pt">Вывести содержимое памяти в десятичном формате.</p><p height="1em" width="0pt">ты</p><p height="1em" width="0pt">Распечатайте содержимое памяти в<i>беззнаковое десятичное число</i>формат.</p><p height="1em" width="0pt">т</p><p height="1em" width="0pt">Распечатайте содержимое памяти в<i>бинарный</i>формат.</p><p height="1em" width="0pt">ф</p><p height="1em" width="0pt">Распечатайте содержимое памяти в<i>плавать</i>формат.</p><p height="1em" width="0pt">а</p><p height="1em" width="0pt">Распечатайте содержимое памяти как<i>адреса памяти</i>.</p><p height="1em" width="0pt">я</p><p height="1em" width="0pt">Распечатайте содержимое памяти в виде серии инструкций по сборке, аналогичной команде дизассемблирования.</p><p height="1em" width="0pt">с</p><p height="1em" width="0pt">Выведите содержимое памяти в виде массива символов ASCII.</p><p height="1em" width="0pt">с</p><p height="1em" width="0pt">Вывести содержимое памяти в виде строки</p><p height="1em" width="0pt">В зависимости от обстоятельств, определенный формат предпочтительнее других. Например, если область памяти содержит числа с плавающей запятой, то лучше использовать формат f, чем рассматривать числа как отдельные 1-байтовые шестнадцатеричные числа.</p><p height="1em" width="0pt"> <i>6.2.7 Команда: print/p</i></p><p height="1em" width="0pt">Исследование необработанной памяти полезно, но обычно лучше иметь более удобочитаемый вывод. Эта команда выполняет именно эту задачу: она красиво печатает выражение. Выражение может быть глобальной переменной, локальной переменной в текущем кадре стека, функцией, регистром, числом и т. д.</p><p height="1em" width="0pt"><b>6.3</b></p><p height="1em" width="0pt"><b>Проверка программы во время выполнения</b></p><p height="1em" width="0pt">В основном отладчик используется для проверки состояния программы во время ее выполнения. gdb предоставляет набор полезных команд для получения полезной информации о времени выполнения.</p><p height="1em" width="0pt"> <i>6.3.1 Команда: запустить</i></p><p height="1em" width="0pt">Эта команда запускает программу.</p><p height="1em" width="0pt"><b>Пример 6.3.1.</b>Запустите приветственную программу:</p><p height="1em" width="0pt">164</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Привет, мир!</p><p height="1em" width="0pt">[Низший 1 (процесс 1002) завершился нормально]</p><p height="1em" width="0pt">Программа успешно запустилась и напечатала сообщение «Hello World».</p><p height="1em" width="0pt">Однако было бы бесполезно, если бы все, что может делать gdb, — это запускать программу.</p><p height="1em" width="0pt"> <i>6.3.2 Команда: break/b</i></p><p height="1em" width="0pt">Эта команда устанавливает точку останова в месте высокоуровневого исходного кода. Когда gdb запускается в определенное место, отмеченное точкой останова, он прекращает выполнение, чтобы программист мог проверить текущее состояние программы.</p><p height="1em" width="0pt"><b>Пример 6.3.2.</b>Точка останова может быть установлена ​​на строке, отображаемой редактором. Предположим, мы хотим установить точку останова в строке 3 программы, которая является началом основной функции:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt"><b>int main(int argc, char *argv[])</b></p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">При запуске программы, вместо запуска от начала до конца, gdb остановился на строке 3:</p><p height="1em" width="0pt">(гдб) б 3</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">165</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Точка останова 1 по адресу 0x400535: файл hello.c, строка 3.</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, основная (argc=1, argv=0x7ffffffffdfb8) в hello.c:5</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">Точка останова находится в строке 3, но gdb остановил строку 5. Причина в том, что строка 3 содержит не код, а сигнатуру функции; gdb останавливается только там, где он может выполнить код. Код в функции начинается со строки 5, вызова printf, поэтому gdb останавливается на этом.</p><p height="1em" width="0pt"><b>Пример 6.3.3.</b>Строка кода не всегда является надежным способом указать точку останова, так как исходный код может быть изменен. Что, если gdb всегда должен останавливаться на основной функции? В этом случае лучше использовать имя функции напрямую:</p><p height="1em" width="0pt">б главный</p><p height="1em" width="0pt">Затем, независимо от того, как изменился исходный код, gdb всегда останавливается на основной функции.</p><p height="1em" width="0pt"><b>Пример 6.3.4.</b>Иногда отладочная программа не содержит отладочной информации или gdb отлаживает ассемблерный код. В этом случае в качестве точки остановки может быть указан адрес памяти. Чтобы получить адрес функции, можно использовать команду печати:</p><p height="1em" width="0pt">(gdb) печатать основной</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">$3 = {int (int, char **)} 0x400526 <main></p><p height="1em" width="0pt">Зная адрес main, мы можем легко установить точку останова с адресом памяти:</p><p height="1em" width="0pt">166</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">б *0x400526</p><p height="1em" width="0pt"><b>Пример 6.3.5.</b>gdb также может установить точку останова в любом исходном файле. Предположим, что программа hello состоит не из одного файла, а из множества файлов, например. hello1.c, hello2.c, hello3.c... В этом случае просто добавьте имя файла перед номером строки:</p><p height="1em" width="0pt">б привет.с:3</p><p height="1em" width="0pt"><b>Пример 6.3.6.</b>Также можно задать имя функции в конкретном файле: b hello.c:main</p><p height="1em" width="0pt"> <i>6.3.3 Команда: следующий/n</i></p><p height="1em" width="0pt">Эта команда выполняет текущую строку и останавливается на следующей строке. Когда текущая строка является вызовом функции, перешагивает через нее.</p><p height="1em" width="0pt"><b>Пример 6.3.7.</b>После установки точки останова на main запустите программу и остановитесь на первом printf:</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, основная (argc=1, argv=0x7ffffffffdfb8) в hello.c:5</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">Затем, чтобы перейти к следующему оператору, мы используем следующую команду: (gdb) n</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Привет, мир!</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">167</p><p height="1em" width="0pt">В выходных данных первая строка показывает результат, полученный после выполнения строки 5; затем следующая строка показывает, где в данный момент останавливается gdb, это строка 6.</p><p height="1em" width="0pt"> <i>6.3.4 Команда: шаг/с</i></p><p height="1em" width="0pt">Эта команда выполняет текущую строку и останавливается на следующей строке. Если текущая строка является вызовом функции, переходит к первой следующей строке вызываемой функции.</p><p height="1em" width="0pt"><b>Пример 6.3.8.</b>Предположим, у нас есть новая функция add1: 1 Зачем нам добавлять новую функцию</p><p height="1em" width="0pt">и вызов функции вместо использования</p><p height="1em" width="0pt">существующий вызов printf? Шагая в</p><p height="1em" width="0pt">функции разделяемой библиотеки сложны, потому что</p><p height="1em" width="0pt">заставить работать отладку, де-</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt">информация об ошибках должна быть установлена ​​и загружена.</p><p height="1em" width="0pt">Это не стоит проблем для демона-</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt">с помощью этой простой команды.</p><p height="1em" width="0pt"><b>инт</b>добавлять(<b>инт</b>а,<b>инт</b>б) {</p><p height="1em" width="0pt"><b>возвращаться</b>а + б;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">добавить (1, 2);</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Если в вызове функции printf используется команда step вместо next, gdb выполняет шаги внутри функции:</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, main (argc=1, argv=0xffffd154) в hello.c:11</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">добавить (1, 2);</p><p height="1em" width="0pt">168</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">добавить (a=1, b=2) в hello.c:6</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть а + б;</p><p height="1em" width="0pt">После выполнения команды s gdb вошел в функцию добавления, где первый оператор является возвратом.</p><p height="1em" width="0pt"> <i>6.3.5 Команда: ни</i></p><p height="1em" width="0pt">По сути, gdb работает с инструкциями по ассемблеру. Построчная отладка исходного кода — это просто усовершенствование, делающее его более удобным для программистов. Каждое выражение в C транслируется в одну или несколько ассемблерных инструкций, как показано в командах objdump и disassemble. Имея доступную отладочную информацию, gdb знает, сколько инструкций принадлежит одной строке высокоуровневого кода; построчная отладка — это просто выполнение ассемблерных инструкций строки при переходе от текущей строки к следующей.</p><p height="1em" width="0pt">Эта команда выполняет<i>один</i>ассемблерная инструкция принадлежит текущей строке. Пока не будут выполнены все ассемблерные инструкции текущей строки, gdb не перейдет к следующей строке. Если текущая инструкция является вызовом, перейти к следующей инструкции.</p><p height="1em" width="0pt"><b>Пример 6.3.9.</b>Когда точка останова находится на вызове printf и используется ni, он выполняет пошагово каждую инструкцию сборки:</p><p height="1em" width="0pt">(gdb) разобрать /s основной</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Дамп ассемблерного кода функции main:</p><p height="1em" width="0pt">Привет:</p><p height="1em" width="0pt">4 {</p><p height="1em" width="0pt">0x0804840b <+0>:</p><p height="1em" width="0pt">Леа</p><p height="1em" width="0pt">еккс,[esp+0x4]</p><p height="1em" width="0pt">0x0804840f <+4>:</p><p height="1em" width="0pt">и</p><p height="1em" width="0pt">esp, 0xffffffff0</p><p height="1em" width="0pt">0x08048412 <+7>:</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">Двойное слово PTR [ecx-0x4]</p><p height="1em" width="0pt">0x08048415 <+10>: нажать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">169</p><p height="1em" width="0pt">0x08048416 <+11>: мов</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">0x08048418 <+13>: нажать</p><p height="1em" width="0pt">ecx</p><p height="1em" width="0pt">0x08048419 <+14>: суб</p><p height="1em" width="0pt">особенно, 0x4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">0x0804841c <+17>: суб</p><p height="1em" width="0pt">особенно, 0xc</p><p height="1em" width="0pt">0x0804841f <+20>: нажать</p><p height="1em" width="0pt">0x80484c0</p><p height="1em" width="0pt">0x08048424 <+25>: вызов</p><p height="1em" width="0pt">0x80482e0 <puts@plt></p><p height="1em" width="0pt">0x08048429 <+30>: добавить</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">=> 0x0804842c <+33>: мов</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">7 }</p><p height="1em" width="0pt">0x08048431 <+38>: мов</p><p height="1em" width="0pt">ecx,DWORD PTR [ebp-0x4]</p><p height="1em" width="0pt">0x08048434 <+41>: оставить</p><p height="1em" width="0pt">0x08048435 <+42>: лиа</p><p height="1em" width="0pt">особенно, [ecx-0x4]</p><p height="1em" width="0pt">0x08048438 <+45>: возврат</p><p height="1em" width="0pt">Конец дампа ассемблера.</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, main (argc=1, argv=0xffffd154) в hello.c:5</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">(gdb) ни</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x0804841f 5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">(gdb) ни</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x08048424 5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">170</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">(gdb) ни</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Привет, мир!</p><p height="1em" width="0pt">0x08048429 5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">(ГДБ)</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">При вводе ni gdb выполняет текущую инструкцию и отображает<i>следующий</i>инструкция. Вот почему на выходе gdb отображает только 3 адреса: 0x0804841f, 0x08048424 и 0x08048429. Инструкция по адресу 0x0804841c, которая является первой инструкцией printf, не отображается, потому что это первая инструкция, на которой остановился gdb. Предположим, что gdb остановился на первой инструкции printf по адресу 0x0804841c, текущая инструкция может быть отображена с помощью команды x:</p><p height="1em" width="0pt">(gdb) x/i $eip</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">=> 0x804841c <основной+17>: подчиненный</p><p height="1em" width="0pt">особенно, 0xc</p><p height="1em" width="0pt"> <i>6.3.6 Команда: си</i></p><p height="1em" width="0pt">Подобно ni, эта команда выполняет текущую ассемблерную инструкцию, принадлежащую текущей строке. Но если текущая инструкция является вызовом, перейдите к первой следующей инструкции в вызываемой функции.</p><p height="1em" width="0pt"><b>Пример 6.3.10.</b>Напомним, что ассемблерный код, сгенерированный из printf, содержит инструкцию вызова:</p><p height="1em" width="0pt">(gdb) разобрать /s основной</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">171</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Дамп ассемблерного кода функции main:</p><p height="1em" width="0pt">Привет:</p><p height="1em" width="0pt">4 {</p><p height="1em" width="0pt">0x0804840b <+0>: лиа</p><p height="1em" width="0pt">еккс,[esp+0x4]</p><p height="1em" width="0pt">0x0804840f <+4>: и</p><p height="1em" width="0pt">esp, 0xffffffff0</p><p height="1em" width="0pt">0x08048412 <+7>: нажать</p><p height="1em" width="0pt">Двойное слово PTR [ecx-0x4]</p><p height="1em" width="0pt">0x08048415 <+10>: нажать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">0x08048416 <+11>: мов</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">0x08048418 <+13>: нажать</p><p height="1em" width="0pt">ecx</p><p height="1em" width="0pt">0x08048419 <+14>: суб</p><p height="1em" width="0pt">особенно, 0x4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">0x0804841c <+17>: суб</p><p height="1em" width="0pt">особенно, 0xc</p><p height="1em" width="0pt">0x0804841f <+20>: нажать</p><p height="1em" width="0pt">0x80484c0</p><p height="1em" width="0pt">0x08048424 <+25>: вызов</p><p height="1em" width="0pt">0x80482e0 <puts@plt></p><p height="1em" width="0pt">0x08048429 <+30>: добавить</p><p height="1em" width="0pt">особенно, 0x10</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">=> 0x0804842c <+33>: мов</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">7 }</p><p height="1em" width="0pt">0x08048431 <+38>: мов</p><p height="1em" width="0pt">ecx,DWORD PTR [ebp-0x4]</p><p height="1em" width="0pt">0x08048434 <+41>: оставить</p><p height="1em" width="0pt">0x08048435 <+42>: лиа</p><p height="1em" width="0pt">особенно, [ecx-0x4]</p><p height="1em" width="0pt">0x08048438 <+45>: возврат</p><p height="1em" width="0pt">Конец дампа ассемблера.</p><p height="1em" width="0pt">Мы снова пытаемся выполнить пошаговую инструкцию за инструкцией, но на этот раз запустив si по адресу 0x08048424, где находится вызов:</p><p height="1em" width="0pt">(gdb) си</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x0804841f 5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">(gdb) си</p><p height="1em" width="0pt">172</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x08048424 5</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt">(gdb) x/i $eip</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">=> 0x8048424 <main+25>: вызов</p><p height="1em" width="0pt">0x80482e0 <puts@plt></p><p height="1em" width="0pt">(gdb) си</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x080482e0 в puts@plt()</p><p height="1em" width="0pt">Следующая инструкция сразу после 0x8048424 — это первая инструкция по адресу 0x080482e0 в функции puts. Другими словами, gdb вмешивается в путы вместо того, чтобы перешагивать через них.</p><p height="1em" width="0pt"> <i>6.3.7 Команда: пока</i></p><p height="1em" width="0pt">Эта команда выполняется до тех пор, пока следующая строка не окажется больше текущей.</p><p height="1em" width="0pt"><b>Пример 6.3.11.</b>Предположим, у нас есть функция, которая выполняет длинный цикл: hello.c</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>добавить1000() {</p><p height="1em" width="0pt"><b>инт</b>всего = 0;</p><p height="1em" width="0pt"><b>для</b>(<b>инт</b>я = 0; я < 1000; ++ я) {</p><p height="1em" width="0pt">всего += я;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">printf("Добавление завершено!\n");</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">173</p><p height="1em" width="0pt"><b>возвращаться</b>общий;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">добавить1000(1, 2);</p><p height="1em" width="0pt">printf("Привет, мир!\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Используя следующую команду, нам нужно нажать 1000 раз, чтобы завершить цикл. Вместо этого более быстрый способ - использовать до тех пор, пока:</p><p height="1em" width="0pt">(gdb) b добавить1000</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Точка останова 1 по адресу 0x8048411: файл hello.c, строка 4.</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, add1000() в hello.c:4</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">общее количество = 0;</p><p height="1em" width="0pt">(гдб) до тех пор, пока</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">для (целое я = 0; я < 1000; ++ я) {</p><p height="1em" width="0pt">(гдб) до тех пор, пока</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">всего += я;</p><p height="1em" width="0pt">174</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">(гдб) до тех пор, пока</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">для (целое я = 0; я < 1000; ++ я) {</p><p height="1em" width="0pt">(гдб) до тех пор, пока</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">printf("Добавление завершено!\n");</p><p height="1em" width="0pt">Выполняя первую команду until, gdb остановился на строке 5, так как строка 5 больше строки 4.</p><p height="1em" width="0pt">Выполняя второй до тех пор, gdb остановился на строке 6, так как строка 6 больше, чем строка 5.</p><p height="1em" width="0pt">Выполняя третий до тех пор, gdb остановился на строке 5, так как цикл все еще продолжается. Поскольку строка 5 меньше строки 6, с четвертой до тех пор, gdb продолжал выполняться до тех пор, пока не перестанет возвращаться к строке 5 и не остановится на строке 8. Это отличный способ пропустить цикл в середине, вместо того, чтобы устанавливать ненужные точка останова.</p><p height="1em" width="0pt"><b>Пример 6.3.12.</b>Пока не может быть предоставлен аргумент для явного выполнения в определенной строке:</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, add1000() в hello.c:4</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">общее количество = 0;</p><p height="1em" width="0pt">(гдб) до 8</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">add1000 () в hello.c:8</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">printf("Добавление завершено!\n");</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">175</p><p height="1em" width="0pt"> <i>6.3.8 Команда: закончить</i></p><p height="1em" width="0pt">Эта команда выполняется до конца функции и отображает возвращаемое значение. Finish на самом деле просто более удобная версия until.</p><p height="1em" width="0pt"><b>Пример 6.3.13.</b>Использование функции add1000 из предыдущего примера и использование finish вместо until:</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, add1000() в hello.c:4</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">общее количество = 0;</p><p height="1em" width="0pt">(ГДБ) закончить</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Бежать до выхода из #0</p><p height="1em" width="0pt">add1000 () в hello.c:4</p><p height="1em" width="0pt">Готово добавление!</p><p height="1em" width="0pt">0x08048466 в main (argc=1, argv=0xffffd154) в hello.c:15</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">добавить1000(1, 2);</p><p height="1em" width="0pt">Возвращаемое значение: $1 = 499500.</p><p height="1em" width="0pt"> <i>6.3.9 Команда: bt</i></p><p height="1em" width="0pt">Эта команда печатает<i>проследить</i>всех кадров стека. А<i>проследить</i>это</p><p height="1em" width="0pt"> <i><b>проследить</b></i></p><p height="1em" width="0pt">список активных функций:</p><p height="1em" width="0pt"><b>Пример 6.3.14.</b>Предположим, у нас есть цепочка вызовов функций: hello.c</p><p height="1em" width="0pt"><b>пустота</b>д(<b>инт</b>г) {};</p><p height="1em" width="0pt"><b>пустота</b>с(<b>инт</b>в) { д(0); }</p><p height="1em" width="0pt"><b>пустота</b>б(<b>инт</b>б) { с(1); }</p><p height="1em" width="0pt"><b>пустота</b>а(<b>инт</b>а) { б(2); }</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">176</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">а(3);</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">bt может визуализировать такую ​​цепочку в действии:</p><p height="1em" width="0pt">(gdb) б а</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Точка останова 1 по адресу 0x8048404: файл hello.c, строка 9.</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Точка останова 1, a (a=3) в hello.c:9</p><p height="1em" width="0pt">9 пустота а(инт а) { б(2); }</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">б (б = 2) в hello.c: 7</p><p height="1em" width="0pt">7 пустота б (целое б) { с (1); }</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">c (c=1) в hello.c:5</p><p height="1em" width="0pt">5 пустота с (целое число с) { д (0); }</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">177</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">d (d=0) в hello.c:3</p><p height="1em" width="0pt">3 пустота d(int d) {};</p><p height="1em" width="0pt">(гдб) бт</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">#0</p><p height="1em" width="0pt">d (d=0) в hello.c:3</p><p height="1em" width="0pt">#1</p><p height="1em" width="0pt">0x080483eb в c (c=1) в hello.c:5</p><p height="1em" width="0pt">#2</p><p height="1em" width="0pt">0x080483fb в b (b=2) в hello.c:7</p><p height="1em" width="0pt">#3</p><p height="1em" width="0pt">0x0804840b в a (a=3) в hello.c:9</p><p height="1em" width="0pt">#4</p><p height="1em" width="0pt">0x0804841b в main (argc=1, argv=0xffffd154) в hello.c:13</p><p height="1em" width="0pt">Самые последние звонки помещаются вверху, а самые последние звонки внизу. В этом случае d является самой текущей активной функцией, поэтому она имеет индекс 0. Далее идет c, вторая активная функция, имеет индекс 1 и так далее с функцией b, функцией a и, наконец, функцией main внизу, самая последняя функция. Вот так мы читаем обратную трассу.</p><p height="1em" width="0pt"> <i>6.3.10 Команда: вверх</i></p><p height="1em" width="0pt">Эта команда перемещается на один кадр раньше текущего кадра.</p><p height="1em" width="0pt"><b>Пример 6.3.15.</b>Вместо того, чтобы оставаться в функции d, мы можем перейти к функции c и посмотреть на ее состояние:</p><p height="1em" width="0pt">(гдб) бт</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">#0</p><p height="1em" width="0pt">d (d=0) в hello.c:3</p><p height="1em" width="0pt">#1</p><p height="1em" width="0pt">0x080483eb в c (c=1) в hello.c:5</p><p height="1em" width="0pt">#2</p><p height="1em" width="0pt">0x080483fb в b (b=2) в hello.c:7</p><p height="1em" width="0pt">#3</p><p height="1em" width="0pt">0x0804840b в a (a=3) в hello.c:9</p><p height="1em" width="0pt">#4</p><p height="1em" width="0pt">0x0804841b в main (argc=1, argv=0xffffd154) в hello.c:13</p><p height="1em" width="0pt">(gdb) вверх</p><p height="1em" width="0pt">178</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">#1</p><p height="1em" width="0pt">0x080483eb в c (c=1) в hello.c:3</p><p height="1em" width="0pt">3 пустота б (целое б) { с (1); }</p><p height="1em" width="0pt">Вывод показывает, что текущий кадр перемещен в c и где сделан вызов c, который находится в функции b в строке 3.</p><p height="1em" width="0pt"> <i>6.3.11 Команда: вниз</i></p><p height="1em" width="0pt">Подобно команде up, эта команда перемещается вниз на один кадр позже текущего кадра.</p><p height="1em" width="0pt"><b>Пример 6.3.16.</b>После проверки функции c мы можем вернуться к d: (gdb) bt</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">#0</p><p height="1em" width="0pt">d (d=0) в hello.c:3</p><p height="1em" width="0pt">#1</p><p height="1em" width="0pt">0x080483eb в c (c=1) в hello.c:5</p><p height="1em" width="0pt">#2</p><p height="1em" width="0pt">0x080483fb в b (b=2) в hello.c:7</p><p height="1em" width="0pt">#3</p><p height="1em" width="0pt">0x0804840b в a (a=3) в hello.c:9</p><p height="1em" width="0pt">#4</p><p height="1em" width="0pt">0x0804841b в main (argc=1, argv=0xffffd154) в hello.c:13</p><p height="1em" width="0pt">(gdb) вверх</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">#1</p><p height="1em" width="0pt">0x080483eb в c (c=1) в hello.c:3</p><p height="1em" width="0pt">3 пустота б (целое б) { с (1); }</p><p height="1em" width="0pt">(ГДБ) вниз</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">#0</p><p height="1em" width="0pt">d (d=0) в hello.c:1</p><p height="1em" width="0pt">1 пустота d(int d) {};</p><a id="filepos540659" /><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">179</p><p height="1em" width="0pt"> <i>6.3.12 Команда: информационные регистры</i></p><p height="1em" width="0pt">Эта команда выводит список текущих значений в часто используемых регистрах. Эта команда полезна при отладке кода сборки и операционной системы, так как мы можем проверить текущее состояние машины.</p><p height="1em" width="0pt"><b>Пример 6.3.17.</b>Выполнив команду, мы можем увидеть часто используемые регистры:</p><p height="1em" width="0pt">(gdb) информационные регистры</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">эакс</p><p height="1em" width="0pt">0xf7faddbc-134554180</p><p height="1em" width="0pt">ecx</p><p height="1em" width="0pt">0xffffd0c0 -12096</p><p height="1em" width="0pt">edx</p><p height="1em" width="0pt">0xffffd0e4 -12060</p><p height="1em" width="0pt">ebx</p><p height="1em" width="0pt">0x0 0</p><p height="1em" width="0pt">особенно</p><p height="1em" width="0pt">0xffffd0a0 0xffffd0a0</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">0xffffd0a8 0xffffd0a8</p><p height="1em" width="0pt">эси</p><p height="1em" width="0pt">0xf7fac000 -134561792</p><p height="1em" width="0pt">эди</p><p height="1em" width="0pt">0xf7fac000 -134561792</p><p height="1em" width="0pt">эп</p><p height="1em" width="0pt">0x804841c 0x804841c <главная+17></p><p height="1em" width="0pt">флаги</p><p height="1em" width="0pt">0x286 [ПФ СФ ЕСЛИ]</p><p height="1em" width="0pt">cs</p><p height="1em" width="0pt">0x23 35</p><p height="1em" width="0pt">SS</p><p height="1em" width="0pt">0x2b 43</p><p height="1em" width="0pt">дс</p><p height="1em" width="0pt">0x2b 43</p><p height="1em" width="0pt">эс</p><p height="1em" width="0pt">0x2b 43</p><p height="1em" width="0pt">фс</p><p height="1em" width="0pt">0x0 0</p><p height="1em" width="0pt">гс</p><p height="1em" width="0pt">0x63 99</p><p height="1em" width="0pt">Вышеупомянутых регистров достаточно для написания нашей операционной системы в более поздней части.</p><p height="1em" width="0pt"><b>6.4</b></p><p height="1em" width="0pt"><b>Как работают отладчики: краткое введение</b></p><p height="1em" width="0pt"> <i>6.4.1 Как работают точки останова</i></p><p height="1em" width="0pt">Когда программист ставит точку останова где-то в своем коде, на самом деле происходит следующее:<i>первый</i>код операции<i>первый</i>инструкция гос-</p><p height="1em" width="0pt">180</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">ment заменяется другой инструкцией, int 3 с опкодом CCh: 83</p><p height="1em" width="0pt">эк</p><p height="1em" width="0pt">0с</p><p height="1em" width="0pt">→</p><p height="1em" width="0pt">копия</p><p height="1em" width="0pt">эк</p><p height="1em" width="0pt">0с</p><p height="1em" width="0pt"><b>Рисунок 6.4.1:</b>Код операции заменить-</p><p height="1em" width="0pt">саб эсп, 0x4</p><p height="1em" width="0pt">целое 3</p><p height="1em" width="0pt">мент, с интервалом 3</p><p height="1em" width="0pt">int 3 занимает всего один байт, что делает его эффективным для отладки. Когда выполняется инструкция int 3, операционная система вызывает обработчик прерывания от точки останова. Затем обработчик проверяет, какой процесс достигает точки останова, приостанавливает его и уведомляет отладчик о приостановке отлаживаемого процесса. Отлаживаемый процесс только приостанавливается, и это означает, что отладчик может свободно проверять его внутреннее состояние, как хирург оперирует пациента под наркозом. Затем отладчик заменяет код операции int 3 исходным кодом операции и выполняет исходную инструкцию в обычном режиме.</p><p height="1em" width="0pt">копия</p><p height="1em" width="0pt">эк</p><p height="1em" width="0pt">0с</p><p height="1em" width="0pt">→</p><p height="1em" width="0pt">83</p><p height="1em" width="0pt">эк</p><p height="1em" width="0pt">0с</p><p height="1em" width="0pt"><b>Рисунок 6.4.2:</b>Восстановить оригинал</p><p height="1em" width="0pt">целое 3</p><p height="1em" width="0pt">саб эсп, 0x4</p><p height="1em" width="0pt">код операции после выполнения int 3</p><p height="1em" width="0pt"><b>Пример 6.4.1.</b>Несложно увидеть int 3 в действии. Во-первых, мы добавляем инструкцию int 3, где нам нужно, чтобы gdb остановился:</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">asm("целое 3");</p><p height="1em" width="0pt">printf("Привет, мир\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">int 3 предшествует printf, поэтому ожидается, что gdb остановится на printf. Затем мы компилируем с включенной отладкой и синтаксисом Intel:</p><p height="1em" width="0pt">$ gcc -masm=intel -m32 -g hello.c -o привет</p><p height="1em" width="0pt">Наконец, запустите gdb:</p><p height="1em" width="0pt">$ gdb привет</p><p height="1em" width="0pt">проверка и отладка во время выполнения</p><p height="1em" width="0pt">181</p><p height="1em" width="0pt">Работая без установки точки останова, gdb останавливается при вызове printf, как и ожидалось:</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/hello</p><p height="1em" width="0pt">Программа получила сигнал SIGTRAP, ловушка трассировки/точки останова.</p><p height="1em" width="0pt">основной (argc=1, argv=0xffffd154) в hello.c:6</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">printf("Привет, мир\n");</p><p height="1em" width="0pt">Синий текст указывает на то, что gdb столкнулся с точкой останова и действительно остановился в нужном месте: на вызове printf, где ему предшествовало int 3.</p><p height="1em" width="0pt"> <i>6.4.2 Одношаговый</i></p><p height="1em" width="0pt">Когда реализована точка останова, легко реализовать пошаговое выполнение: отладчик просто помещает другой код операции int 3 в следующую инструкцию.</p><p height="1em" width="0pt">Таким образом, когда программист устанавливает точку останова на инструкции, следующая инструкция автоматически устанавливается отладчиком, что позволяет выполнять отладку по инструкции. Точно так же построчная отладка исходного кода — это просто размещение самых первых кодов операций в двух операторах с двумя кодами операций int 3.</p><p height="1em" width="0pt"> <i>6.4.3 Как отладчик понимает исходный код высокого уровня</i>DWARF — это формат файла отладки, используемый многими компиляторами и отладчиками для поддержки отладки на уровне исходного кода. DWARF содержит информацию, которая сопоставляет объекты в исполняемом двоичном файле с исходными файлами.</p><p height="1em" width="0pt">Программный объект может быть либо данными, либо кодом. А<b>УМЕРЕТЬ</b>, или<i><b>Д</b></i><i>откладывание</i><i><b>я</b></i><i>информация</i></p><p height="1em" width="0pt"> <i><b>Отладочная информация</b></i></p><p height="1em" width="0pt"> <i><b>Е</b></i><i>попытаться</i>, является описанием объекта программы. DIE состоит из тега, который sp<i><b>Вход</b></i></p><p height="1em" width="0pt">эк-</p><p height="1em" width="0pt">определяет сущность, которую описывает DIE, и список атрибутов, описывающих сущность. Из всех атрибутов эти два атрибута включают отладку на уровне исходного кода:</p><p height="1em" width="0pt">Где объект появляется в исходных файлах: в каком файле и в какой строке появляется объект.</p><p height="1em" width="0pt">182</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Где объект появляется в исполняемом двоичном файле:</p><p height="1em" width="0pt">в какой адрес памяти объект загружается во время выполнения. С точным адресом gdb может получить правильное значение для объекта данных или установить правильную точку останова и соответственно остановиться для объекта кода. Без информации об этих адресах gdb не знал бы, где находятся объекты для их проверки.</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt"><b>УМЕРЕТЬ</b></p><p height="1em" width="0pt">Линия 1</p><p height="1em" width="0pt">#include <stdio.h></p><p height="1em" width="0pt">....</p><p height="1em" width="0pt">Линия 2</p><p height="1em" width="0pt">....</p><p height="1em" width="0pt">⇒ Строка 3</p><p height="1em" width="0pt">int main(int argc, char *argv[])</p><p height="1em" width="0pt">→</p><p height="1em" width="0pt">main в hello.c находится по адресу</p><p height="1em" width="0pt">Строка 5</p><p height="1em" width="0pt">..........</p><p height="1em" width="0pt">0x804840b привет</p><p height="1em" width="0pt">Строка 6</p><p height="1em" width="0pt">..........</p><p height="1em" width="0pt">....</p><p height="1em" width="0pt">....</p><p height="1em" width="0pt">↓↑</p><p height="1em" width="0pt"><b>привет</b>(0x804840b)</p><p height="1em" width="0pt">...8d 4c 24 04 83 e4 f0</p><p height="1em" width="0pt">фф 71 фк ....</p><p height="1em" width="0pt"><b>Рисунок 6.4.3:</b>Исходный бинарный</p><p height="1em" width="0pt">В дополнение к DIE, другим отображением двоичного кода в исходный код является<i>отображение нумерации строк с помощью DIE</i></p><p height="1em" width="0pt"><i>бер стол. Таблица номеров строк сопоставляет строку в исходном коде с адресом памяти, с которого начинается строка в исполняемом двоичном файле.</i></p><p height="1em" width="0pt"><i>Таким образом, чтобы успешно включить отладку на уровне исходного кода, отладчику необходимо знать точное расположение исходных файлов и адреса загрузки во время выполнения. Сопоставление адресов между макетом изображения двоичного файла ELF и адресом, по которому он загружается, чрезвычайно важно, поскольку отладочная информация зависит от правильного адреса загрузки во время выполнения. То есть он предполагает, что адреса, записанные в двоичном образе во время компиляции, такие же, как и во время выполнения, например. если адрес загрузки для раздела .text записан в исполняемом двоичном файле по адресу 0x800000, то, когда двоичный файл действительно запускается,</i></p><p height="1em" width="0pt"><i>.text действительно должен быть загружен по адресу 0x800000, чтобы gdb мог правильно сопоставлять выполняемые инструкции с оператором кода высокого уровня. Несоответствие адресов делает отладочную информацию бесполезной, поскольку фактический код по одному адресу отображается как код по другому адресу. Без этих знаний мы</i></p><p height="1em" width="0pt"><i>проверка и отладка во время выполнения</i></p><p height="1em" width="0pt"><i>183</i></p><p height="1em" width="0pt"><i>не сможет построить операционную систему, которую можно отлаживать с помощью gdb.</i></p><p height="1em" width="0pt"><i><b>Пример 6.4.2.</b></i><i>Когда исполняемый двоичный файл содержит отладочную информацию, readelf может отобразить такую ​​информацию в удобочитаемом формате. Используя старую добрую программу hello world:</i></p><p height="1em" width="0pt"><i>Привет</i></p><p height="1em" width="0pt"><i><b>#включать</b></i><i><stdio.h></i></p><p height="1em" width="0pt"><i><b>инт</b></i><i>основной(</i><i><b>инт</b></i><i>аргк,</i><i><b>уголь</b></i><i>*argv[])</i></p><p height="1em" width="0pt"><i>{</i></p><p height="1em" width="0pt"><i>printf("Привет, мир\n");</i></p><p height="1em" width="0pt"><i><b>возвращаться</b></i><i>0;</i></p><p height="1em" width="0pt"><i>}</i></p><p height="1em" width="0pt"><i>и скомпилировать с отладочной информацией:</i></p><p height="1em" width="0pt"><i>$ gcc -m32 -g hello.c -o привет</i></p><p height="1em" width="0pt"><i>Когда бинарник готов, мы можем посмотреть таблицу номеров строк с помощью команды:</i></p><p height="1em" width="0pt"><i>$ readlelf -wL привет</i></p><p height="1em" width="0pt"><i>Опция -w выводит всю отладочную информацию. В сочетании с его подпараметром отображается только конкретная информация. Например, с -L отображается только таблица номеров строк:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Декодированный дамп отладочного содержимого секции .debug_line:CU:hello.c:</i></p><p height="1em" width="0pt"><i>Имя файла</i></p><p height="1em" width="0pt"><i>Номер строки</i></p><p height="1em" width="0pt"><i>Начальный адрес</i></p><p height="1em" width="0pt"><i>Привет</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>0x804840b</i></p><p height="1em" width="0pt"><i>Привет</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>0x804841с</i></p><p height="1em" width="0pt"><i>Привет</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>0x804842c</i></p><p height="1em" width="0pt"><i>184</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>Привет</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i>0x8048431</i></p><p height="1em" width="0pt"><i>Из приведенного выше вывода:</i></p><p height="1em" width="0pt"><i>CU шорты для</i><i><b>С</b></i><i>компиляция</i><i><b>U</b></i><i>nit, отдельно скомпилированный исходный файл. В нашем примере у нас есть только один файл hello.c.</i></p><p height="1em" width="0pt"><i>Имя файла отображает имя файла текущей единицы компиляции.</i></p><p height="1em" width="0pt"><i>Номер строки — это номер строки в исходном файле, в котором эта строка не является пустой строкой. В примере строка 8 является пустой строкой, поэтому она не отображается.</i></p><p height="1em" width="0pt"><i>Начальный адрес — это адрес памяти, где фактически начинается строка в исполняемом двоичном файле.</i></p><p height="1em" width="0pt"><i>С такой кристально чистой информацией именно так gdb может легко установить точку останова на строке. Для размещения точек останова на переменных и функциях пришло время взглянуть на DIE. Чтобы получить информацию о DIE из исполняемого двоичного файла, выполните команду:</i></p><p height="1em" width="0pt"><i>$ readlelf - привет</i></p><p height="1em" width="0pt"><i>Опция -wi выводит список всех записей DIE. Это типичная запись DIE:</i></p><p height="1em" width="0pt"><i><0><b>: Номер сокращения: 1 (DW_TAG_compile_unit)</i></p><p height="1em" width="0pt"><i><с></i></p><p height="1em" width="0pt"><i>DW_AT_производитель</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0xe): GNU C11 5.4.0 20160609 -masm=intel -m32 -mtune=generic -march=i686 -g -fstack-protector-strong</i></p><p height="1em" width="0pt"><i><10></i></p><p height="1em" width="0pt"><i>DW_AT_language</i></p><p height="1em" width="0pt"><i>: 12 (ANSI C99)</i></p><p height="1em" width="0pt"><i><11></i></p><p height="1em" width="0pt"><i>DW_AT_имя</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0xbe):</i><i><b>Привет</b></i></p><p height="1em" width="0pt"><i><15></i></p><p height="1em" width="0pt"><i>DW_AT_comp_dir</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0x97):</i><i><b>/tmp</b></i></p><p height="1em" width="0pt"><i><19></i></p><p height="1em" width="0pt"><i>DW_AT_low_pc</i></p><p height="1em" width="0pt"><i>:</i><i><b>0x804840b</b></i></p><p height="1em" width="0pt"><i><1д></i></p><p height="1em" width="0pt"><i>DW_AT_high_pc</i></p><p height="1em" width="0pt"><i>:</i><i><b>0x2e</b></i></p><p height="1em" width="0pt"><i><21></i></p><p height="1em" width="0pt"><i>DW_AT_stmt_list</i></p><p height="1em" width="0pt"><i>: 0x0</i></p><p height="1em" width="0pt"><i>Красный Это крайнее левое число указывает текущий уровень вложенности DIE.</i></p><p height="1em" width="0pt"><i>вход. 0 — это DIE самого внешнего уровня, а его сущность — единица компиляции. Это означает, что все последующие записи DIE с более высоким уровнем вложенности являются дочерними элементами этого тега, единицы компиляции. Это имеет смысл, так как все объекты должны происходить из исходного файла.</i></p><p height="1em" width="0pt"><i>проверка и отладка во время выполнения</i></p><p height="1em" width="0pt"><i>185</i></p><p height="1em" width="0pt"><i>Синий Эти числа в шестнадцатеричном формате указывают смещения в разделе .debug_info. Каждая значимая информация отображается вместе со своим смещением. Когда атрибут ссылается на другой атрибут, смещение используется для точной идентификации ссылочного атрибута.</i></p><p height="1em" width="0pt"><i>Зеленый Эти имена с префиксом DW_AT_ являются атрибутами, прикрепленными к DIE, которые описывают объект. Примечательные атрибуты:</i></p><p height="1em" width="0pt"><i>DW_AT_имя</i></p><p height="1em" width="0pt"><i>DW_AT_comp_dir Имя файла модуля компиляции и каталог, в котором произошла компиляция. Без имени файла и пути gdb не сможет отобразить исходный код высокого уровня, несмотря на наличие отладочной информации. Информация об отладке содержит только сопоставление между исходным и двоичным файлами, а не сам исходный код.</i></p><p height="1em" width="0pt"><i>DW_AT_low_pc</i></p><p height="1em" width="0pt"><i>DW_AT_high_pc Начало и конец текущего объекта, который является единицей компиляции, в исполняемом двоичном файле. Значение в DW_AT_low_pc является начальным адресом. DW_AT_high_pc — это размер единицы компиляции, при добавлении к DW_AT_low_pc получается конечный адрес объекта. В этом примере код, скомпилированный из hello.c, начинается с адреса 0x804840b и заканчивается на адресе 0x804840b + 0x2e = 0x8048439.</i></p><p height="1em" width="0pt"><i>Чтобы действительно убедиться, мы проверяем с помощью objdump:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>int main(int argc, char *argv[])</i></p><p height="1em" width="0pt"><i>{</i></p><p height="1em" width="0pt"><i>804840b:</i></p><p height="1em" width="0pt"><i>8д 4с 24 04</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>еккс,[esp+0x4]</i></p><p height="1em" width="0pt"><i>804840f:</i></p><p height="1em" width="0pt"><i>83 e4 f0</i></p><p height="1em" width="0pt"><i>и</i></p><p height="1em" width="0pt"><i>esp, 0xffffffff0</i></p><p height="1em" width="0pt"><i>8048412:</i></p><p height="1em" width="0pt"><i>фф 71 фк</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>Двойное слово PTR [ecx-0x4]</i></p><p height="1em" width="0pt"><i>8048415:</i></p><p height="1em" width="0pt"><i>55</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>8048416:</i></p><p height="1em" width="0pt"><i>89 e5</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>е.и.п., особенно</i></p><p height="1em" width="0pt"><i>8048418:</i></p><p height="1em" width="0pt"><i>51</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ecx</i></p><p height="1em" width="0pt"><i>8048419:</i></p><p height="1em" width="0pt"><i>83 эк 04</i></p><p height="1em" width="0pt"><i>суб</i></p><p height="1em" width="0pt"><i>особенно, 0x4</i></p><p height="1em" width="0pt"><i>printf("Привет, мир\n");</i></p><p height="1em" width="0pt"><i>804841с:</i></p><p height="1em" width="0pt"><i>83 ек 0с</i></p><p height="1em" width="0pt"><i>суб</i></p><p height="1em" width="0pt"><i>особенно, 0xc</i></p><p height="1em" width="0pt"><i>804841f:</i></p><p height="1em" width="0pt"><i>68 с0 84 04 08</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>0x80484c0</i></p><p height="1em" width="0pt"><i>186</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>8048424:</i></p><p height="1em" width="0pt"><i>e8 b7 fe ff ff</i></p><p height="1em" width="0pt"><i>вызов</i></p><p height="1em" width="0pt"><i>80482e0 <puts@plt></i></p><p height="1em" width="0pt"><i>8048429:</i></p><p height="1em" width="0pt"><i>83 с4 10</i></p><p height="1em" width="0pt"><i>добавлять</i></p><p height="1em" width="0pt"><i>особенно, 0x10</i></p><p height="1em" width="0pt"><i>вернуть 0;</i></p><p height="1em" width="0pt"><i>804842с:</i></p><p height="1em" width="0pt"><i>б8 00 00 00 00</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>еакс, 0x0</i></p><p height="1em" width="0pt"><i>}</i></p><p height="1em" width="0pt"><i>8048431:</i></p><p height="1em" width="0pt"><i>8b 4d фк</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>ecx,DWORD PTR [ebp-0x4]</i></p><p height="1em" width="0pt"><i>8048434:</i></p><p height="1em" width="0pt"><i>с9</i></p><p height="1em" width="0pt"><i>оставлять</i></p><p height="1em" width="0pt"><i>8048435:</i></p><p height="1em" width="0pt"><i>8д 61 фк</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>особенно, [ecx-0x4]</i></p><p height="1em" width="0pt"><i>8048438:</i></p><p height="1em" width="0pt"><i>с3</i></p><p height="1em" width="0pt"><i>рет</i></p><p height="1em" width="0pt"><i>8048439:</i></p><p height="1em" width="0pt"><i>66 90</i></p><p height="1em" width="0pt"><i>хчг</i></p><p height="1em" width="0pt"><i>топор, топор</i></p><p height="1em" width="0pt"><i>804843б:</i></p><p height="1em" width="0pt"><i>66 90</i></p><p height="1em" width="0pt"><i>хчг</i></p><p height="1em" width="0pt"><i>топор, топор</i></p><p height="1em" width="0pt"><i>804843д:</i></p><p height="1em" width="0pt"><i>66 90</i></p><p height="1em" width="0pt"><i>хчг</i></p><p height="1em" width="0pt"><i>топор, топор</i></p><p height="1em" width="0pt"><i>804843f:</i></p><p height="1em" width="0pt"><i>90</i></p><p height="1em" width="0pt"><i>нет</i></p><p height="1em" width="0pt"><i>Это правда: main начинается с 804840b и заканчивается на 8048439, сразу после инструкции ret на 8048438. Инструкции после 8048439 — это просто байты заполнения, вставленные gcc для выравнивания, которые не принадлежат main. Обратите внимание, что вывод objdump показывает гораздо больше кода, чем main. Не засчитывается, так как код вне hello.c, добавленный gcc для операционной системы. hello.c содержит только одну функцию: main, поэтому hello.c также начинается и заканчивается так же, как и main.</i></p><p height="1em" width="0pt"><i>Розовый Этот номер отображает форму аббревиатуры тега. Аббревиатура — это форма DIE. Когда отладочная информация отображается с параметром -wi, DIE отображаются со своими значениями. Параметр -wa показывает сокращения в разделе .debug_abbrev:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Содержимое раздела .debug_abbrev:</i></p><p height="1em" width="0pt"><i>Тег номера (0x0)</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>DW_TAG_compile_unit</i></p><p height="1em" width="0pt"><i>[имеет детей]</i></p><p height="1em" width="0pt"><i>DW_AT_производитель</i></p><p height="1em" width="0pt"><i>DW_FORM_strp</i></p><p height="1em" width="0pt"><i>DW_AT_language</i></p><p height="1em" width="0pt"><i>DW_FORM_data1</i></p><p height="1em" width="0pt"><i>DW_AT_имя</i></p><p height="1em" width="0pt"><i>DW_FORM_strp</i></p><p height="1em" width="0pt"><i>DW_AT_comp_dir</i></p><p height="1em" width="0pt"><i>DW_FORM_strp</i></p><p height="1em" width="0pt"><i>проверка и отладка во время выполнения</i></p><p height="1em" width="0pt"><i>187</i></p><p height="1em" width="0pt"><i>DW_AT_low_pc</i></p><p height="1em" width="0pt"><i>DW_FORM_addr</i></p><p height="1em" width="0pt"><i>DW_AT_high_pc</i></p><p height="1em" width="0pt"><i>DW_FORM_data4</i></p><p height="1em" width="0pt"><i>DW_AT_stmt_list</i></p><p height="1em" width="0pt"><i>DW_FORM_sec_offset</i></p><p height="1em" width="0pt"><i>Значение DW_AT: 0</i></p><p height="1em" width="0pt"><i>Значение DW_FORM: 0</i></p><p height="1em" width="0pt"><i><b>.... другие сокращения ....</b></i></p><p height="1em" width="0pt"><i>Вывод похож на вывод DIE, только с именами атрибутов и без каких-либо значений. Мы также можем сказать, что аббревиатура является типом DIE, поскольку аббревиатура представляет собой структуру конкретного DIE. Многие DIE имеют одну и ту же аббревиатуру или структуру, поэтому они относятся к одному типу. Номер аббревиатуры указывает, к какому типу относится DIE в приведенной выше таблице сокращений. Аббревиатуры повышают эффективность кодирования (уменьшают размер двоичного кода), поскольку каждый DIE не должен нести информацию о своей структуре в виде пар атрибут-значение2, а просто ссылается 2 Например, на формат данных, такой как</i></p><p height="1em" width="0pt"><i>YAML или JSON кодирует свой атрибут</i></p><p height="1em" width="0pt"><i>к аббревиатуре для правильной расшифровки.</i></p><p height="1em" width="0pt"><i>имена вместе со своими значениями. Этот</i></p><p height="1em" width="0pt"><i>упрощает кодирование, но с накладными расходами.</i></p><p height="1em" width="0pt"><i>Вот все DIE приветствия, представленные в виде дерева: На рисунке</i><a href="#filepos566265"><i>6.4.4,</i></a><i>DW_TAG_subprogram представляет такую ​​функцию, как main. Его дочерние элементы — DIE argc и argv. С такой точной информацией сопоставление исходного кода с двоичным — простая задача для gdb.</i></p><p height="1em" width="0pt"><i>Если в исполняемом двоичном файле существует более одной единицы компиляции, записи DIE сортируются в соответствии с порядком компиляции из gcc. Например, предположим, что у нас есть еще один исходный файл test.c3, и мы скомпилируем его в файл-3. Он может содержать что угодно. Просто сам-</i></p><p height="1em" width="0pt"><i>пл файл.</i></p><p height="1em" width="0pt"><i>вместе с приветом:</i></p><p height="1em" width="0pt"><i>$ gcc -masm=intel -m32 -g test.c привет.c -о привет</i></p><p height="1em" width="0pt"><i>Затем все записи DIE в test.c отображаются перед записями DIE в hello.c:</i></p><p height="1em" width="0pt"><i><0><b>: Номер сокращения: 1 (DW_TAG_compile_unit)</i></p><p height="1em" width="0pt"><i><с></i></p><p height="1em" width="0pt"><i>DW_AT_производитель</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0x0): GNU C11 5.4.0 20160609</i></p><p height="1em" width="0pt"><i>-masm=intel -m32 -mtune=generic -march=i686 -g -fstack-protector-strong</i></p><p height="1em" width="0pt"><i><10></i></p><p height="1em" width="0pt"><i>DW_AT_language</i></p><p height="1em" width="0pt"><i>: 12</i></p><p height="1em" width="0pt"><i>(АНСИ С99)</i></p><a id="filepos566265" /><p height="1em" width="0pt"><i>188</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i><0><b>: Номер сокращения: 1 (DW_TAG_compile_unit)</i></p><p height="1em" width="0pt"><i><c> DW_AT_producer : (косвенная строка, смещение: 0xe): GNU C11</i></p><p height="1em" width="0pt"><i>5.4.0 20160609 -masm=intel -m32 -mtune=универсальный -march=i686 -g</i></p><p height="1em" width="0pt"><i>-fstack-протектор-сильный</i></p><p height="1em" width="0pt"><i><10> DW_AT_language : 12 (ANSI C99)</i></p><p height="1em" width="0pt"><i><11> DW_AT_name : (косвенная строка, смещение: 0xbe): hello.c</i></p><p height="1em" width="0pt"><i><15> DW_AT_comp_dir : (косвенная строка, смещение: 0x97): /tmp</i></p><p height="1em" width="0pt"><i><19> DW_AT_low_pc: 0x804840b</i></p><p height="1em" width="0pt"><i><1d> DW_AT_high_pc: 0x2e</i></p><p height="1em" width="0pt"><i><21> DW_AT_stmt_list: 0x0</i></p><p height="1em" width="0pt"><i><1><25>: Номер сокращения: 2 (DW_TAG_base_type)</i></p><p height="1em" width="0pt"><i><26> DW_AT_byte_size : 4</i></p><p height="1em" width="0pt"><i><27> DW_AT_encoding : 7 (без знака)</i></p><p height="1em" width="0pt"><i><28> DW_AT_name : (косвенная строка, смещение: 0x77): беззнаковое целое</i></p><p height="1em" width="0pt"><i><1><2c>: Номер сокращения: 2 (DW_TAG_base_type)</i></p><p height="1em" width="0pt"><i><2d> DW_AT_byte_size : 1</i></p><p height="1em" width="0pt"><i><2e> DW_AT_encoding : 8 (беззнаковый символ)</i></p><p height="1em" width="0pt"><i><2f> DW_AT_name : (косвенная строка, смещение: 0x84): беззнаковый символ</i></p><p height="1em" width="0pt"><i><1><33>: Номер сокращения: 2 (DW_TAG_base_type)</i></p><p height="1em" width="0pt"><i><34> DW_AT_byte_size : 2</i></p><p height="1em" width="0pt"><i><35> DW_AT_encoding : 7 (без знака)</i></p><p height="1em" width="0pt"><i><36> DW_AT_name : (косвенная строка, смещение: 0xa1): короткое целое без знака</i></p><p height="1em" width="0pt"><i><1><3a>: Номер сокращения: 2 (DW_TAG_base_type)</i></p><p height="1em" width="0pt"><i><3b> DW_AT_byte_size : 4</i></p><p height="1em" width="0pt"><i><3c> DW_AT_encoding : 7 (без знака)</i></p><p height="1em" width="0pt"><i><3d> DW_AT_name : (косвенная строка, смещение: 0x72): длинное целое без знака</i></p><p height="1em" width="0pt"><i>...................................много других записей базового типа . ...................</i></p><p height="1em" width="0pt"><i><1><7f>: Сокращенный номер: 5 (DW_TAG_subprogram)</i></p><p height="1em" width="0pt"><i><80> DW_AT_external : 1</i></p><p height="1em" width="0pt"><i><80> DW_AT_name : (косвенная строка, смещение: 0x92): main</i></p><p height="1em" width="0pt"><i><84> DW_AT_decl_file : 1</i></p><p height="1em" width="0pt"><i><85> DW_AT_decl_line : 3</i></p><p height="1em" width="0pt"><i><86> DW_AT_прототип: 1</i></p><p height="1em" width="0pt"><i><86> DW_AT_type : <0x4f></i></p><p height="1em" width="0pt"><i><8a> DW_AT_low_pc: 0x804840b</i></p><p height="1em" width="0pt"><i><8e> DW_AT_high_pc: 0x2e</i></p><p height="1em" width="0pt"><i><92> DW_AT_frame_base : 1-байтовый блок: 9c (DW_OP_call_frame_cfa)</i></p><p height="1em" width="0pt"><i><94> DW_AT_GNU_all_tail_call_sites: 1</i></p><p height="1em" width="0pt"><i><94> DW_AT_sibling : <0xb5></i></p><p height="1em" width="0pt"><i><2><98>: Номер сокращения: 6 (DW_TAG_formal_parameter)</i></p><p height="1em" width="0pt"><i><99> DW_AT_name : (косвенная строка, смещение: 0x9c): argc</i></p><p height="1em" width="0pt"><i><9d> DW_AT_decl_file : 1</i></p><p height="1em" width="0pt"><i><9e> DW_AT_decl_line : 3</i></p><p height="1em" width="0pt"><i><9f> DW_AT_type : <0x4f></i></p><p height="1em" width="0pt"><i><a3> DW_AT_location : 2-байтовый блок: 91 0 (DW_OP_fbreg: 0)</i></p><p height="1em" width="0pt"><i><2><a6>: Номер сокращения: 6 (DW_TAG_formal_parameter)</i></p><p height="1em" width="0pt"><i><a7> DW_AT_name : (косвенная строка, смещение: 0xcf): argv</i></p><p height="1em" width="0pt"><i><ab> DW_AT_decl_file : 1</i></p><p height="1em" width="0pt"><i><ac> DW_AT_decl_line : 3</i></p><p height="1em" width="0pt"><i><ad> DW_AT_type : <0xb5></i></p><p height="1em" width="0pt"><i><b1> DW_AT_location : 2-байтовый блок: 91 4 (DW_OP_fbreg: 4)</i><i><b>Рисунок 6.4.4:</b></i><i>Записи DIE визуализируются в виде дерева</i></p><p height="1em" width="0pt"><i>проверка и отладка во время выполнения</i></p><p height="1em" width="0pt"><i>189</i></p><p height="1em" width="0pt"><i><11></i></p><p height="1em" width="0pt"><i>DW_AT_имя</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0x64): test.c</i></p><p height="1em" width="0pt"><i><15></i></p><p height="1em" width="0pt"><i>DW_AT_comp_dir</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0x5f): /tmp</i></p><p height="1em" width="0pt"><i><19></i></p><p height="1em" width="0pt"><i>DW_AT_low_pc</i></p><p height="1em" width="0pt"><i>: 0x804840b</i></p><p height="1em" width="0pt"><i><1д></i></p><p height="1em" width="0pt"><i>DW_AT_high_pc</i></p><p height="1em" width="0pt"><i>: 0x6</i></p><p height="1em" width="0pt"><i><21></i></p><p height="1em" width="0pt"><i>DW_AT_stmt_list</i></p><p height="1em" width="0pt"><i>: 0x0</i></p><p height="1em" width="0pt"><i><1><25>: Сокращенный номер: 2 (DW_TAG_subprogram)</i></p><p height="1em" width="0pt"><i><26></i></p><p height="1em" width="0pt"><i>DW_AT_external</i></p><p height="1em" width="0pt"><i>: 1</i></p><p height="1em" width="0pt"><i><26></i></p><p height="1em" width="0pt"><i>DW_AT_имя</i></p><p height="1em" width="0pt"><i>: бар</i></p><p height="1em" width="0pt"><i><2а></i></p><p height="1em" width="0pt"><i>DW_AT_decl_file</i></p><p height="1em" width="0pt"><i>: 1</i></p><p height="1em" width="0pt"><i><2b></i></p><p height="1em" width="0pt"><i>DW_AT_decl_line</i></p><p height="1em" width="0pt"><i>: 1</i></p><p height="1em" width="0pt"><i><2с></i></p><p height="1em" width="0pt"><i>DW_AT_low_pc</i></p><p height="1em" width="0pt"><i>: 0x804840b</i></p><p height="1em" width="0pt"><i><30></i></p><p height="1em" width="0pt"><i>DW_AT_high_pc</i></p><p height="1em" width="0pt"><i>: 0x6</i></p><p height="1em" width="0pt"><i><34></i></p><p height="1em" width="0pt"><i>DW_AT_frame_base</i></p><p height="1em" width="0pt"><i>: 1-байтовый блок: 9c</i></p><p height="1em" width="0pt"><i>(DW_OP_call_frame_cfa)</i></p><p height="1em" width="0pt"><i><36></i></p><p height="1em" width="0pt"><i>DW_AT_GNU_all_call_sites: 1</i></p><p height="1em" width="0pt"><i><b>.... после того, как все DIE в test.c перечислены....</b></i></p><p height="1em" width="0pt"><i><0><42>: Номер сокращения: 1 (DW_TAG_compile_unit)</i></p><p height="1em" width="0pt"><i><43></i></p><p height="1em" width="0pt"><i>DW_AT_производитель</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0x0): GNU C11 5.4.0 20160609</i></p><p height="1em" width="0pt"><i>-masm=intel -m32 -mtune=generic -march=i686 -g -fstack-protector-strong</i></p><p height="1em" width="0pt"><i><47></i></p><p height="1em" width="0pt"><i>DW_AT_language</i></p><p height="1em" width="0pt"><i>: 12</i></p><p height="1em" width="0pt"><i>(АНСИ С99)</i></p><p height="1em" width="0pt"><i><48></i></p><p height="1em" width="0pt"><i>DW_AT_имя</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0xc5): hello.c</i></p><p height="1em" width="0pt"><i><4c></i></p><p height="1em" width="0pt"><i>DW_AT_comp_dir</i></p><p height="1em" width="0pt"><i>: (косвенная строка, смещение: 0x5f): /tmp</i></p><p height="1em" width="0pt"><i><50></i></p><p height="1em" width="0pt"><i>DW_AT_low_pc</i></p><p height="1em" width="0pt"><i>: 0x8048411</i></p><p height="1em" width="0pt"><i><54></i></p><p height="1em" width="0pt"><i>DW_AT_high_pc</i></p><p height="1em" width="0pt"><i>: 0x2e</i></p><p height="1em" width="0pt"><i><58></i></p><p height="1em" width="0pt"><i>DW_AT_stmt_list</i></p><p height="1em" width="0pt"><i>: 0x35</i></p><p height="1em" width="0pt"><i><b>....тогда перечисляются все DIE в hello.c....</b></i></p><p height="1em" width="0pt"><i> </i><a id="filepos574709" /><i><b>Часть II</b></i></p><p height="1em" width="0pt"><i><b>Фундамент</b></i></p><p height="1em" width="0pt"><i> </i><a id="filepos574833" /><i><b>7</b></i></p><p height="1em" width="0pt"><i>Загрузчик</i></p><p height="1em" width="0pt"><i>Загрузчик загружает ОС или приложение 1, которое запускается и общается-1 Многие встроенные устройства не используют</i></p><p height="1em" width="0pt"><i>ОС. Во встроенных системах</i></p><p height="1em" width="0pt"><i>напрямую с аппаратным обеспечением. Для запуска ОС первым делом нужно написать загрузчик просто включается в boot</i></p><p height="1em" width="0pt"><i>прошивка и загрузчик не нужен.</i></p><p height="1em" width="0pt"><i>загрузчик. В этой главе мы собираемся написать элементарный загрузчик, поскольку наша основная цель — написание операционной системы, а не загрузчика.</i></p><p height="1em" width="0pt"><i>Что еще более интересно, в этой главе будут представлены соответствующие инструменты и методы, применимые как для написания загрузчика, так и для операционной системы.</i></p><p height="1em" width="0pt"><i><b>7.1</b></i></p><p height="1em" width="0pt"><i><b>Процесс загрузки x86</b></i></p><p height="1em" width="0pt"><i>После завершения процесса POST программный счетчик ЦП устанавливается на адрес FFFF:0000h для выполнения кода BIOS. БИОС -</i><i><b>Б</b></i><i>асик</i><i><b>я</b></i><i>ввод/</i><i><b>О</b></i><i>выход</i></p><p height="1em" width="0pt"><i> </i><i><b>С</b></i><i>system — это прошивка, которая выполняет аппаратную инициализацию и предоставляет набор общих подпрограмм для управления устройствами ввода/вывода. БИОС</i></p><p height="1em" width="0pt"><i>проверяет все доступные устройства хранения (дискеты и жесткие диски), является ли какое-либо устройство загрузочным, проверяя последние два байта первого сектора на наличие подписи загрузочной записи 0x55, 0xAA. Если это так, то BIOS загружает первый сектор по адресу 7C00h, устанавливает программный счетчик на этот адрес и позволяет процессору выполнять код оттуда.</i></p><p height="1em" width="0pt"><i>Первый сектор называется</i><i><b>М</b></i><i>астра</i><i><b>Б</b></i><i>ой</i><i><b>р</b></i><i>запись или MBR. Программа в первом секторе называется MBR Bootloader.</i></p><a id="filepos576886" /><p height="1em" width="0pt"><i>194</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i><b>7.2</b></i></p><p height="1em" width="0pt"><i><b>Использование служб БИОС</b></i></p><p height="1em" width="0pt"><i>BIOS предоставляет множество базовых сервисов для управления оборудованием на этапе загрузки. Служба — это группа подпрограмм, которые управляют определенным аппаратным устройством или возвращают информацию о текущей системе. Каждой службе присваивается номер прерывания. Для вызова подпрограммы BIOS необходимо использовать инструкцию int с номером прерывания. Каждая служба BIOS определяет свои собственные номера для своих подпрограмм; для вызова подпрограммы в регистр, требуемый каждой службой, должно быть записано определенное число. Список всех прерываний BIOS доступен в списке прерываний Ральфа Брауна по адресу:</i><a href="http://www.cs.cmu.edu/~ralf/files.html"><i>http://www.cs.cmu.edu/</i></a></p><p height="1em" width="0pt"><a href="http://www.cs.cmu.edu/~ralf/files.html"><i>~ральф/файлы.html.</i></a></p><p height="1em" width="0pt"><i><b>Рисунок 7.2.1:</b></i><i>Процесс загрузки.</i></p><p height="1em" width="0pt"><i>БИОС</i></p><p height="1em" width="0pt"><i>Загрузчик</i></p><p height="1em" width="0pt"><i>Операционные системы</i></p><p height="1em" width="0pt"><i>Пример: вызов прерывания 13h (обслуживание дискеты) требует количество секторов для чтения, номер дорожки, номер сектора, номер головки и номер диска для чтения с устройства хранения. Содержимое сектора хранится в памяти по адресу, определяемому парой регистров ES:BX. Параметры хранятся в регистрах следующим образом:</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>; Сохранить содержимое сектора в буфере 10FF:0000</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i><b>мов дх</b></i><i>, 10FFч</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i><b>движение</b></i><i>,</i><i><b>дх</b></i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i><b>xor bx</b></i><i>,</i><i><b>бх</b></i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i><b>двигаться аль</b></i><i>, 2 ; читать 2 сектора</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i><b>мов ч</b></i><i>, 0 ; читать трек 0</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i><b>мов кл</b></i><i>, 2 ; 2-й сектор читается</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i><b>мов дх</b></i><i>, 0 ; главный номер</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i><b>мов дл</b></i><i>, 0 ; номер привода. Диск 0 — это дисковод для гибких дисков.</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i><b>мов ах</b></i><i>, 0x02 ; функция чтения сектора дискеты 11</i></p><p height="1em" width="0pt"><i><b>инт</b></i><i>0x13 ; вызов биоса - прочитать сектор</i></p><p height="1em" width="0pt"><i>BIOS доступен только в реальном режиме. Однако при переходе в защищенный режим BIOS больше нельзя будет использовать, и</i></p><a id="filepos579975" /><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>195</i></p><p height="1em" width="0pt"><i>Системный код отвечает за управление аппаратными устройствами. Это когда операционная система стоит сама по себе: она должна предоставлять свои собственные драйверы ядра для взаимодействия с оборудованием.</i></p><p height="1em" width="0pt"><i><b>7.3</b></i></p><p height="1em" width="0pt"><i><b>Процесс загрузки</b></i></p><p height="1em" width="0pt"><i>1. BIOS передает управление загрузчику MBR путем перехода к адресу 0000:7c00h, где предполагается, что загрузчик уже существует.</i></p><p height="1em" width="0pt"><i>2. Настройте среду компьютера для загрузки, правильно инициализировав сегментные регистры, чтобы включить модель плоской памяти.</i></p><p height="1em" width="0pt"><i>3. Загрузите ядро:</i></p><p height="1em" width="0pt"><i>(a) Чтение ядра с диска.</i></p><p height="1em" width="0pt"><i>(b) Сохраните его где-нибудь в основной памяти.</i></p><p height="1em" width="0pt"><i>(c) Перейти к начальному кодовому адресу ядра и выполнить.</i></p><p height="1em" width="0pt"><i>4. Если возникает ошибка, напечатайте сообщение, чтобы уведомить пользователей о том, что что-то пошло не так, и остановитесь.</i></p><p height="1em" width="0pt"><i><b>7.4</b></i></p><p height="1em" width="0pt"><i><b>Пример загрузчика</b></i></p><p height="1em" width="0pt"><i>Вот простой загрузчик, который ничего не делает, кроме того, что не приводит к сбою машины, а изящно останавливает ее. Если виртуальная машина не останавливается, а текст постоянно мигает, это означает, что загрузчик загружается неправильно, и машина вышла из строя. Машина вышла из строя, потому что она продолжает выполняться до конца физической памяти (1 МБ в реальном режиме), то есть FFFF: 0000h, что запускает весь процесс загрузки BIOS заново.</i></p><p height="1em" width="0pt"><i>Фактически это сброс, но не полный, поскольку компьютерная среда предыдущего запуска все еще зарезервирована. По этой причине это называется «теплой перезагрузкой».</i></p><p height="1em" width="0pt"><i>Противоположностью «горячей» перезагрузке является «холодная» перезагрузка, при которой среда компьютера сбрасывается до первоначальных настроек, когда компьютер запускается из обесточенного состояния.</i></p><p height="1em" width="0pt"><i>загрузчик.asm</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>;*********************************************</i></p><a id="filepos582270" /><p height="1em" width="0pt"><i>196</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>; загрузчик.asm</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>; Простой загрузчик</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>;*********************************************</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i><b>организация</b></i><i>0x7c00</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>бит 16</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>начинать:</i><i><b>джмп</b></i><i>ботинок</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>;; постоянные и переменные определения</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i>сообщение</i><i><b>дБ</b></i><i>«Добро пожаловать в мою операционную систему!», 0</i><i><b>ах</b></i><i>, 0</i><i><b>дх</b></i><i>, 0ч 11</i></p><p height="1em" width="0pt"><i>12</i></p><p height="1em" width="0pt"><i>ботинок:</i></p><p height="1em" width="0pt"><i>13</i></p><p height="1em" width="0pt"><i><b>Кли</b></i><i>; без прерываний</i></p><p height="1em" width="0pt"><i>14</i></p><p height="1em" width="0pt"><i><b>cld</b></i><i>; все, что нам нужно для инициализации</i></p><p height="1em" width="0pt"><i>15</i></p><p height="1em" width="0pt"><i><b>hlt</b></i><i>; остановить систему</i></p><p height="1em" width="0pt"><i>16</i></p><p height="1em" width="0pt"><i>17</i></p><p height="1em" width="0pt"><i>; У нас должно быть 512 байт. Очистить остальные байты с помощью 0</i></p><p height="1em" width="0pt"><i>18</i></p><p height="1em" width="0pt"><i>раз 510 - ($-$$)</i><i><b>дБ</b></i><i>0</i></p><p height="1em" width="0pt"><i>19</i></p><p height="1em" width="0pt"><i><b>дв</b></i><i>0xAA55</i></p><p height="1em" width="0pt"><i>; Загрузочная подпись</i></p><p height="1em" width="0pt"><i><b>7,5</b></i></p><p height="1em" width="0pt"><i><b>Скомпилируйте и загрузите</b></i></p><p height="1em" width="0pt"><i>Компилируем код с помощью nasm и записываем в образ диска: $ nasm -f bin bootloader.asm -o bootloader</i></p><p height="1em" width="0pt"><i>Затем мы создаем дискету объемом 1,4 МБ и:</i></p><p height="1em" width="0pt"><i>$ dd if=/dev/zero of=disk.img bs=512 count=2880</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>2880+0 записей в</i></p><p height="1em" width="0pt"><i>2880+0 записей</i></p><p height="1em" width="0pt"><i>1474560 байт (1,5 МБ, 1,4 МБ) скопировано, 0,00625622 с, 236 МБ/с</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>197</i></p><p height="1em" width="0pt"><i>Затем записываем загрузчик в 1-й сектор:</i></p><p height="1em" width="0pt"><i>$ dd conv=notrunc if=загрузчик=disk.img bs=512</i></p><p height="1em" width="0pt"><i>количество = 1 поиск = 0</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>1+0 записей в</i></p><p height="1em" width="0pt"><i>1+0 записей</i></p><p height="1em" width="0pt"><i>Скопировано 512 байт, 0,000102708 с, 5,0 МБ/с</i></p><p height="1em" width="0pt"><i>Опция conv=notrunc сохраняет исходный размер дискеты.</i></p><p height="1em" width="0pt"><i>Без этой опции образ диска размером 1,4 МБ будет полностью заменен новым disk.img размером всего 512 байт, а мы не хотим, чтобы это произошло.</i></p><p height="1em" width="0pt"><i>В прошлом разработка операционной системы была сложной, потому что программисту нужно было разбираться в конкретном аппаратном обеспечении, которое он использует. Несмотря на то, что x86 был повсеместным, незначительные различия между моделями приводили к тому, что некоторый код, написанный для одной машины, не работал на другой. Кроме того, если вы используете тот же физический компьютер, на котором вы пишете, ваша операционная система занимает очень много времени между запусками, а также ее трудно отлаживать. К счастью, сегодня мы можем единообразно создать виртуальную машину с определенной спецификацией и полностью избежать проблемы несовместимости, что упрощает написание и тестирование ОС, поскольку каждый может воспроизвести одну и ту же машинную среду.</i></p><p height="1em" width="0pt"><i>Мы будем использовать QEMU, универсальный эмулятор машин и виртуализатор с открытым исходным кодом. QEMU может эмулировать различные типы машин, не ограничиваясь только x86_64. Отладка проста, поскольку вы можете подключить GDB к виртуальной машине для отладки кода, который на ней выполняется, через встроенный в QEMU сервер GDB. QEMU может использовать disk.img в качестве загрузочного устройства, например. дискета: $ qemu-system-i386 -machine q35 -fda disk.img -gdb</i></p><p height="1em" width="0pt"><i>TCP:: 26000 -S</i></p><p height="1em" width="0pt"><i>С опцией -machine q35 QEMU эмулирует модель машины q35 от Intel.2.</i></p><p height="1em" width="0pt"><i>2 Следующая команда выводит список всех</i></p><p height="1em" width="0pt"><i>поддерживаемые эмулированные машины от</i></p><p height="1em" width="0pt"><i>QEMU:</i></p><p height="1em" width="0pt"><i>qemu-system-i386 -машинная помощь</i></p><p height="1em" width="0pt"><i>198</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>С опцией -fda disk.img QEMU использует disk.img как образ дискеты.</i></p><p height="1em" width="0pt"><i>С опцией -gdb tcp::26000 QEMU позволяет gdb подключаться к виртуальной машине для удаленной отладки через сокет tcp с портом 26000.</i></p><p height="1em" width="0pt"><i>С опцией -S QEMU ожидает подключения gdb перед запуском.</i></p><p height="1em" width="0pt"><i>После выполнения команды появится новое окно консоли, отображающее вывод экрана виртуальной машины. Откройте другой терминал, запустите gdb и установите текущую архитектуру на i8086, так как мы работаем в 16-битном режиме:</i></p><p height="1em" width="0pt"><i>(gdb) установить архитектуру i8086</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>предупреждение: обработчик для OS ABI "GNU/Linux" не встроен в эту конфигурацию GDB. Попытка продолжить с настройками i8086 по умолчанию.</i></p><p height="1em" width="0pt"><i>Предполагается, что целевой архитектурой является i8086.</i></p><p height="1em" width="0pt"><i>Затем подключите gdb к ожидающей виртуальной машине с помощью этой команды: (gdb) target remote localhost:26000</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Удаленная отладка с использованием localhost:26000</i></p><p height="1em" width="0pt"><i>0x0000fff0 в ?? ()</i></p><p height="1em" width="0pt"><i>Затем поставьте точку останова на 0x7c00:</i></p><p height="1em" width="0pt"><i>(гдб) б *0x7c00</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Точка останова 1 на 0x7c00</i></p><p height="1em" width="0pt"><i>Обратите внимание на звездочку перед адресом памяти. Без звездочки gdb обрабатывает адрес как символ в программе, а не как адрес.</i></p><p height="1em" width="0pt"><img align="baseline" height="990" src="Images/image00234.jpeg" width="1264"></img></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>199</i></p><p height="1em" width="0pt"><i>Затем для удобства используем разделенную верстку для просмотра ассемблерного кода и регистров вместе:</i></p><p height="1em" width="0pt"><i>(gdb) компоновка asm</i></p><p height="1em" width="0pt"><i>(gdb) раскладка reg</i></p><p height="1em" width="0pt"><i>Наконец, запустите программу:</i></p><p height="1em" width="0pt"><i>(гдб) с</i></p><p height="1em" width="0pt"><i>Если виртуальная машина успешно запускает загрузчик, экран QEMU должен выглядеть следующим образом:</i></p><p height="1em" width="0pt"><i><b>Рисунок 7.5.1:</b></i><i>Загрузка прошла успешно.</i></p><p height="1em" width="0pt"><i>7.5.1 Отладка</i></p><p height="1em" width="0pt"><i>Если по какой-то причине образец загрузчика не может попасть на такой экран и gdb не останавливается на 0x7c00, то вероятны следующие сценарии: Загрузчик недействителен: при загрузке с дискеты появляется сообщение «Boot failed: not a bootable disk». . Убедитесь, что загрузочная подпись находится в последних 2 байтах 512-байтового первого сектора.</i></p><p height="1em" width="0pt"><i>200</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>Машина не может найти загрузочный диск: при загрузке с дискеты появляется сообщение «Boot failed: not a bootable disk». Убедитесь, что загрузчик правильно записан в первый сектор. В этом можно убедиться, проверив диск с помощью hd:</i></p><p height="1em" width="0pt"><i>$ жесткий диск.img | меньше</i></p><p height="1em" width="0pt"><i>Если первые 512 байт все нули, то, скорее всего, загрузчик неправильно записал в другой сектор.</i></p><p height="1em" width="0pt"><i>Машина выходит из строя: когда происходит такой сценарий, она возвращается к началу в FFFF: 0000h. Если машина QEMU запускается, не дожидаясь gdb, то окно вывода консоли продолжает мигать, поскольку машина неоднократно перезагружается. Вероятно, какая-то инструкция в коде загрузчика вызывает ошибку.</i></p><p height="1em" width="0pt"><i><b>Упражнение 7.5.1.</b></i><i>Распечатать приветственное сообщение</i></p><p height="1em" width="0pt"><i>Мы успешно загрузили загрузчик. Но ему нужно сделать что-то полезное, кроме остановки нашей машины. Проще всего напечатать что-нибудь на экране, например, введение во все языки программирования начинается с «Hello World». Наш загрузчик печатает «Добро пожаловать в мою операционную систему»3. В этой части мы создадим простую библиотеку ввода-вывода 3 или любое другое сообщение, которое вы хотите.</i></p><p height="1em" width="0pt"><i>что позволяет нам устанавливать курсор в любом месте экрана и печатать там текст.</i></p><p height="1em" width="0pt"><i>Сначала создайте файл</i><i><b>io.asm</b></i><i>для подпрограмм, связанных с вводом-выводом. Затем напишите следующие подпрограммы:</i></p><p height="1em" width="0pt"><i>1. МовКурсор</i></p><p height="1em" width="0pt"><i><b>Цель:</b></i><i>Переместите курсор в определенное место на экране и запомните это место.</i></p><p height="1em" width="0pt"><i><b>Параметры:</b></i></p><p height="1em" width="0pt"><i>bh = координата Y</i></p><p height="1em" width="0pt"><i>bl = координата X.</i></p><p height="1em" width="0pt"><i><b>Возвращаться:</b></i><i>Никто</i></p><a id="filepos592594" /><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>201</i></p><p height="1em" width="0pt"><i>2. Поместите чар</i></p><p height="1em" width="0pt"><i><b>Цель:</b></i><i>Напечатайте символ на экране в позиции курсора, ранее установленной MovCursor.</i></p><p height="1em" width="0pt"><i><b>Параметры:</b></i></p><p height="1em" width="0pt"><i>al = символ для печати</i></p><p height="1em" width="0pt"><i>bl = цвет текста</i></p><p height="1em" width="0pt"><i>cx = количество повторений символа</i></p><p height="1em" width="0pt"><i>Возврат: Нет</i></p><p height="1em" width="0pt"><i>3. Печать</i></p><p height="1em" width="0pt"><i><b>Цель:</b></i><i>Распечатать строку.</i></p><p height="1em" width="0pt"><i><b>Параметры:</b></i></p><p height="1em" width="0pt"><i>ds:si = строка с нулевым завершением</i></p><p height="1em" width="0pt"><i>Возврат: Нет</i></p><p height="1em" width="0pt"><i>Протестируйте подпрограммы, поместив каждую в исходный код загрузчика, скомпилируйте и запустите. Для отладки запустите GDB и установите точку останова в определенной подпрограмме. Конечным результатом является то, что Print должен отображать приветственное сообщение на экране.</i></p><p height="1em" width="0pt"><i><b>7.6</b></i></p><p height="1em" width="0pt"><i><b>Загрузка программы из загрузчика</b></i></p><p height="1em" width="0pt"><i>Теперь, когда мы получили представление о том, как использовать службы BIOS, пришло время для чего-то более сложного. Мы разместим наше ядро ​​на 2-м секторе и далее, и наш загрузчик читает 30 секторов, начиная со 2-го сектора. Почему 30 секторов? Наше ядро ​​будет расти постепенно, поэтому мы сохраним 30 секторов и сэкономим время на изменение загрузчика каждый раз, когда размер ядра увеличивается еще на один сектор.</i></p><p height="1em" width="0pt"><i>Основной обязанностью загрузчика является чтение операционной системы с какого-либо устройства хранения, например. жесткий диск, затем загружает его в оперативную память и передает управление загруженной операционной системе аналогично</i></p><a id="filepos594548" /><p height="1em" width="0pt"><i>202</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>как BIOS читает и загружает загрузчик. На данный момент наш загрузчик не что иное, как программа сборки, загружаемая биосом. Чтобы наш загрузчик стал настоящим, он должен хорошо выполнять две вышеуказанные задачи: читать и загружать операционную систему.</i></p><p height="1em" width="0pt"><i>7.6.1 Структура гибкого диска</i></p><p height="1em" width="0pt"><i>Чтобы читать с устройства хранения, мы должны понимать, как работает устройство, и предоставленный интерфейс для управления им. Во-первых, дискета — это запоминающее устройство, похожее на оперативную память, но способное хранить информацию даже при выключенном компьютере, поэтому называется постоянным запоминающим устройством. дискета</i></p><p height="1em" width="0pt"><i> </i><i><b>постоянное запоминающее устройство</b></i></p><p height="1em" width="0pt"><i>диск также является постоянным запоминающим устройством, поэтому он обеспечивает пространство для хранения до 1,4 МБ или 1 474 560 байт. При чтении с гибкого диска наименьшая единица, которую можно прочитать, — это сектор, группа из 512 смежных байтов. Группа из 18 секторов представляет собой дорожку. Каждая сторона гибкого диска состоит из 80</i></p><p height="1em" width="0pt"><i><b>Рисунок 7.6.1:</b></i><i>Сектор и трек.</i></p><p height="1em" width="0pt"><i>треки. Для чтения дискет требуется дисковод. Внутри гибкого трека</i></p><p height="1em" width="0pt"><i>привод содержит руку с 2 головками, каждая головка читает сторону гибкого сектора</i></p><p height="1em" width="0pt"><i>водить машину; головка 0 записывает верхнюю сторону, а головка 1 записывает нижнюю сторону гибкого диска.</i></p><p height="1em" width="0pt"><i>Когда дисковод записывает данные на новую дискету, дорожка 0</i></p><p height="1em" width="0pt"><i>на верхней стороне записывается первой головкой 0. Когда верхняя дорожка 0 заполнена, нижняя дорожка 0 используется головкой 1. Когда и верхняя, и нижняя стороны дорожки 0 заполнены, она возвращается к головке 0. для повторной записи данных, но на этот раз верхней стороны дорожки 1 и так далее, пока не останется свободного места</i><i><b>Рисунок 7.6.2:</b></i><i>Тарелка для гибких дисков</i></p><p height="1em" width="0pt"><i>Устройство. Та же процедура применяется и для чтения данных с дискеты с 2-х сторон.</i></p><p height="1em" width="0pt"><i>диск.</i></p><p height="1em" width="0pt"><i>Голова 0</i></p><p height="1em" width="0pt"><i>7.6.2 Чтение и загрузка секторов с дискеты</i></p><p height="1em" width="0pt"><i>Во-первых, нам нужен образец программы для записи во 2-й сектор, чтобы мы могли поэкспериментировать с чтением дискеты:</i></p><p height="1em" width="0pt"><i>Глава 1</i></p><p height="1em" width="0pt"><i>образец.asm</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>;*********************************************</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>; образец.asm</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>; Пример программы</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>203</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>;*********************************************</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i><b>движение eax</b></i><i>, 1</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i><b>добавить eax</b></i><i>, 1</i></p><p height="1em" width="0pt"><i>Такой программы достаточно. Для упрощения и в целях демонстрации мы будем использовать ту же дискету, на которой находится загрузчик, для хранения нашей операционной системы. Образ операционной системы начинается со 2-го сектора, так как 1-й сектор уже используется загрузчиком. Компилируем и пишем во 2-й сектор с dd:</i></p><p height="1em" width="0pt"><i>$ nasm -f бин образец.asm -o образец</i></p><p height="1em" width="0pt"><i>$ dd if=sample of=disk.img bs=512 count=1 seek=1</i></p><p height="1em" width="0pt"><i><b>1</b></i><i>ул.</i><i><b>сектор</b></i></p><p height="1em" width="0pt"><i><b>2</b></i><i>й</i><i><b>сектор</b></i></p><p height="1em" width="0pt"><i>.....</i></p><p height="1em" width="0pt"><i><b>30</b></i><i>й</i><i><b>сектор</b></i></p><p height="1em" width="0pt"><i><b>Рисунок 7.6.3:</b></i><i>Загрузчик и</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>образец</i></p><p height="1em" width="0pt"><i>....</i></p><p height="1em" width="0pt"><i>(пустой)</i></p><p height="1em" width="0pt"><i>образец программы на дискете.</i></p><p height="1em" width="0pt"><i>Далее нам нужно поправить загрузчик для чтения с дискеты и загрузить некоторое количество произвольных секторов. Прежде чем сделать это, необходимо иметь общее представление о гибком диске. Чтобы прочитать данные с диска, прерывание 13</i></p><p height="1em" width="0pt"><i>с AH = 02 — процедура чтения секторов с диска в память: AH = 02</i></p><p height="1em" width="0pt"><i>AL = количество секторов для чтения (1-128 дес.)</i></p><p height="1em" width="0pt"><i>CH = номер дорожки/цилиндра (0-1023 дес., см. ниже)</i></p><p height="1em" width="0pt"><i>CL = номер сектора (1-17 дес.)</i></p><p height="1em" width="0pt"><i>DH = номер головы (0-15 уб.)</i></p><p height="1em" width="0pt"><i>DL = номер диска (0=A:, 1=2-я дискета, 80h=диск 0, 81h=диск 1) ES:BX = указатель на буфер</i></p><p height="1em" width="0pt"><i>Возвращаться:</i></p><p height="1em" width="0pt"><i>AH = статус (см. INT 13, STATUS)</i></p><p height="1em" width="0pt"><i>AL = количество прочитанных секторов</i></p><p height="1em" width="0pt"><i>CF = 0 в случае успеха</i></p><p height="1em" width="0pt"><i>= 1, если ошибка</i></p><p height="1em" width="0pt"><i>Примените описанную выше процедуру, загрузчик сможет прочитать 2-й сектор:</i></p><p height="1em" width="0pt"><i>204</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>загрузчик.asm</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>;*********************************************</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>; Загрузчик.asm</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>; Простой загрузчик</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>;*********************************************</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i><b>организация</b></i><i>0x7c00</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>бит 16</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>начинать:</i><i><b>джмп</b></i><i>ботинок</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>;; постоянные и переменные определения</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i>сообщение</i><i><b>дБ</b></i><i>«Добро пожаловать в мою операционную систему!», 0</i><i><b>ах</b></i><i>, 0</i><i><b>дх</b></i><i>, 0ч 11</i></p><p height="1em" width="0pt"><i>12</i></p><p height="1em" width="0pt"><i>ботинок:</i></p><p height="1em" width="0pt"><i>13</i></p><p height="1em" width="0pt"><i><b>Кли</b></i><i>; без прерываний</i></p><p height="1em" width="0pt"><i>14</i></p><p height="1em" width="0pt"><i><b>cld</b></i><i>; все, что нам нужно для инициализации</i></p><p height="1em" width="0pt"><i>15</i></p><p height="1em" width="0pt"><i>16</i></p><p height="1em" width="0pt"><i><b>движущийся топор</b></i><i>, 0x50</i></p><p height="1em" width="0pt"><i>17</i></p><p height="1em" width="0pt"><i>18</i></p><p height="1em" width="0pt"><i>;; установить буфер</i></p><p height="1em" width="0pt"><i>19</i></p><p height="1em" width="0pt"><i><b>движение</b></i><i>,</i><i><b>топор</b></i></p><p height="1em" width="0pt"><i>20</i></p><p height="1em" width="0pt"><i><b>xor bx</b></i><i>,</i><i><b>бх</b></i></p><p height="1em" width="0pt"><i>21</i></p><p height="1em" width="0pt"><i>22</i></p><p height="1em" width="0pt"><i><b>двигаться аль</b></i><i>, 2</i></p><p height="1em" width="0pt"><i>; читать 2 сектора</i></p><p height="1em" width="0pt"><i>23</i></p><p height="1em" width="0pt"><i><b>мов ч</b></i><i>, 0</i></p><p height="1em" width="0pt"><i>; трек 0</i></p><p height="1em" width="0pt"><i>24</i></p><p height="1em" width="0pt"><i><b>мов кл</b></i><i>, 2</i></p><p height="1em" width="0pt"><i>; сектор для чтения (второй сектор)</i></p><p height="1em" width="0pt"><i>25</i></p><p height="1em" width="0pt"><i><b>мов дх</b></i><i>, 0</i></p><p height="1em" width="0pt"><i>; главный номер</i></p><p height="1em" width="0pt"><i>26</i></p><p height="1em" width="0pt"><i><b>мов дл</b></i><i>, 0</i></p><p height="1em" width="0pt"><i>; номер диска</i></p><p height="1em" width="0pt"><i>27</i></p><p height="1em" width="0pt"><i>28</i></p><p height="1em" width="0pt"><i><b>мов ах</b></i><i>, 0x02</i></p><p height="1em" width="0pt"><i>; чтение секторов с диска</i></p><p height="1em" width="0pt"><i>29</i></p><p height="1em" width="0pt"><i><b>инт</b></i><i>0x13</i></p><p height="1em" width="0pt"><i>; вызвать процедуру BIOS</i></p><p height="1em" width="0pt"><i>30</i></p><p height="1em" width="0pt"><i><b>джмп</b></i><i>0x50:0x0</i></p><p height="1em" width="0pt"><i>; прыгай и выполняй сектор!</i></p><p height="1em" width="0pt"><i>31</i></p><p height="1em" width="0pt"><i>32</i></p><p height="1em" width="0pt"><i><b>hlt</b></i><i>; остановить систему</i></p><p height="1em" width="0pt"><i>33</i></p><p height="1em" width="0pt"><i>34</i></p><p height="1em" width="0pt"><i>; У нас должно быть 512 байт. Очистить остальные байты</i></p><a id="filepos604179" /><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>205</i></p><p height="1em" width="0pt"><i>с 0</i></p><p height="1em" width="0pt"><i>35</i></p><p height="1em" width="0pt"><i>раз 510 - ($-$$)</i><i><b>дБ</b></i><i>0</i></p><p height="1em" width="0pt"><i>36</i></p><p height="1em" width="0pt"><i><b>дв</b></i><i>0xAA55</i></p><p height="1em" width="0pt"><i>; Загрузочная подпись</i></p><p height="1em" width="0pt"><i>Приведенный выше код переходит к адресу 0x50:00 (то есть 0x500). Чтобы протестировать код, загрузите его на виртуальную машину QEMU и подключитесь через gdb, затем поставьте точку останова на 0x500. Если gdb останавливается по адресу, при этом в листинге сборки тот же код, что и в sample.asm, то загрузчик успешно загрузил программу. Это важная веха, так как мы гарантируем, что наша операционная система загружается и работает правильно.</i></p><p height="1em" width="0pt"><i><b>7.7</b></i></p><p height="1em" width="0pt"><i><b>Повысьте производительность с помощью скриптов</b></i></p><p height="1em" width="0pt"><i>7.7.1 Автоматизация сборки с помощью GNU Make</i></p><p height="1em" width="0pt"><i>До этого момента весь процесс разработки казался повторяющимся: всякий раз, когда вносятся изменения, одни и те же команды вводятся снова. Команды тоже сложные. Ctrl+r помогает, но все равно утомительно.</i></p><p height="1em" width="0pt"><i><b>Сделать GNU</b></i><i>это программа, которая контролирует и автоматизирует процесс создания сложного программного обеспечения. Для небольшой программы, такой как один исходный файл C, вызов gcc выполняется быстро и легко. Однако вскоре ваше программное обеспечение станет более сложным, когда несколько каталогов охватывают несколько каталогов, поэтому вручную создавать и связывать файлы становится рутинной работой. Чтобы решить эту проблему, был создан инструмент для автоматизации этой проблемы, который называется системой сборки. ГНУ</i></p><p height="1em" width="0pt"><i>Make является одним из таких инструментов. Существуют различные системы сборки, но GNU Make является самой популярной в мире Linux, поскольку она используется для сборки ядра Linux.</i></p><p height="1em" width="0pt"><i>Подробное введение в make см. в официальном руководстве Introduction to Make:</i><a href="https://www.gnu.org/software/make/manual/html_node/Introduction.html#Introduction"><i>https://www.gnu.org/software/make/manual/</i></a></p><p height="1em" width="0pt"><a href="https://www.gnu.org/software/make/manual/html_node/Introduction.html#Introduction"><i>html_node/Introduction.html#Introduction.</i></a><i>И этого достаточно для нашего проекта. Вы также можете скачать руководство в различных форматах, например.</i></p><p height="1em" width="0pt"><i>PDF с официальной страницы руководства:</i><a href="https://www.gnu.org/software/make/manual/"><i>https://www.gnu.org/software/</i></a></p><p height="1em" width="0pt"><a href="https://www.gnu.org/software/make/manual/"><i>сделать/ручной/</i></a><i>.</i></p><p height="1em" width="0pt"><i>С помощью Makefile мы можем создавать более простые команды и экономить время:</i></p><p height="1em" width="0pt"><i>206</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>все: загрузочный диск</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>загрузчик:</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>nasm -f bin bootloader.asm -o bootloader.o</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>ядро:</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>nasm -f бин образец.asm -o образец.о</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>загрузочный диск: bootloader.o ядро.o</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i>dd if=/dev/zero of=disk.img bs=512 count=2880</i></p><p height="1em" width="0pt"><i>11</i></p><p height="1em" width="0pt"><i>dd conv=notrunc if=bootloader.o of=disk.img bs=512</i></p><p height="1em" width="0pt"><i>количество = 1 поиск = 0</i></p><p height="1em" width="0pt"><i>12</i></p><p height="1em" width="0pt"><i>dd conv=notrunc if=sample.o of=disk.img bs=512 count=1</i></p><p height="1em" width="0pt"><i>искать=1</i></p><p height="1em" width="0pt"><i>Теперь с помощью одной команды мы можем создать от начала до конца образ диска с загрузчиком в 1-м секторе и программой-примером во 2-м секторе: $ make bootdisk</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>nasm -f bin bootloader.asm -o bootloader.o</i></p><p height="1em" width="0pt"><i>nasm -f bin sample.asm -o bootloader.o</i></p><p height="1em" width="0pt"><i>dd if=/dev/zero of=disk.img bs=512 count=2880</i></p><p height="1em" width="0pt"><i>2880+0 записей в</i></p><p height="1em" width="0pt"><i>2880+0 записей</i></p><p height="1em" width="0pt"><i>скопировано 1474560 байт (1,5 МБ, 1,4 МБ), 0,00482188 с, 306 МБ/с dd conv=notrunc if=bootloader.o of=disk.img bs=512 count=1 seek=0</i></p><p height="1em" width="0pt"><i>0+1 записей в</i></p><p height="1em" width="0pt"><i>0+1 записей</i></p><p height="1em" width="0pt"><i>Скопировано 10 байт, 7.0316e-05 с, 142 кБ/с</i></p><p height="1em" width="0pt"><i>dd conv=notrunc if=sample.o of=disk.img bs=512 count=1 seek=1</i></p><p height="1em" width="0pt"><i>0+1 записей в</i></p><p height="1em" width="0pt"><i>0+1 записей</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>207</i></p><p height="1em" width="0pt"><i>Скопировано 10 байт, 0,000208375 с, 48,0 кБ/с</i></p><p height="1em" width="0pt"><i>Глядя на Makefile, мы видим несколько проблем:</i></p><p height="1em" width="0pt"><i>Во-первых, имя disk.img повсюду. Когда мы хотим изменить имя образа диска, например. floppy_disk.img, все места с названием disk.img надо менять вручную. Чтобы решить эту проблему, мы используем переменную, и каждое появление disk.img заменяется ссылкой на переменную. Таким образом, изменяется только одно место — определение переменной — все остальные места обновляются автоматически. Добавляются следующие переменные:</i></p><p height="1em" width="0pt"><i>ЗАГРУЗЧИК=bootloader.o</i></p><p height="1em" width="0pt"><i>ОС=sample.o</i></p><p height="1em" width="0pt"><i>DISK_IMG=disk.img.o</i></p><p height="1em" width="0pt"><i>Вторая проблема заключается в том, что имя загрузчика и образца появляется как часть имен файлов исходных файлов, например. bootloader.asm и sample.asm, а также имена двоичных файлов, например. загрузчик и пример.</i></p><p height="1em" width="0pt"><i>Подобно disk.img, при изменении имени каждая ссылка на это имя также должна быть изменена вручную как для имен исходных файлов, так и для имен двоичных файлов, например. если мы изменим bootloader.asm на loader.asm, то объектный файл bootloader.o нужно изменить на loader.o. Чтобы решить эту проблему, вместо того, чтобы менять имена файлов вручную, мы создаем правило, которое автоматически генерирует имена файлов одного расширения на другое.</i></p><p height="1em" width="0pt"><i>В этом случае мы хотим, чтобы любой исходный файл, который начинается с .asm, имел свои эквивалентные двоичные файлы без каких-либо расширений, например. bootloader.asm → bootloader.o.</i></p><p height="1em" width="0pt"><i>Такое преобразование распространено, поэтому GNU Make предоставляет встроенные функции: wildcard и patsubst для решения таких проблем: BOOTLOADER_SRCS := $(</i><i><b>подстановочный знак</b></i><i>*.как м)</i></p><p height="1em" width="0pt"><i>BOOTLOADER_OBJS := $(</i><i><b>патсубст</b></i><i>%.asm, %.o, $(BOOTLOADER_SRCS</i></p><p height="1em" width="0pt"><i>))</i></p><p height="1em" width="0pt"><i>подстановочный знак соответствует любому файлу .asm в текущем каталоге, а затем присваивает список соответствующих файлов переменной BOOTLOADER_SRCS. В этом случае BOOTLOADER_SRCS присваивается значение:</i></p><p height="1em" width="0pt"><i>208</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>загрузчик.asm образец.asm</i></p><p height="1em" width="0pt"><i>patsubst заменяет любое имя файла, начинающееся с .asm, на имя файла .o, например bootloader.asm → bootloader.o. После запуска patsubsts мы получаем список объектных файлов в BOOTLOADER_OBJS:</i></p><p height="1em" width="0pt"><i>bootloader.o образец.o</i></p><p height="1em" width="0pt"><i>Наконец, нужен рецепт сборки из .asm в .o:</i></p><p height="1em" width="0pt"><i>%.о: %.асм</i></p><p height="1em" width="0pt"><i>nasm -f бин $< -o</i><i><b>$@</b></i></p><p height="1em" width="0pt"><i>$< — это специальная переменная, которая ссылается на ввод рецепта: %.asm.</i></p><p height="1em" width="0pt"><i>$@ — это специальная переменная, которая относится к выходным данным рецепта: %.o.</i></p><p height="1em" width="0pt"><i>При выполнении рецепта переменные заменяются фактическими значениями. Например, если преобразование bootloader.asm → bootloader.o, то фактическая команда, выполняемая при замене заполнителей в рецепте, будет следующей:</i></p><p height="1em" width="0pt"><i>nasm -f bin bootloader.asm -o bootloader.o</i></p><p height="1em" width="0pt"><i>Благодаря рецепту все файлы .asm автоматически создаются с помощью команды nasm в файлы .o, и нам больше не нужен отдельный рецепт для каждого объектного файла. Объединив все это с новыми переменными, мы получаем лучший Makefile:</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>ЗАГРУЗЧИК=bootloader.o</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>ОС=sample.o</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>DISK_IMG=диск.img</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i>BOOTLOADER_SRCS := $(</i><i><b>подстановочный знак</b></i><i>*.как м)</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>BOOTLOADER_OBJS := $(</i><i><b>патсубст</b></i><i>%.asm, %.o, $(BOOTLOADER_SRCS</i></p><p height="1em" width="0pt"><i>))</i></p><a id="filepos614340" /><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>209</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>все: загрузочный диск</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i>%.о: %.асм</i></p><p height="1em" width="0pt"><i>11</i></p><p height="1em" width="0pt"><i>nasm -f бин $< -o</i><i><b>$@</b></i></p><p height="1em" width="0pt"><i>12</i></p><p height="1em" width="0pt"><i>13</i></p><p height="1em" width="0pt"><i>загрузочный диск: $(BOOTLOADER_OBJS)</i></p><p height="1em" width="0pt"><i>14</i></p><p height="1em" width="0pt"><i>dd if=/dev/zero of=$(DISK_IMG) bs=512 count=2880</i></p><p height="1em" width="0pt"><i>15</i></p><p height="1em" width="0pt"><i>dd conv=notrunc if=$(BOOTLOADER) of=$(DISK_IMG) bs=512</i></p><p height="1em" width="0pt"><i>количество = 1 поиск = 0</i></p><p height="1em" width="0pt"><i>16</i></p><p height="1em" width="0pt"><i>dd conv=notrunc if=$(OS) of=$(DISK_IMG) bs=512 count=1</i></p><p height="1em" width="0pt"><i>искать=1</i></p><p height="1em" width="0pt"><i><b>Рисунок 7.7.1:</b></i><i>Лучшая планировка проекта-</i></p><p height="1em" width="0pt"><i>вне</i></p><p height="1em" width="0pt"><i>С этого момента любой файл .asm компилируется автоматически, без предварительной подготовки.</i></p><p height="1em" width="0pt"><i>.</i></p><p height="1em" width="0pt"><i>явный рецепт для каждого файла.</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>загрузчик.asm</i></p><p height="1em" width="0pt"><i>Объектные файлы находятся в том же каталоге, что и исходные файлы, поэтому Makefile</i></p><p height="1em" width="0pt"><i>это сложнее при работе с исходным деревом. В идеале объектные файлы создаются</i></p><p height="1em" width="0pt"><i>а исходные файлы должны находиться в разных каталогах. Хотим лучше или-бутлоадер</i></p><p height="1em" width="0pt"><i>загрузчик.o</i></p><p height="1em" width="0pt"><i>организованный макет каталога, как на рисунке</i><a href="#filepos614340"><i>7.7.1.</i></a></p><p height="1em" width="0pt"><i>диск.img</i></p><p height="1em" width="0pt"><i>Операционные системы</i></p><p height="1em" width="0pt"><i>каталог bootloader/ содержит исходные файлы загрузчика; os/ содержит oper-sample.o</i></p><p height="1em" width="0pt"><i>атирование системных исходных файлов, которые мы собираемся написать позже; построить/содержит Makefile</i></p><p height="1em" width="0pt"><i>объектные файлы для загрузчика, ОС и конечного образа диска ОС</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>диск.img. Обратите внимание, что каталог bootloader/ также имеет собственный Makefile.</i></p><p height="1em" width="0pt"><i>образец.asm</i></p><p height="1em" width="0pt"><i>Этот Makefile будет отвечать за сборку всего в bootloader/</i></p><p height="1em" width="0pt"><i>Макет может отображаться в виде дерева</i></p><p height="1em" width="0pt"><i>каталог, в то время как Makefile верхнего уровня освобождается от бремени команды сборки:</i></p><p height="1em" width="0pt"><i>$ дерево</i></p><p height="1em" width="0pt"><i>загрузчик, а только образ диска. Содержимое Makefile в каталоге bootloader/ должно быть:</i></p><p height="1em" width="0pt"><i>загрузчик/Makefile</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>BUILD_DIR=</i><i><b>../строить/</b></i><i>загрузчик</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>BOOTLOADER_SRCS := $(</i><i><b>подстановочный знак</b></i><i>*.как м)</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>BOOTLOADER_OBJS := $(</i><i><b>патсубст</b></i><i>%.asm, $(BUILD_DIR)/%.o, $(</i></p><p height="1em" width="0pt"><i>BOOTLOADER_SRCS))</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i>210</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>все: $(BOOTLOADER_OBJS)</i></p><p height="1em" width="0pt"><i><b>Рисунок 7.7.2:</b></i><i>Makefile в</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>загрузчик/</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>$(BUILD_DIR)/%.o: %.asm</i></p><p height="1em" width="0pt"><i>.</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>nasm -f бин $< -o</i><i><b>$@</b></i></p><p height="1em" width="0pt"><i>загрузчик.asm</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>строить</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>В основном все, что связано с загрузчиком в файле Makefile bootloader.o верхнего уровня.</i></p><p height="1em" width="0pt"><i>извлекаются в этот Makefile. Когда make запускает этот Makefile, bootloader.o disk.img</i></p><p height="1em" width="0pt"><i>должен быть собран и помещен в каталог ../build/. Как хорошая практика, ОС</i></p><p height="1em" width="0pt"><i>образец.o</i></p><p height="1em" width="0pt"><i>все ссылки на ../build/ проходят через переменную BUILD_DIR. Рецепт Makefile</i></p><p height="1em" width="0pt"><i>для преобразования из .asm → .o также обновляется с правильными путями, иначе os</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>он не будет работать.</i></p><p height="1em" width="0pt"><i>образец.asm</i></p><p height="1em" width="0pt"><i>%.asm относится к исходным файлам сборки в текущем каталоге.</i></p><p height="1em" width="0pt"><i>$(BUILD_DIR)/%.o относится к выходным объектным файлам в каталоге сборки по пути ../build/.</i></p><p height="1em" width="0pt"><i>Весь рецепт реализует преобразование из <source_file.asm></i><i><b>Рисунок 7.7.3:</b></i><i>Makefile в os/</i></p><p height="1em" width="0pt"><i>→ ../build/<object_file.o>. Обратите внимание, что все пути должны быть правильными. Если</i></p><p height="1em" width="0pt"><i>.</i></p><p height="1em" width="0pt"><i>мы пытаемся создать объектные файлы в другом каталоге, например. текущий каталог, загрузчик</i></p><p height="1em" width="0pt"><i>загрузчик.asm</i></p><p height="1em" width="0pt"><i>это не сработает, так как не существует такого рецепта для сборки объектов в таком Makefile</i></p><p height="1em" width="0pt"><i>путь.</i></p><p height="1em" width="0pt"><i>строить</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>Мы также создаем аналогичный Makefile для каталога os/:</i></p><p height="1em" width="0pt"><i>загрузчик.o</i></p><p height="1em" width="0pt"><i>диск.img</i></p><p height="1em" width="0pt"><i>Операционные системы</i></p><p height="1em" width="0pt"><i>ОС/Makefile</i></p><p height="1em" width="0pt"><i>образец.o</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>BUILD_DIR=../сборка/ОС</i></p><p height="1em" width="0pt"><i>Операционные системы</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>образец.asm</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>ОС_SRCS := $(</i><i><b>подстановочный знак</b></i><i>*.как м)</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>ОС_OBJS := $(</i><i><b>патсубст</b></i><i>%.asm, $(BUILD_DIR)/%.o, $(OS_SRCS)) 5</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>все: $(OS_OBJS)</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>$(BUILD_DIR)/%.o: %.asm</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>nasm -f бин $< -o</i><i><b>$@</b></i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>211</i></p><p height="1em" width="0pt"><i>На данный момент он выглядит почти так же, как Makefile для загрузчика. В</i><i><b>Рисунок 7.7.4:</b></i><i>Makefile верхнего уровня</i></p><p height="1em" width="0pt"><i>в следующей главе мы обновим его для кода C. Затем мы обновляем топ-</i></p><p height="1em" width="0pt"><i>.</i></p><p height="1em" width="0pt"><i>Makefile уровня:</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>загрузчик.asm</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>строить</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>BUILD_DIR=сборка</i></p><p height="1em" width="0pt"><i>загрузчик.o</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>BOOTLOADER=$(BUILD_DIR)/bootloader/bootloader.o</i></p><p height="1em" width="0pt"><i>диск.img</i></p><p height="1em" width="0pt"><i>Операционные системы</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>ОС=$(BUILD_DIR)/os/sample.o</i></p><p height="1em" width="0pt"><i>образец.o</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>DISK_IMG=диск.img</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i>Операционные системы</i></p><p height="1em" width="0pt"><i>Makefile</i></p><p height="1em" width="0pt"><i>6</i></p><p height="1em" width="0pt"><i>все: загрузочный диск</i></p><p height="1em" width="0pt"><i>образец.asm</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>.PHONY: ОС загрузчика загрузочного диска</i></p><p height="1em" width="0pt"><i>9</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i>загрузчик:</i></p><p height="1em" width="0pt"><i>11</i></p><p height="1em" width="0pt"><i>сделать -C загрузчик</i></p><p height="1em" width="0pt"><i>12</i></p><p height="1em" width="0pt"><i>13</i></p><p height="1em" width="0pt"><i>Операционные системы:</i></p><p height="1em" width="0pt"><i>14</i></p><p height="1em" width="0pt"><i>сделать -C ОС</i></p><p height="1em" width="0pt"><i>15</i></p><p height="1em" width="0pt"><i>16</i></p><p height="1em" width="0pt"><i>загрузочный диск: ОС загрузчика</i></p><p height="1em" width="0pt"><i>17</i></p><p height="1em" width="0pt"><i>dd if=/dev/zero of=$(DISK_IMG) bs=512 count=2880</i></p><p height="1em" width="0pt"><i>18</i></p><p height="1em" width="0pt"><i>dd conv=notrunc if=$(BOOTLOADER) of=$(DISK_IMG) bs=512</i></p><p height="1em" width="0pt"><i>количество = 1 поиск = 0</i></p><p height="1em" width="0pt"><i>19</i></p><p height="1em" width="0pt"><i>dd conv=notrunc if=$(OS) of=$(DISK_IMG) bs=512 count=1</i></p><p height="1em" width="0pt"><i>искать=1</i></p><p height="1em" width="0pt"><i>Процесс сборки теперь действительно модульный:</i></p><p height="1em" width="0pt"><i>Сборки загрузчика и ОС теперь делегированы в дочерний Makefile соответствующих компонентов. Опция -C указывает make выполняться с Makefile в указанном каталоге. В данном случае это каталоги bootloader/</i></p><p height="1em" width="0pt"><i>и ОС/.</i></p><p height="1em" width="0pt"><i>Целевой объект Makefile верхнего уровня отвечает только за целевой загрузочный диск, который является основным целевым объектом этого Makefile.</i></p><p height="1em" width="0pt"><i>212</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>Во многих случаях цель не всегда является именем файла, а просто именем рецепта, который всегда выполняется по запросу. Если имя файла совпадает с именем цели, и файл актуален, make не выполняет цель. Чтобы решить эту проблему, .PHONY указывает, что некоторые цели не являются файлами. Все фальшивые цели будут запускаться по запросу, независимо от файлов с одинаковыми именами.</i></p><p height="1em" width="0pt"><i>Чтобы сэкономить время на ввод команды для запуска виртуальной машины QEMU, мы также добавляем цель в Makefile верхнего уровня: qemu:</i></p><p height="1em" width="0pt"><i>qemu-system-i386 -machine q35 -fda $(DISK_IMG) -gdb TCP</i></p><p height="1em" width="0pt"><i>::26000 -С</i></p><p height="1em" width="0pt"><i>Последняя проблема — очистка проекта. На данный момент объектные файлы необходимо удалять вручную, и это повторяющийся процесс. Вместо этого пусть Makefile каждого компонента позаботится об очистке своих объектных файлов, а затем Makefile верхнего уровня выполнит очистку проекта, вызывая компонент Makefile для выполнения заданий. Каждый Makefile добавляется с чистой целью в конце: Makefile загрузчика:</i></p><p height="1em" width="0pt"><i>чистый:</i></p><p height="1em" width="0pt"><i>рм $(BUILD_DIR)/*</i></p><p height="1em" width="0pt"><i>Makefile ОС:</i></p><p height="1em" width="0pt"><i>чистый:</i></p><p height="1em" width="0pt"><i>рм $(BUILD_DIR)/*</i></p><p height="1em" width="0pt"><i>Makefile верхнего уровня:</i></p><p height="1em" width="0pt"><i>чистый:</i></p><p height="1em" width="0pt"><i>очистить загрузчик -C</i></p><p height="1em" width="0pt"><i>сделать -C ОС чистой</i></p><p height="1em" width="0pt"><i>Просто запустив make clean в корне проекта, все объектные файлы будут удалены.</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>213</i></p><p height="1em" width="0pt"><i>7.7.2 Обзор синтаксиса GNU Make</i></p><p height="1em" width="0pt"><i>GNU Make по своей сути является предметно-ориентированным языком для автоматизации сборки. Как и любому языку программирования, ему нужен способ определения данных и кода. В Makefile переменные несут данные. Значение переменной либо жестко закодировано, либо оценивается при вызове оболочки, такой как Bash. Все значения переменных в Make имеют один и тот же тип: строка текста. Число 3 — это не число, а текстовое представление символа 3. Вот распространенные способы определения данных в Makefile:</i></p><p height="1em" width="0pt"><i><b>Синтаксис</b></i></p><p height="1em" width="0pt"><i><b>Описание</b></i></p><p height="1em" width="0pt"><i>А = 1</i></p><p height="1em" width="0pt"><i>Объявите переменную и присвойте ей текстовое значение.</i></p><p height="1em" width="0pt"><i>В = 2</i></p><p height="1em" width="0pt"><i>двойной знак доллара $$ означает закрывающий</i></p><p height="1em" width="0pt"><i>C = $$(выражение $(A) + $(B))</i></p><p height="1em" width="0pt"><i>выражение, вычисляемое оболочкой, определенное в /bin/sh.</i></p><p height="1em" width="0pt"><i>⇒ А равно 1, В равно 2, С равно 3.</i></p><p height="1em" width="0pt"><i>В этом случае объемлющее выражение имеет вид (expr $(A)</i></p><p height="1em" width="0pt"><i>+ $(B)) и оценивается Bash.</i></p><p height="1em" width="0pt"><i>ПУТЬ = /bin</i></p><p height="1em" width="0pt"><i>Объявите переменную и присвойте ей. Однако</i></p><p height="1em" width="0pt"><i>ПУТЬ:= $ПУТЬ:/usr/bin</i></p><p height="1em" width="0pt"><i>разница в том, что синтаксис = не позволяет ссылаться</i></p><p height="1em" width="0pt"><i>⇒ ПУТЬ: /bin/:/usr/bin</i></p><p height="1em" width="0pt"><i>в переменную, чтобы использовать себя в качестве значения в правом</i></p><p height="1em" width="0pt"><i>стороны, в то время как этот синтаксис делает.</i></p><p height="1em" width="0pt"><i>ПУТЬ = /bin</i></p><p height="1em" width="0pt"><i>Добавить новое значение в конец переменной.</i></p><p height="1em" width="0pt"><i>ПУТЬ += /usr/bin</i></p><p height="1em" width="0pt"><i>Эквивалентно:</i></p><p height="1em" width="0pt"><i>⇒ ПУТЬ: /bin/:/usr/bin</i></p><p height="1em" width="0pt"><i>ПУТЬ:= $ПУТЬ:/usr/bin</i></p><p height="1em" width="0pt"><i>CFLAGS ?= -o</i></p><p height="1em" width="0pt"><i>Этот синтаксис называется</i><i><b>условная ссылка</b></i><i>. Установить</i></p><p height="1em" width="0pt"><i>⇒ CFLAGS присваивается значение -o, если оно было</i></p><p height="1em" width="0pt"><i>переменная в значение, если оно не определено. Это полезно, не определено.</i></p><p height="1em" width="0pt"><i>если пользователь хочет указать другое значение для</i></p><p height="1em" width="0pt"><i>переменная из командной строки, например. добавить отладку</i></p><p height="1em" width="0pt"><i>опция CFLAGS. В противном случае Make использует значение по умолчанию.</i></p><p height="1em" width="0pt"><i>определяется ?=.</i></p><a id="filepos630447" /><p height="1em" width="0pt"><i>214</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>SRCS = lib1.c lib2.c main.c</i></p><p height="1em" width="0pt"><i>Этот синтаксис называется</i><i><b>ссылка на замену</b></i><i>. OBJS := $(SRC:.o=.c)</i></p><p height="1em" width="0pt"><i>часть ссылочной переменной заменяется на</i></p><p height="1em" width="0pt"><i>⇒ OBJS имеет значение lib1.o lib2.o</i></p><p height="1em" width="0pt"><i>что-то другое. В этом случае все расширения .c — это main.o.</i></p><p height="1em" width="0pt"><i>заменяется расширением .o, таким образом создавая список</i></p><p height="1em" width="0pt"><i>объектные файлы для переменной OBJS из списка исходных файлов из переменной SRCS.</i></p><p height="1em" width="0pt"><i>Код в GNU Make — это набор рецептов, которые он может запускать. Каждый рецепт аналогичен функции в языке программирования и может вызываться как обычная функция. Каждый рецепт содержит ряд команд оболочки, которые должны быть выполнены оболочкой, например. Баш. Рецепт имеет следующий формат: цель: предпосылки</i></p><p height="1em" width="0pt"><i>команда</i></p><p height="1em" width="0pt"><i>Каждая цель аналогична имени функции. Каждая предпосылка является вызовом другой цели. Каждая команда является одной из встроенных команд Make или командой, исполняемой оболочкой. Все предварительные условия должны быть выполнены перед входом в основную часть цели; то есть каждое предварительное условие не должно возвращать никаких ошибок. Если возвращается какая-либо ошибка, Make завершает весь процесс сборки и выводит сообщение об ошибке в командной строке.</i></p><p height="1em" width="0pt"><i>Каждый раз, когда make запускается, по умолчанию, если цель не указана, она начинается со всей цели, проходит через все предварительные условия и, наконец, все тело.</i></p><p height="1em" width="0pt"><i>все аналогично main в других языках программирования. Однако, если make задана цель, она запустится с этой цели, а не с main. Эта функция полезна для автоматизации нескольких аспектов проекта. Например, одна цель предназначена для создания проекта, другая цель — для создания документов, например. отчеты о тестировании, еще одна цель для запуска всего набора тестов и всех прогонов всех основных целей.</i></p><p height="1em" width="0pt"><i>7.7.3 Автоматизация шагов отладки с помощью скрипта GDB</i></p><p height="1em" width="0pt"><i>Для удобства мы сохраняем конфигурацию GDB в файл .gdbinit в корневом каталоге проекта. Эта конфигурация представляет собой просто набор команд GDB и несколько дополнительных команд. Когда gdb запускается, он сначала загружает .gdbinit</i></p><p height="1em" width="0pt"><i>загрузчик</i></p><p height="1em" width="0pt"><i>215</i></p><p height="1em" width="0pt"><i>файл в домашнем каталоге, затем файл .gdbinit в текущем каталоге. Почему мы не должны помещать команды в ~/.gdbinit? Поскольку эти команды относятся только к этому проекту, например. не все программы требуют удаленного подключения.</i></p><p height="1em" width="0pt"><i>Наша первая конфигурация:</i></p><p height="1em" width="0pt"><i>.gdbinit</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>определить хук-стоп</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i># Преобразование сегмента: смещение в физический адрес 3</i></p><p height="1em" width="0pt"><i><b>printf</b></i><i>"[%4x:%4x] ", $cs, $eip</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>x/i $cs*16+$eip</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i>конец</i></p><p height="1em" width="0pt"><i>Приведенный выше скрипт отображает адрес памяти в [segment:offset]</i></p><p height="1em" width="0pt"><i>формат, необходимый для отладки кода нашего загрузчика и операционной системы.</i></p><p height="1em" width="0pt"><i>Лучше использовать синтаксис Intel:</i></p><p height="1em" width="0pt"><i>установить вкус разборки intel</i></p><p height="1em" width="0pt"><i>Следующие команды задают более удобную компоновку для отладки ассемблерного кода:</i></p><p height="1em" width="0pt"><i>сборка макета</i></p><p height="1em" width="0pt"><i>макет reg</i></p><p height="1em" width="0pt"><i>В настоящее время мы отлаживаем код загрузчика, поэтому рекомендуется сначала установить его на 16-битный:</i></p><p height="1em" width="0pt"><i>установить архитектуру i8086</i></p><p height="1em" width="0pt"><i>Каждый раз, когда запускается виртуальная машина QEMU, gdb всегда должен подключаться к порту 26000. Чтобы избежать проблем с подключением к виртуальной машине вручную, добавьте команду:</i></p><p height="1em" width="0pt"><i>целевой удаленный локальный хост: 26000</i></p><p height="1em" width="0pt"><i>216</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>Для отладки загрузчика нужна точка останова по адресу 0x7c00, где начинается наш код загрузчика:</i></p><p height="1em" width="0pt"><i>б *0x7c00</i></p><p height="1em" width="0pt"><i>Теперь всякий раз, когда gdb запускается, он автоматически устанавливает правильную архитектуру на основе кода, автоматически подключается к виртуальной машине4, отображает out-4. Виртуальная машина QEMU должна</i></p><p height="1em" width="0pt"><i>уже были запущены до начала-</i></p><p height="1em" width="0pt"><i>сделать удобную раскладку и установить необходимую точку останова. Все, что нужно для gdb.</i></p><p height="1em" width="0pt"><i>сделать, это запустить программу.</i></p><a id="filepos635813" /><p height="1em" width="0pt"><i><b>8</b></i></p><p height="1em" width="0pt"><i>Связывание и загрузка на голое железо</i></p><p height="1em" width="0pt"><i>Перемещение — это процесс замены ссылок на символы их реальными.</i></p><p height="1em" width="0pt"><i> </i><i><b>Переезд</b></i></p><p height="1em" width="0pt"><i>символические определения в объектном файле. Ссылка на символ — это адрес памяти символа.</i></p><p height="1em" width="0pt"><i>Если определение трудно понять, рассмотрите похожую аналогию: переезд дома. Предположим, что программист купил новый дом, и этот новый дом пуст. Он должен покупать мебель и бытовую технику для удовлетворения повседневных потребностей, поэтому он составил список предметов, которые нужно купить, и где их разместить. Чтобы визуализировать размещение новых предметов, он рисует план дома и соответствующие места для всех предметов. Затем он ходит в магазины, чтобы купить товары. Всякий раз, когда он посещает магазин и видит совпадающие предметы, он говорит владельцу магазина записать их. Сделав выбор, он говорит владельцу магазина забрать новый товар вместо выставленных предметов, а затем указать адрес доставки товара в его новый дом. Наконец, когда товары прибывают, он размещает их там, где планировал вначале.</i></p><p height="1em" width="0pt"><i>Теперь, когда перемещение дома понятно, перемещение объектов аналогично: список предметов представляет собой таблицу перемещений, где заранее определено место в памяти для каждого символа (предмета).</i></p><p height="1em" width="0pt"><i>Каждый элемент представляет собой пару определения символа и его адреса символа.</i></p><p height="1em" width="0pt"><i>Каждый магазин представляет собой скомпилированный объектный файл.</i></p><a id="filepos637501" /><p height="1em" width="0pt"><i>218</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>Каждый отображаемый элемент представляет собой определение символа и ссылки в объектном файле.</i></p><p height="1em" width="0pt"><i>Новый адрес, по которому доставляются все товары, представляет собой окончательный исполняемый двоичный файл или окончательный объектный файл. Поскольку выставленные товары не продаются, владелец магазина вместо этого доставляет совершенно новые товары.</i></p><p height="1em" width="0pt"><i>Точно так же объектные файлы не объединяются вместе, а копируются в новый файл, объектный/исполняемый файл.</i></p><p height="1em" width="0pt"><i>Наконец, товары расставляются по позициям в соответствии со списком покупок, составленным с самого начала. Точно так же определения символов размещаются соответствующим образом в соответствующем разделе, а ссылки на символы в конечном объектном/исполняемом файле заменяются фактическими адресами памяти определений символов.</i></p><p height="1em" width="0pt"><i><b>8.1</b></i></p><p height="1em" width="0pt"><i><b>Понимание переездов с readelf</b></i></p><p height="1em" width="0pt"><i>Ранее, когда мы исследовали разделы объектов, существовали разделы, начинающиеся с .rel. Эти разделы представляют собой таблицы перемещений, которые сопоставляют символ и его положение в конечном объектном файле или в окончательном исполняемом двоичном файле1.</i></p><p height="1em" width="0pt"><i>1 Раздел .rel эквивалентен списку</i></p><p height="1em" width="0pt"><i>предметов в доме аналогии.</i></p><p height="1em" width="0pt"><i>Предположим, что функция foo определена в другом объектном файле, поэтому main.c объявляет ее как extern:</i></p><p height="1em" width="0pt"><i>main.c</i></p><p height="1em" width="0pt"><i><b>инт</b></i><i>я;</i></p><p height="1em" width="0pt"><i><b>пустота</b></i><i>Фу();</i></p><p height="1em" width="0pt"><i><b>инт</b></i><i>основной(</i><i><b>инт</b></i><i>аргк,</i><i><b>уголь</b></i><i>*argv[])</i></p><p height="1em" width="0pt"><i>{</i></p><p height="1em" width="0pt"><i>я = 5;</i></p><p height="1em" width="0pt"><i>Фу();</i></p><p height="1em" width="0pt"><i><b>возвращаться</b></i><i>0;</i></p><p height="1em" width="0pt"><i>}</i></p><p height="1em" width="0pt"><i><b>пустота</b></i><i>Фу () {}</i></p><p height="1em" width="0pt"><i>Когда мы компилируем main.c как объектный файл с помощью этой команды:</i></p><p height="1em" width="0pt"><i>линковка и загрузка на голое железо</i></p><p height="1em" width="0pt"><i>219</i></p><p height="1em" width="0pt"><i>$ gcc -m32 -masm=intel -c main.c</i></p><p height="1em" width="0pt"><i>Затем мы можем проверить таблицы перемещений с помощью этой команды: $ readelf -r main.o</i></p><p height="1em" width="0pt"><i>Выход:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Раздел перемещения '.rel.text' по смещению 0x1cc содержит 2 записи: Смещение</i></p><p height="1em" width="0pt"><i>Информация</i></p><p height="1em" width="0pt"><i>Тип</i></p><p height="1em" width="0pt"><i>Сим.значение</i></p><p height="1em" width="0pt"><i>Сим. Имя</i></p><p height="1em" width="0pt"><i>00000013</i></p><p height="1em" width="0pt"><i>00000801 Р_386_32</i></p><p height="1em" width="0pt"><i>00000004</i></p><p height="1em" width="0pt"><i>я</i></p><p height="1em" width="0pt"><i>0000001c</i></p><p height="1em" width="0pt"><i>00000a02 R_386_PC32</i></p><p height="1em" width="0pt"><i>0000002e</i></p><p height="1em" width="0pt"><i>фу</i></p><p height="1em" width="0pt"><i>Раздел перемещения '.rel.eh_frame' по смещению 0x1dc содержит 2 записи: Смещение</i></p><p height="1em" width="0pt"><i>Информация</i></p><p height="1em" width="0pt"><i>Тип</i></p><p height="1em" width="0pt"><i>Сим.значение</i></p><p height="1em" width="0pt"><i>Сим. Имя</i></p><p height="1em" width="0pt"><i>00000020</i></p><p height="1em" width="0pt"><i>00000202 R_386_PC32</i></p><p height="1em" width="0pt"><i>00000000</i></p><p height="1em" width="0pt"><i>.текст</i></p><p height="1em" width="0pt"><i>0000004с</i></p><p height="1em" width="0pt"><i>00000202 R_386_PC32</i></p><p height="1em" width="0pt"><i>00000000</i></p><p height="1em" width="0pt"><i>.текст</i></p><p height="1em" width="0pt"><i>8.1.1 Смещение</i></p><p height="1em" width="0pt"><i>Смещение — это место в разделе двоичного файла, где фактическое</i></p><p height="1em" width="0pt"><i> </i><i><b>компенсировать</b></i></p><p height="1em" width="0pt"><i>адрес памяти определения символа заменяется. Раздел с префиксом .rel определяет, в какой раздел следует выполнить смещение. Например, .rel.text — это таблица перемещений символов, адрес которых нужно исправить в секции .text, по определенному смещению в секцию .text. В выводе примера:</i><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>0000001c</i></p><p height="1em" width="0pt"><i>00000a02 R_386_PC32</i></p><p height="1em" width="0pt"><i>0000002e</i></p><p height="1em" width="0pt"><i>фу</i></p><p height="1em" width="0pt"><i>Синее число указывает на то, что существует ссылка на символ foo, который находится в 1c байтах в разделе .text. Чтобы было понятнее, перекомпилируем main.c с опцией -g в файл main_debug.o, затем запустим на нем objdump и получим:</i><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Разборка раздела .text:</i></p><p height="1em" width="0pt"><i>00000000 <основной>:</i></p><p height="1em" width="0pt"><i>инт я;</i></p><p height="1em" width="0pt"><i>недействительный фу();</i></p><p height="1em" width="0pt"><i>220</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>int main(int argc, char *argv[])</i></p><p height="1em" width="0pt"><i>{</i></p><p height="1em" width="0pt"><i>0:</i></p><p height="1em" width="0pt"><i>8д 4с 24 04</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>еккс,[esp+0x4]</i></p><p height="1em" width="0pt"><i>4:</i></p><p height="1em" width="0pt"><i>83 e4 f0</i></p><p height="1em" width="0pt"><i>и</i></p><p height="1em" width="0pt"><i>esp, 0xffffffff0</i></p><p height="1em" width="0pt"><i>7:</i></p><p height="1em" width="0pt"><i>фф 71 фк</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>Двойное слово PTR [ecx-0x4]</i></p><p height="1em" width="0pt"><i>а:</i></p><p height="1em" width="0pt"><i>55</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>б:</i></p><p height="1em" width="0pt"><i>89 e5</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>е.и.п., особенно</i></p><p height="1em" width="0pt"><i>д:</i></p><p height="1em" width="0pt"><i>51</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ecx</i></p><p height="1em" width="0pt"><i>е:</i></p><p height="1em" width="0pt"><i>83 эк 04</i></p><p height="1em" width="0pt"><i>суб</i></p><p height="1em" width="0pt"><i>особенно, 0x4</i></p><p height="1em" width="0pt"><i>я = 5;</i></p><p height="1em" width="0pt"><i>11:</i></p><p height="1em" width="0pt"><i>с7 05 00 00 00 00 05</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>DWORD PTR ds:0x0,0x5</i></p><p height="1em" width="0pt"><i>18:</i></p><p height="1em" width="0pt"><i>00 00 00</i></p><p height="1em" width="0pt"><i>Фу();</i></p><p height="1em" width="0pt"><i>1б:</i></p><p height="1em" width="0pt"><i>e8 fc ff ff ff</i></p><p height="1em" width="0pt"><i>вызов</i></p><p height="1em" width="0pt"><i>1c <основной+0x1c></i></p><p height="1em" width="0pt"><i>вернуть 0;</i></p><p height="1em" width="0pt"><i>20:</i></p><p height="1em" width="0pt"><i>б8 00 00 00 00</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>еакс, 0x0</i></p><p height="1em" width="0pt"><i>}</i></p><p height="1em" width="0pt"><i>25:</i></p><p height="1em" width="0pt"><i>83 с4 04</i></p><p height="1em" width="0pt"><i>добавлять</i></p><p height="1em" width="0pt"><i>особенно, 0x4</i></p><p height="1em" width="0pt"><i>28:</i></p><p height="1em" width="0pt"><i>59</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ecx</i></p><p height="1em" width="0pt"><i>29:</i></p><p height="1em" width="0pt"><i>5д</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>2а:</i></p><p height="1em" width="0pt"><i>8д 61 фк</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>особенно, [ecx-0x4]</i></p><p height="1em" width="0pt"><i>2д:</i></p><p height="1em" width="0pt"><i>с3</i></p><p height="1em" width="0pt"><i>рет</i></p><p height="1em" width="0pt"><i>....не относящееся к делу содержание опущено....</i></p><p height="1em" width="0pt"><i>Байт 1b — это код операции e8, инструкция вызова; байт в 1c является значением fc. Почему значение операнда для e8 равно 0xffffffffc, что эквивалентно -4, а преобразованный вызов инструкции равен 1c? Это будет объяснено после еще нескольких разделов, но вы должны сделать паузу и немного подумать о причине.</i></p><p height="1em" width="0pt"><i>8.1.2 Информация</i></p><p height="1em" width="0pt"><i>Информация определяет индекс символа в таблице символов и тип выполняемого перемещения.</i></p><p height="1em" width="0pt"><i>линковка и загрузка на голое железо</i></p><p height="1em" width="0pt"><i>221</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>0000001c</i></p><p height="1em" width="0pt"><i>00000a02 R_386_PC32</i></p><p height="1em" width="0pt"><i>0000002e</i></p><p height="1em" width="0pt"><i>фу</i></p><p height="1em" width="0pt"><i>Розовое число — это индекс символа foo в таблице символов, а зеленое число — тип перемещения. Числа записываются в шестнадцатеричном формате. В примере 0a означает 10 в десятичном виде, а символ foo действительно имеет индекс 10:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>10: 0000002e</i></p><p height="1em" width="0pt"><i>6 ФУНКЦИИ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>1 фу</i></p><p height="1em" width="0pt"><i>8.1.3 Тип</i></p><p height="1em" width="0pt"><i>Тип представляет значение типа в текстовой форме. Глядя на тип foo:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>0000001c</i></p><p height="1em" width="0pt"><i>00000a02 R_386_PC32</i></p><p height="1em" width="0pt"><i>0000002e</i></p><p height="1em" width="0pt"><i>фу</i></p><p height="1em" width="0pt"><i>Зеленый номер — это тип в числовой форме, а R_386_PC32 — это имя, присвоенное этому значению. Каждое значение представляет метод расчета перемещения. Например, с типом R_386_PC32 для перемещения применяется следующая формула (Inteli386 psABI):</i></p><p height="1em" width="0pt"><i>Перемещенный набор f = S + A - P</i></p><p height="1em" width="0pt"><i>Чтобы понять формулу, необходимо понимать значения символов.</i></p><p height="1em" width="0pt"><i>8.1.4 Симметричное значение</i></p><p height="1em" width="0pt"><i>В этом поле отображается значение символа. Значение символа — это значение, присвоенное символу, значение которого зависит от поля Ndx:</i></p><p height="1em" width="0pt"><i>Символ с индексом раздела COMMON , его значение символа содержит ограничения выравнивания.</i></p><p height="1em" width="0pt"><i><b>Пример 8.1.1.</b></i><i>В таблице символов переменная i обозначена как COM (неинициализированная переменная):2</i></p><p height="1em" width="0pt"><i>2 Символ списка команд</i></p><p height="1em" width="0pt"><i>таблица (предположим, что объектный файл</i></p><p height="1em" width="0pt"><i>привет.о):</i></p><p height="1em" width="0pt"><i>readelf -s привет.о</i></p><p height="1em" width="0pt"><i>222</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Таблица символов '.symtab' содержит 16 записей:</i></p><p height="1em" width="0pt"><i>Номер:</i></p><p height="1em" width="0pt"><i>Ценить</i></p><p height="1em" width="0pt"><i>Размер Тип</i></p><p height="1em" width="0pt"><i>Связывать</i></p><p height="1em" width="0pt"><i>Вис</i></p><p height="1em" width="0pt"><i>Имя NDX</i></p><p height="1em" width="0pt"><i>0: 00000000</i></p><p height="1em" width="0pt"><i>0 НЕТИП</i></p><p height="1em" width="0pt"><i>МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>UND</i></p><p height="1em" width="0pt"><i>1: 00000000</i></p><p height="1em" width="0pt"><i>0 ФАЙЛ</i></p><p height="1em" width="0pt"><i>МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>АБС hello2.c</i></p><p height="1em" width="0pt"><i>2: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>3: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>4: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>5: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>5</i></p><p height="1em" width="0pt"><i>6: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>7</i></p><p height="1em" width="0pt"><i>7: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>8</i></p><p height="1em" width="0pt"><i>8: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>10</i></p><p height="1em" width="0pt"><i>9: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>12</i></p><p height="1em" width="0pt"><i>10: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>14</i></p><p height="1em" width="0pt"><i>11:00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>15</i></p><p height="1em" width="0pt"><i>12: 00000000</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>13</i></p><p height="1em" width="0pt"><i>13: 00000004</i></p><p height="1em" width="0pt"><i>4 ОБЪЕКТ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>COM я</i></p><p height="1em" width="0pt"><i>14: 00000000</i></p><p height="1em" width="0pt"><i>46 ФУНКЦ.</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>1 основной</i></p><p height="1em" width="0pt"><i>15: 0000002e</i></p><p height="1em" width="0pt"><i>6 ФУНКЦИИ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>1 фу</i></p><p height="1em" width="0pt"><i>поэтому его символьное значение является выравниванием памяти для назначения правильного адреса памяти, который соответствует выравниванию в конечном адресе памяти. В случае i значение равно 4, поэтому начальный адрес памяти i в конечном двоичном файле будет кратен 4.</i></p><p height="1em" width="0pt"><i>Символ, Ndx которого идентифицирует определенный раздел, его значение символа содержит смещение раздела.</i></p><p height="1em" width="0pt"><i><b>Пример 8.1.2.</b></i><i>В таблице символов main и foo относятся к разделу 1:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>14: 00000000</i></p><p height="1em" width="0pt"><i>46 ФУНКЦ.</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>1 основной</i></p><p height="1em" width="0pt"><i>15: 0000002e</i></p><p height="1em" width="0pt"><i>6 ФУНКЦИИ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>1 фу</i></p><p height="1em" width="0pt"><i>который является .text3 section4:</i></p><p height="1em" width="0pt"><i>3 .text содержит программный код и считывается</i></p><p height="1em" width="0pt"><i>только данные.</i></p><p height="1em" width="0pt"><i>4 Команда для просмотра разделов</i></p><p height="1em" width="0pt"><i>(предположим, что объектный файл — hello.o):</i></p><p height="1em" width="0pt"><i>readelf -S привет.о</i></p><p height="1em" width="0pt"><i>линковка и загрузка на голое железо</i></p><p height="1em" width="0pt"><i>223</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Имеется 20 заголовков разделов, начиная со смещения 0x558: Заголовки разделов:</i></p><p height="1em" width="0pt"><i>[№] Имя</i></p><p height="1em" width="0pt"><i>Тип</i></p><p height="1em" width="0pt"><i>Адрес</i></p><p height="1em" width="0pt"><i>Выключенный</i></p><p height="1em" width="0pt"><i>Размер</i></p><p height="1em" width="0pt"><i>ES Flg Lk Inf Al</i></p><p height="1em" width="0pt"><i>[ 0]</i></p><p height="1em" width="0pt"><i>НУЛЕВОЙ</i></p><p height="1em" width="0pt"><i>00000000 000000 000000 00</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>[ 1] .текст</i></p><p height="1em" width="0pt"><i>PROGBITS</i></p><p height="1em" width="0pt"><i>00000000 000034 000034 00</i></p><p height="1em" width="0pt"><i>ТОПОР</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>[ 2] .отн.текст</i></p><p height="1em" width="0pt"><i>ОТНОС</i></p><p height="1em" width="0pt"><i>00000000 000414 000010 08</i></p><p height="1em" width="0pt"><i>мне 18</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>4</i></p><p height="1em" width="0pt"><i>[ 3] .данные</i></p><p height="1em" width="0pt"><i>PROGBITS</i></p><p height="1em" width="0pt"><i>00000000 000068 000000 00</i></p><p height="1em" width="0pt"><i>Вашингтон</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>[ 4 ] .bss</i></p><p height="1em" width="0pt"><i>НОБИТЫ</i></p><p height="1em" width="0pt"><i>00000000 000068 000000 00</i></p><p height="1em" width="0pt"><i>Вашингтон</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>[ 5] .debug_info</i></p><p height="1em" width="0pt"><i>PROGBITS</i></p><p height="1em" width="0pt"><i>00000000 000068 000096 00</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>0</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>..... остальные выходные данные опущены для ясности....</i></p><p height="1em" width="0pt"><i>В окончательных исполняемых и совместно используемых объектных файлах вместо указанных выше значений значение символа содержит адрес памяти.</i></p><p height="1em" width="0pt"><i><b>Пример 8.1.3.</b></i><i>После компиляции hello.o в окончательный исполняемый файл hello таблица символов теперь содержит адрес памяти для каждого символа5: 5 Команда для компиляции объекта</i></p><p height="1em" width="0pt"><i>файл hello.o в исполняемый файл hello:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Таблица символов '.symtab' содержит 75 записей:</i></p><p height="1em" width="0pt"><i>gcc -g -m32 -masm=intel привет.о -о привет</i></p><p height="1em" width="0pt"><i>Номер:</i></p><p height="1em" width="0pt"><i>Ценить</i></p><p height="1em" width="0pt"><i>Размер Тип</i></p><p height="1em" width="0pt"><i>Связывать</i></p><p height="1em" width="0pt"><i>Вис</i></p><p height="1em" width="0pt"><i>Имя NDX</i></p><p height="1em" width="0pt"><i>0: 00000000</i></p><p height="1em" width="0pt"><i>0 НЕТИП</i></p><p height="1em" width="0pt"><i>МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>UND</i></p><p height="1em" width="0pt"><i>1: 08048154</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>1</i></p><p height="1em" width="0pt"><i>2: 08048168</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>2</i></p><p height="1em" width="0pt"><i>3: 08048188</i></p><p height="1em" width="0pt"><i>0 РАЗДЕЛ МЕСТНЫЙ</i></p><p height="1em" width="0pt"><i>ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>3</i></p><p height="1em" width="0pt"><i>....вывод опущен...</i></p><p height="1em" width="0pt"><i>64: 08048409</i></p><p height="1em" width="0pt"><i>6 ФУНКЦИИ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>14 фу</i></p><p height="1em" width="0pt"><i>65: 0804a020</i></p><p height="1em" width="0pt"><i>0 НЕТИП</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>26 _конец</i></p><p height="1em" width="0pt"><i>66: 080482e0</i></p><p height="1em" width="0pt"><i>0 ФУНКЦИЯ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>14 _старт</i></p><p height="1em" width="0pt"><i>67: 08048488</i></p><p height="1em" width="0pt"><i>4 ОБЪЕКТ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>16 _fp_hw</i></p><p height="1em" width="0pt"><i>68: 0804a01c</i></p><p height="1em" width="0pt"><i>4 ОБЪЕКТ</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>26 я</i></p><p height="1em" width="0pt"><i>69: 0804a018</i></p><p height="1em" width="0pt"><i>0 НЕТИП</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>26 __bss_start</i></p><p height="1em" width="0pt"><i>70: 080483дб</i></p><p height="1em" width="0pt"><i>46 ФУНКЦ.</i></p><p height="1em" width="0pt"><i>ГЛОБАЛЬНОЕ ПО УМОЛЧАНИЮ</i></p><p height="1em" width="0pt"><i>14 основных</i></p><p height="1em" width="0pt"><i>...вывод опущен...</i></p><p height="1em" width="0pt"><i>В отличие от значений символов foo, i и main, как в объектном файле hello.o, здесь указаны полные адреса памяти.</i></p><p height="1em" width="0pt"><i>224</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>Теперь достаточно разобраться в типах релокаций. Ранее мы упоминали тип R_386_PC32. Для перемещения применяется следующая формула (Inteli386</i></p><p height="1em" width="0pt"><i>псАБИ):</i></p><p height="1em" width="0pt"><i>Перемещенный набор f = S + A - P</i></p><p height="1em" width="0pt"><i>где</i></p><p height="1em" width="0pt"><i> </i><i><b>С</b></i><i>представляет значение символа. В конечном исполняемом двоичном файле это адрес символа.</i></p><p height="1em" width="0pt"><i> </i><i><b>А</b></i><i>представляет сложение, дополнительное значение, добавляемое к значению символа.</i></p><p height="1em" width="0pt"><i> </i><i><b>п</b></i><i>Представляет адрес памяти, который нужно исправить.</i></p><p height="1em" width="0pt"><i> </i><i><b>Переместить смещение</b></i><i>это расстояние между перемещаемым местоположением6 и 6, где указанный адрес памяти</i></p><p height="1em" width="0pt"><i>должно быть исправлено.</i></p><p height="1em" width="0pt"><i>фактическое расположение в памяти определения символа или адрес памяти.</i></p><p height="1em" width="0pt"><i>Но почему мы тратим время на вычисление расстояния вместо замены прямым адресом памяти? Причина в том, что архитектура x86 не использует какой-либо режим адресации, использующий абсолютный адрес памяти, как указано в таблице</i><a href="#filepos188918"><i>4.5.2.</i></a><i>Все режимы адресации в x86 относительные.</i></p><p height="1em" width="0pt"><i>В некоторых языках ассемблера абсолютный адрес может использоваться просто потому, что это синтаксический сахар, который позже преобразуется ассемблером в один из режимов относительной адресации, предоставляемых оборудованием x86.</i></p><p height="1em" width="0pt"><i><b>Пример 8.1.4.</b></i><i>Для символа foo:</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>0000001c</i></p><p height="1em" width="0pt"><i>00000a02 R_386_PC32</i></p><p height="1em" width="0pt"><i>0000002e</i></p><p height="1em" width="0pt"><i>фу</i></p><p height="1em" width="0pt"><i>Расстояние между использованием foo в main.o и его определением по формуле S + A − P составляет: 2e + 0 − 1c = 12. То есть место, где начинается фиксация памяти, находится на расстоянии 0x12 или 18 байт от определение символа foo. Однако, чтобы инструкция работала правильно, мы должны также вычесть 4 из 0x12 и получить 0xe. Почему дополнительные -4?</i></p><p height="1em" width="0pt"><i>Поскольку относительный адрес начинается в конце инструкции, а не</i></p><p height="1em" width="0pt"><i>линковка и загрузка на голое железо</i></p><p height="1em" width="0pt"><i>225</i></p><p height="1em" width="0pt"><i>адрес, с которого начинается фиксация памяти. По этой причине мы также должны исключить 4 байта перезаписанного адреса.</i></p><p height="1em" width="0pt"><i>Действительно, глядя на вывод objdump объектного файла hello.o:</i><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>Разборка раздела .text:</i></p><p height="1em" width="0pt"><i>00000000 <основной>:</i></p><p height="1em" width="0pt"><i>0:</i></p><p height="1em" width="0pt"><i>8д 4с 24 04</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>еккс,[esp+0x4]</i></p><p height="1em" width="0pt"><i>4:</i></p><p height="1em" width="0pt"><i>83 e4 f0</i></p><p height="1em" width="0pt"><i>и</i></p><p height="1em" width="0pt"><i>esp, 0xffffffff0</i></p><p height="1em" width="0pt"><i>7:</i></p><p height="1em" width="0pt"><i>фф 71 фк</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>Двойное слово PTR [ecx-0x4]</i></p><p height="1em" width="0pt"><i>а:</i></p><p height="1em" width="0pt"><i>55</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>б:</i></p><p height="1em" width="0pt"><i>89 e5</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>е.и.п., особенно</i></p><p height="1em" width="0pt"><i>д:</i></p><p height="1em" width="0pt"><i>51</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ecx</i></p><p height="1em" width="0pt"><i>е:</i></p><p height="1em" width="0pt"><i>83 эк 04</i></p><p height="1em" width="0pt"><i>суб</i></p><p height="1em" width="0pt"><i>особенно, 0x4</i></p><p height="1em" width="0pt"><i>11:</i></p><p height="1em" width="0pt"><i>с7 05 00 00 00 00 05</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>DWORD PTR ds:0x0,0x5</i></p><p height="1em" width="0pt"><i>18:</i></p><p height="1em" width="0pt"><i>00 00 00</i></p><p height="1em" width="0pt"><i>1б:</i></p><p height="1em" width="0pt"><i>e8 fc ff ff ff</i></p><p height="1em" width="0pt"><i>вызов</i></p><p height="1em" width="0pt"><i>1c <основной+0x1c></i></p><p height="1em" width="0pt"><i>20:</i></p><p height="1em" width="0pt"><i>б8 00 00 00 00</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>еакс, 0x0</i></p><p height="1em" width="0pt"><i>25:</i></p><p height="1em" width="0pt"><i>83 с4 04</i></p><p height="1em" width="0pt"><i>добавлять</i></p><p height="1em" width="0pt"><i>особенно, 0x4</i></p><p height="1em" width="0pt"><i>28:</i></p><p height="1em" width="0pt"><i>59</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ecx</i></p><p height="1em" width="0pt"><i>29:</i></p><p height="1em" width="0pt"><i>5д</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>2а:</i></p><p height="1em" width="0pt"><i>8д 61 фк</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>особенно, [ecx-0x4]</i></p><p height="1em" width="0pt"><i>2д:</i></p><p height="1em" width="0pt"><i>с3</i></p><p height="1em" width="0pt"><i>рет</i></p><p height="1em" width="0pt"><i>0000002e <foo>:</i></p><p height="1em" width="0pt"><i>2д:</i></p><p height="1em" width="0pt"><i>55</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>2ф:</i></p><p height="1em" width="0pt"><i>89 e5</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>е.и.п., особенно</i></p><p height="1em" width="0pt"><i>31:</i></p><p height="1em" width="0pt"><i>90</i></p><p height="1em" width="0pt"><i>нет</i></p><p height="1em" width="0pt"><i>32:</i></p><p height="1em" width="0pt"><i>5д</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>33:</i></p><p height="1em" width="0pt"><i>с3</i></p><p height="1em" width="0pt"><i>рет</i></p><p height="1em" width="0pt"><i>Место, где начинается фиксация памяти, находится после кода операции e8 с фиктивным значением fc ff ff ff, которое равно -4 в десятичном виде. Однако в ассемблерном коде значение отображается как 1с. Адрес памяти сразу после e8. Причина в том, что инструкция e8 начинается с 1b и заканчивается на 207.</i></p><p height="1em" width="0pt"><i>7 Концом инструкции является память.</i></p><p height="1em" width="0pt"><i>адрес сразу после последнего операнда.</i></p><p height="1em" width="0pt"><i>-4 означает 4 байта назад от конца инструкции, то есть: 20 - 4 = 1c. Вся инструкция e8 простирается от адреса 1b до адреса 1f.</i></p><p height="1em" width="0pt"><i>После линковки отображается вывод конечного исполняемого файла с фактической фиксацией памяти:</i></p><p height="1em" width="0pt"><i>226</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i><b>Выход</b></i></p><p height="1em" width="0pt"><i>080483db <основной>:</i></p><p height="1em" width="0pt"><i>80483дб:</i></p><p height="1em" width="0pt"><i>8д 4с 24 04</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>еккс,[esp+0x4]</i></p><p height="1em" width="0pt"><i>80483df:</i></p><p height="1em" width="0pt"><i>83 e4 f0</i></p><p height="1em" width="0pt"><i>и</i></p><p height="1em" width="0pt"><i>esp, 0xffffffff0</i></p><p height="1em" width="0pt"><i>80483e2:</i></p><p height="1em" width="0pt"><i>фф 71 фк</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>Двойное слово PTR [ecx-0x4]</i></p><p height="1em" width="0pt"><i>80483e5:</i></p><p height="1em" width="0pt"><i>55</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>80483e6:</i></p><p height="1em" width="0pt"><i>89 e5</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>е.и.п., особенно</i></p><p height="1em" width="0pt"><i>80483e8:</i></p><p height="1em" width="0pt"><i>51</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ecx</i></p><p height="1em" width="0pt"><i>80483e9:</i></p><p height="1em" width="0pt"><i>83 эк 04</i></p><p height="1em" width="0pt"><i>суб</i></p><p height="1em" width="0pt"><i>особенно, 0x4</i></p><p height="1em" width="0pt"><i>80483эк:</i></p><p height="1em" width="0pt"><i>с7 05 1с а0 04 08 05</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>Двойное слово PTR ds: 0x804a01c, 0x5</i></p><p height="1em" width="0pt"><i>80483f3:</i></p><p height="1em" width="0pt"><i>00 00 00</i></p><p height="1em" width="0pt"><i>80483f6:</i></p><p height="1em" width="0pt"><i>е8 0е 00 00 00</i></p><p height="1em" width="0pt"><i>вызов</i></p><p height="1em" width="0pt"><i>8048409 <foo></i></p><p height="1em" width="0pt"><i>80483fb:</i></p><p height="1em" width="0pt"><i>б8 00 00 00 00</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>еакс, 0x0</i></p><p height="1em" width="0pt"><i>8048400:</i></p><p height="1em" width="0pt"><i>83 с4 04</i></p><p height="1em" width="0pt"><i>добавлять</i></p><p height="1em" width="0pt"><i>особенно, 0x4</i></p><p height="1em" width="0pt"><i>8048403:</i></p><p height="1em" width="0pt"><i>59</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ecx</i></p><p height="1em" width="0pt"><i>8048404:</i></p><p height="1em" width="0pt"><i>5д</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>8048405:</i></p><p height="1em" width="0pt"><i>8д 61 фк</i></p><p height="1em" width="0pt"><i>Леа</i></p><p height="1em" width="0pt"><i>особенно, [ecx-0x4]</i></p><p height="1em" width="0pt"><i>8048408:</i></p><p height="1em" width="0pt"><i>с3</i></p><p height="1em" width="0pt"><i>рет</i></p><p height="1em" width="0pt"><i>08048409 <foo>:</i></p><p height="1em" width="0pt"><i>8048409:</i></p><p height="1em" width="0pt"><i>55</i></p><p height="1em" width="0pt"><i>толкать</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>804840а:</i></p><p height="1em" width="0pt"><i>89 e5</i></p><p height="1em" width="0pt"><i>движение</i></p><p height="1em" width="0pt"><i>е.и.п., особенно</i></p><p height="1em" width="0pt"><i>804840с:</i></p><p height="1em" width="0pt"><i>90</i></p><p height="1em" width="0pt"><i>нет</i></p><p height="1em" width="0pt"><i>804840d:</i></p><p height="1em" width="0pt"><i>5д</i></p><p height="1em" width="0pt"><i>поп</i></p><p height="1em" width="0pt"><i>ebp</i></p><p height="1em" width="0pt"><i>804840е:</i></p><p height="1em" width="0pt"><i>с3</i></p><p height="1em" width="0pt"><i>рет</i></p><p height="1em" width="0pt"><i>804840f:</i></p><p height="1em" width="0pt"><i>90</i></p><p height="1em" width="0pt"><i>нет</i></p><p height="1em" width="0pt"><i>В финальном выводе код операции e8, который ранее был равен 1b, теперь начинается с адреса 80483f6. Фиктивное значение fc ff ff ff заменяется фактическим значением 0e 00 00 00 с использованием того же метода вычисления из его объектного файла: код операции e8 имеет значение 80483f6. Определение foo находится по адресу 8048409.</i></p><p height="1em" width="0pt"><i>Смещение от следующего адреса после e8 равно 8048409 + 0 — 80483f7 — 4 = 0e.</i></p><p height="1em" width="0pt"><i>Однако для удобочитаемости сборка отображается как вызов 8048409 <foo>, поскольку ассемблер GNU as8 позволяет указать фактический адрес памяти 8 или любой текущий ассемблер, используемый сегодня.</i></p><p height="1em" width="0pt"><i>определения символа. Такой адрес позже переводится в режим относительной адресации, избавляя программиста от необходимости вычислять смещение.</i></p><a id="filepos672464" /><p height="1em" width="0pt"><i>линковка и загрузка на голое железо</i></p><p height="1em" width="0pt"><i>227</i></p><p height="1em" width="0pt"><i>вручную.</i></p><p height="1em" width="0pt"><i>8.1.5 Сим. Имя</i></p><p height="1em" width="0pt"><i>В этом поле отображается имя перемещаемого символа. Именованный символ совпадает с написанным на языке высокого уровня, таком как C.</i></p><p height="1em" width="0pt"><i><b>8.2</b></i></p><p height="1em" width="0pt"><i><b>Создание двоичного файла ELF с помощью скриптов компоновщика</b></i></p><p height="1em" width="0pt"><i>Компоновщик — это программа, которая объединяет отдельные объектные файлы в окончательный</i></p><p height="1em" width="0pt"><i> </i><i><b>компоновщик</b></i></p><p height="1em" width="0pt"><i>бинарный файл. Когда gcc вызывается, он запускает ld внизу, чтобы превратить объектные файлы в окончательный исполняемый файл.</i></p><p height="1em" width="0pt"><i>Сценарий компоновщика — это текстовый файл, который указывает, как компоновщик должен</i></p><p height="1em" width="0pt"><i> </i><i><b>скрипт компоновщика</b></i></p><p height="1em" width="0pt"><i>объектные файлы bin. Когда gcc запускается, он использует свой сценарий компоновщика по умолчанию для построения схемы памяти скомпилированного двоичного файла. Стандартизированный макет памяти называется форматом объектного файла, например. ELF включает в себя заголовки программ, заголовки разделов и их атрибуты. Сценарий компоновщика по умолчанию предназначен для работы в среде текущей операционной системы9. Запуск на голой 9 Чтобы просмотреть сценарий по умолчанию,</i></p><p height="1em" width="0pt"><i>использовать</i></p><p height="1em" width="0pt"><i>--подробный вариант:</i></p><p height="1em" width="0pt"><i>metal сценарий по умолчанию использовать нельзя, так как он не предназначен для таких целей en-ld --verbose</i></p><p height="1em" width="0pt"><i>окружающая среда. По этой причине программист должен предоставить свой собственный скрипт компоновщика для таких сред.</i></p><p height="1em" width="0pt"><i>Каждый скрипт компоновщика состоит из серии команд следующего формата:</i></p><p height="1em" width="0pt"><i>КОМАНДА</i></p><p height="1em" width="0pt"><i>{</i></p><p height="1em" width="0pt"><i>подкоманда 1</i></p><p height="1em" width="0pt"><i>подкоманда 2</i></p><p height="1em" width="0pt"><i>.... дополнительная подкоманда....</i></p><p height="1em" width="0pt"><i>}</i></p><p height="1em" width="0pt"><i>Каждая подкоманда относится только к команде верхнего уровня. В простейшем сценарии компоновщика требуется только одна команда: SECTION, которая использует входные разделы из объектных файлов и создает выходные разделы окончательного двоичного файла10.</i></p><p height="1em" width="0pt"><i>10 Вспомните, что секции — это куски</i></p><p height="1em" width="0pt"><i>код или данные, или и то, и другое.</i></p><p height="1em" width="0pt"><i>228</i></p><p height="1em" width="0pt"><i>операционные системы: от 0 до 1</i></p><p height="1em" width="0pt"><i>8.2.1 Пример скрипта компоновщика</i></p><p height="1em" width="0pt"><i>Вот минимальный пример скрипта компоновщика:</i></p><p height="1em" width="0pt"><i>main.lds</i></p><p height="1em" width="0pt"><i>РАЗДЕЛЫ /* Команда */</i></p><p height="1em" width="0pt"><i>{</i></p><p height="1em" width="0pt"><i>. = 0x10000; /* под-</i><i><b>команда</b></i><i>1 */</i></p><p height="1em" width="0pt"><i>.text : { *(.text) } /* вложенный</i><i><b>команда</b></i><i>2 */</i></p><p height="1em" width="0pt"><i>. = 0x8000000; /* под-</i><i><b>команда</b></i><i>3 */</i></p><p height="1em" width="0pt"><i>.data : { *(.data) } /* вложенный</i><i><b>команда</b></i><i>4 */</i></p><p height="1em" width="0pt"><i>.bss : { *(.bss) } /* суб-</i><i><b>команда</b></i><i>5 */</i></p><p height="1em" width="0pt"><i>}</i></p><p height="1em" width="0pt"><i><b>Разбор кода:</b></i></p><p height="1em" width="0pt"><i><b>Код</b></i></p><p height="1em" width="0pt"><i><b>Описание</b></i></p><p height="1em" width="0pt"><i>РАЗДЕЛ</i></p><p height="1em" width="0pt"><i>Команда верхнего уровня, объявляющая список пользовательских разделов программы. ld предоставляет набор таких команд.</i></p><p height="1em" width="0pt"><i>. = 0x10000;</i></p><p height="1em" width="0pt"><i>Установите счетчик местоположения на адрес 0x10000. Счетчик местоположения указывает базовый адрес для последующих команд. В этом примере последующие команды будут использовать 0x10000 и далее.</i></p><p height="1em" width="0pt"><i>.текст : { *(.текст) }</i></p><p height="1em" width="0pt"><i>Поскольку счетчик местоположения установлен на 0x10000, вывод .text в конечном двоичном файле будет начинаться с адреса 0x10000. Эта команда объединяет все разделы .text из всех объектных файлов с</i></p><p height="1em" width="0pt"><i>*(.text) в окончательный раздел .text. * — это подстановочный знак, который соответствует любому имени файла.</i></p><p height="1em" width="0pt"><i>. = 0x8000000;</i></p><p height="1em" width="0pt"><i>Опять же, счетчик местоположения установлен на 0x8000000. Последующие команды будут использовать этот адрес для работы с разделами.</i></p><p height="1em" width="0pt"><i>.данные: {*(.данные)}</i></p><p height="1em" width="0pt"><i>Все разделы .data объединяются в один раздел .data в конечном бинарном файле.</i></p><p height="1em" width="0pt"><i>.bss : { *(.bss) }</i></p><p height="1em" width="0pt"><i>Все разделы .bss объединяются в один раздел .bss в финальном бинарном файле.</i></p><p height="1em" width="0pt"><i>Адреса 0x10000 и 0x8000000 называются адресами виртуальной памяти.</i></p><p height="1em" width="0pt"><i>Адрес виртуальной памяти — это адрес, по которому секция загружается в память — адрес виртуальной памяти.</i></p><p height="1em" width="0pt">ори, когда программа запускается. Чтобы использовать скрипт компоновщика, мы сохраняем его как файл, например. основной.lds11; затем нам нужен образец программы в файле, например. main.c: 11 .lds — это расширение для компоновщика.</p><p height="1em" width="0pt">сценарий.</p><p height="1em" width="0pt">main.c</p><p height="1em" width="0pt"><b>пустота</b>тест() {}</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">229</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Затем мы компилируем файл и явно вызываем ld с помощью скрипта компоновщика: $ gcc -m32 -g -c main.c</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">В команде ld параметры аналогичны gcc:</p><p height="1em" width="0pt"><b>Вариант</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">-м</p><p height="1em" width="0pt">Укажите формат объектного файла, который создает ld. В примере elf_i386 означает, что должен быть создан 32-битный файл ELF.</p><p height="1em" width="0pt">-о</p><p height="1em" width="0pt">Укажите имя конечного исполняемого двоичного файла.</p><p height="1em" width="0pt">-Т</p><p height="1em" width="0pt">Укажите сценарий компоновщика для использования. В примере это main.lds.</p><p height="1em" width="0pt">Остальные входные данные — это список объектных файлов для связывания. После выполнения команды ld создается окончательный исполняемый двоичный файл — main. Если мы попробуем запустить его:</p><p height="1em" width="0pt">$ ./основной</p><p height="1em" width="0pt">Ошибка сегментации</p><p height="1em" width="0pt">Причина в том, что при ручном связывании адрес входа должен быть явно установлен, иначе ld по умолчанию устанавливает его в начало раздела .text.</p><p height="1em" width="0pt">Мы можем проверить из вывода readelf:</p><p height="1em" width="0pt">$ readelf -h главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Заголовок ЭЛЬФ:</p><p height="1em" width="0pt">Магия:</p><p height="1em" width="0pt">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">Сорт:</p><p height="1em" width="0pt">ЭЛЬФ64</p><p height="1em" width="0pt">Данные:</p><p height="1em" width="0pt">дополнение до 2, прямой порядок байтов</p><p height="1em" width="0pt">Версия:</p><p height="1em" width="0pt">1 (текущий)</p><p height="1em" width="0pt">230</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">ОС/ABI:</p><p height="1em" width="0pt">UNIX — Система V</p><p height="1em" width="0pt">Версия АБИ:</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Тип:</p><p height="1em" width="0pt">EXEC (исполняемый файл)</p><p height="1em" width="0pt">Машина:</p><p height="1em" width="0pt">Усовершенствованные микроустройства X86-64</p><p height="1em" width="0pt">Версия:</p><p height="1em" width="0pt">0x1</p><p height="1em" width="0pt">Адрес точки входа:</p><p height="1em" width="0pt">0x10000</p><p height="1em" width="0pt">Начало заголовков программы:</p><p height="1em" width="0pt">64 (байт в файл)</p><p height="1em" width="0pt">Начало заголовков разделов:</p><p height="1em" width="0pt">2098144 (байт в файл)</p><p height="1em" width="0pt">Флаги:</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt">Размер этого заголовка:</p><p height="1em" width="0pt">64 (байта)</p><p height="1em" width="0pt">Размер заголовков программы:</p><p height="1em" width="0pt">56 (байт)</p><p height="1em" width="0pt">Количество заголовков программы:</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">Размер заголовков разделов:</p><p height="1em" width="0pt">64 (байта)</p><p height="1em" width="0pt">Количество заголовков разделов:</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">Индекс таблицы строк заголовка раздела: 11</p><p height="1em" width="0pt">Адрес точки входа установлен на 0x10000, что является началом</p><p height="1em" width="0pt">.текстовый раздел. Использование objdump для проверки адреса:</p><p height="1em" width="0pt">$ objdump -z -M intel -S -D прог | меньше</p><p height="1em" width="0pt">мы видим, что адрес 0x10000 не начинается с основной функции при запуске программы:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Разборка раздела .text:</p><p height="1em" width="0pt">00010000 <тест>:</p><p height="1em" width="0pt">инт а = 5;</p><p height="1em" width="0pt">инт я;</p><p height="1em" width="0pt">недействительный тест () {}</p><p height="1em" width="0pt">10000:</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">10001:</p><p height="1em" width="0pt">89 e5</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">10003:</p><p height="1em" width="0pt">90</p><p height="1em" width="0pt">нет</p><p height="1em" width="0pt">10004:</p><p height="1em" width="0pt">5д</p><p height="1em" width="0pt">поп</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">10005:</p><p height="1em" width="0pt">с3</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">00010006 <основной>:</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">231</p><p height="1em" width="0pt">int main(int argc, char *argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">10006:</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">10007:</p><p height="1em" width="0pt">89 e5</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">10009:</p><p height="1em" width="0pt">б8 00 00 00 00</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">еакс, 0x0</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">1000 евро:</p><p height="1em" width="0pt">5д</p><p height="1em" width="0pt">поп</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">1000ф:</p><p height="1em" width="0pt">с3</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">Начало раздела .text с адреса 0x10000 — это проверка функции, а не основная!</p><p height="1em" width="0pt">Чтобы программа могла правильно работать на main, нам нужно установить точку входа в скрипте компоновщика со следующей строкой в ​​начале файла:</p><p height="1em" width="0pt">ВХОД(основной)</p><p height="1em" width="0pt">Снова перекомпилируйте исполняемый бинарный файл main. На этот раз вывод readelf отличается:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Заголовок ЭЛЬФ:</p><p height="1em" width="0pt">Магия:</p><p height="1em" width="0pt">7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">Сорт:</p><p height="1em" width="0pt">ЭЛЬФ32</p><p height="1em" width="0pt">Данные:</p><p height="1em" width="0pt">дополнение до 2, прямой порядок байтов</p><p height="1em" width="0pt">Версия:</p><p height="1em" width="0pt">1 (текущий)</p><p height="1em" width="0pt">ОС/ABI:</p><p height="1em" width="0pt">UNIX — Система V</p><p height="1em" width="0pt">Версия АБИ:</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">Тип:</p><p height="1em" width="0pt">EXEC (исполняемый файл)</p><p height="1em" width="0pt">Машина:</p><p height="1em" width="0pt">Интел 80386</p><p height="1em" width="0pt">Версия:</p><p height="1em" width="0pt">0x1</p><p height="1em" width="0pt">Адрес точки входа:</p><p height="1em" width="0pt">0x10006</p><p height="1em" width="0pt">Начало заголовков программы:</p><p height="1em" width="0pt">52 (байт в файл)</p><p height="1em" width="0pt">Начало заголовков разделов:</p><p height="1em" width="0pt">9168 (байт в файл)</p><p height="1em" width="0pt">Флаги:</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt">Размер этого заголовка:</p><p height="1em" width="0pt">52 (байта)</p><p height="1em" width="0pt">232</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Размер заголовков программы:</p><p height="1em" width="0pt">32 (байта)</p><p height="1em" width="0pt">Количество заголовков программы:</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">Размер заголовков разделов:</p><p height="1em" width="0pt">40 (байт)</p><p height="1em" width="0pt">Количество заголовков разделов:</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">Индекс таблицы строк заголовка раздела: 11</p><p height="1em" width="0pt">Программа теперь выполняет код по адресу 0x10006 при запуске.</p><p height="1em" width="0pt">0x10006 — вот где начинается главное! Чтобы убедиться, что мы действительно начинаем с main, мы запускаем программу с помощью gdb, устанавливаем две точки останова на функции main и test:</p><p height="1em" width="0pt">$ гдб ./основной</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">.... вывод опущен ....</p><p height="1em" width="0pt">Чтение символов из ./main... готово.</p><p height="1em" width="0pt">(gdb) тест b</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Точка останова 1 по адресу 0x10003: файл main.c, строка 1.</p><p height="1em" width="0pt">(gdb) б основной</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Точка останова 2 по адресу 0x10009: файл main.c, строка 5.</p><p height="1em" width="0pt">(гдб) р</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Стартовая программа: /tmp/main</p><p height="1em" width="0pt">Точка останова 2, main (argc=-11493, argv=0x0) в main.c:5</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">вернуть 0;</p><p height="1em" width="0pt">Как показано в выводе, gdb сначала остановился на 2-й точке останова.</p><p height="1em" width="0pt">Теперь запускаем программу в обычном режиме, без gdb:</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">233</p><p height="1em" width="0pt">$ ./основной</p><p height="1em" width="0pt">Ошибка сегментации</p><p height="1em" width="0pt">Мы по-прежнему получаем ошибку сегментации. Этого и следовало ожидать, так как мы запустили пользовательский двоичный файл без поддержки среды выполнения C со стороны операционной системы. Последний оператор в основной функции: return 0, просто возвращает в случайное место12. Среда выполнения C обеспечивает правильное завершение программы. В 12 Обратный адрес выше текущего</p><p height="1em" width="0pt">э.п. Однако, когда мы входим в main, нет</p><p height="1em" width="0pt">В Linux функция _exit() неявно вызывается при возврате из main. Для возврата значение помещается в стек.</p><p height="1em" width="0pt">Итак, когда return выполняется, он просто</p><p height="1em" width="0pt">Чтобы решить эту проблему, мы просто изменим программу, чтобы она правильно завершала работу: извлекала любое значение выше ebp и использовала</p><p height="1em" width="0pt">в качестве обратного адреса.</p><p height="1em" width="0pt">Привет</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt"><b>пустота</b>тест() {}</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[]) 3</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">asm("mov eax, 0x1\n"</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">"mov ebx, 0x0\n"</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">"целое 0x80");</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Требуется встроенная сборка, поскольку прерывание 0x80 определено для системных вызовов в Linux. Так как программа не использует библиотеку, нет другого способа вызвать системные функции, кроме использования ассемблера. Однако при написании нашей операционной системы такой код нам не понадобится, так как среды для нормального выхода пока нет.</p><p height="1em" width="0pt">Теперь, когда мы можем точно контролировать, где изначально запускается программа, легко загрузить ядро ​​из загрузчика. Прежде чем мы перейдем к следующему разделу, обратите внимание, как readelf и objdump можно применять для отладки программы еще до ее запуска.</p><p height="1em" width="0pt"> <i>8.2.2 Понимание пользовательской структуры ELF</i></p><p height="1em" width="0pt">В этом примере нам удалось создать работающий исполняемый двоичный файл ELF из пользовательского сценария компоновщика, в отличие от сценария по умолчанию, предоставленного gcc. Чтобы было удобно заглянуть в его структуру:</p><p height="1em" width="0pt">234</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">$ readelf -e главная</p><p height="1em" width="0pt">Опция -e представляет собой комбинацию 3-х опций -h -l -S:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">....... Вывод заголовка ELF опущен .......</p><p height="1em" width="0pt">Заголовки разделов:</p><p height="1em" width="0pt">[№] Имя</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Адрес</p><p height="1em" width="0pt">Выключенный</p><p height="1em" width="0pt">Размер</p><p height="1em" width="0pt">ES Flg Lk Inf Al</p><p height="1em" width="0pt">[ 0]</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">00000000 000000 000000 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">[ 1] .текст</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00010000 001000 000010 00</p><p height="1em" width="0pt">ТОПОР</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 2] .eh_frame</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00010010 001010 000058 00</p><p height="1em" width="0pt">А</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[ 3] .debug_info</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 001068 000087 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 4] .debug_abbrev</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 0010ef 000074 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 5] .debug_aranges</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 001163 000020 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 6] .debug_line</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 001183 000038 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 7] .debug_str</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 0011bb 000078 01</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[ 8 ] .комментарий</p><p height="1em" width="0pt">PROGBITS</p><p height="1em" width="0pt">00000000 001233 000034 01</p><p height="1em" width="0pt">РС</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[9] .shstrtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 00133а 000074 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">[10] .симтаб</p><p height="1em" width="0pt">СИМТАБ</p><p height="1em" width="0pt">00000000 001268 0000c0 10</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">[11] .strtab</p><p height="1em" width="0pt">СТРТАБ</p><p height="1em" width="0pt">00000000 001328 000012 00</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">0</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Ключ к флагам:</p><p height="1em" width="0pt">W (запись), A (распределение), X (выполнение), M (объединение), S (строки), I (информация), L (порядок ссылок), G (группа), T (TLS), E (исключение), x (неизвестно) O (требуется дополнительная обработка ОС) o (зависит от ОС), p (зависит от процессора) Заголовки программ:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00010000 0x00010000 0x00068 0x00068 ЧТ 0x1000</p><p height="1em" width="0pt">GNU_STACK</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00000 0x00000 ЧЗ</p><p height="1em" width="0pt">0x10</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">Структура невероятно проста. Списки сегментов и разделов могут находиться на одном экране. Это не относится к исполняемому двоичному файлу ELF по умолчанию. На выходе всего 11 разделов,</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">235</p><p height="1em" width="0pt">и только два загружаются во время выполнения: .text и .eh_frame, потому что обоим разделам назначаются фактические адреса памяти, 0x10000 и 0x10010.</p><p height="1em" width="0pt">соответственно. Остальным разделам присваивается 0<i>в финальном исполняемом бинарнике</i>13, что означает, что они не загружаются во время выполнения. Это составляет 13 В отличие от объектных файлов, где</p><p height="1em" width="0pt">адреса памяти всегда равны 0 и</p><p height="1em" width="0pt">смысле, так как эти разделы связаны с управлением версиями14, отладкой15 и только ссылками, которым присваиваются фактические значения в</p><p height="1em" width="0pt">процесс связывания.</p><p height="1em" width="0pt">ing16.</p><p height="1em" width="0pt">14 Это раздел .comment. Может быть</p><p height="1em" width="0pt">просмотрено с комментарием readelf -p</p><p height="1em" width="0pt">Таблица заголовков сегментов программы еще проще. Он содержит только 2</p><p height="1em" width="0pt">.комментарий основной.</p><p height="1em" width="0pt">15 Те, что начинаются с префикса .debug.</p><p height="1em" width="0pt">сегменты:</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">ЗАГРУЗКА и GNU_STACK. По умолчанию, если скрипт компоновщика не содержит таблицы символов и таблицы строк.</p><p height="1em" width="0pt">предоставить инструкции по построению программных сегментов, ld предоставляет разумные сегменты по умолчанию. Как и в этом случае, .text должен быть в LOAD</p><p height="1em" width="0pt">сегмент. Сегмент GNU_STACK — это расширение GNU, используемое ядром Linux для управления состоянием стека программы. Этот сегмент нам не понадобится, как и .eh_frame, который предназначен для обработки исключений, так как мы пишем свою операционную систему с нуля. Для достижения этих целей нам нужно будет создать собственные заголовки программ вместо того, чтобы позволить ld справиться с этой задачей, и поручить ld удалить .eh_frame.</p><p height="1em" width="0pt"> <i>8.2.3 Управление сегментами программы</i></p><p height="1em" width="0pt">Во-первых, нам нужно создать собственную таблицу заголовков программы, используя следующий синтаксис:</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt"><имя> <<b>тип</b>> [FILEHDR] [PHDRS] [AT (адрес)]</p><p height="1em" width="0pt">[ФЛАГИ (флаги)];</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Команда PHDRS похожа на команду SECTION, но для объявления списка пользовательских сегментов программы с предопределенным синтаксисом.</p><p height="1em" width="0pt"> <i><b>имя</b></i>— это имя заголовка, на которое позже ссылается раздел, объявленный в команде SECTION.</p><p height="1em" width="0pt"> <i><b>тип</b></i>тип сегмента ELF, как описано в разделе Раздел<a href="#filepos444786">5,5,</a>с добавленным префиксом PT_. Например, вместо NULL или LOAD, отображаемых readelf, это PT_NULL или PT_LOAD.</p><p height="1em" width="0pt">236</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Пример 8.2.1.</b>Имея только имя и тип, мы можем создать любое количество сегментов программы. Например, мы можем добавить сегмент программы NULL и удалить сегмент GNU_STACK:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">ноль PT_NULL;</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">код PT_LOAD;</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">РАЗДЕЛЫ</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">. = 0x10000;</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">.текст : { *(.текст) } :код</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">. = 0x8000000;</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">.данные: {*(.данные)}</p><p height="1em" width="0pt">13</p><p height="1em" width="0pt">.bss : { *(.bss) }</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Содержимое команды PHDRS говорит о том, что окончательный исполняемый двоичный файл содержит 2 сегмента программы: NULL и LOAD. Сегменту NULL дается имя null, а сегменту LOAD присваивается код имени, означающий, что этот сегмент LOAD содержит программный код. Затем, чтобы поместить раздел в сегмент, мы используем синтаксис :<phdr>, где phdr — это имя, данное ранее сегменту. В этом примере раздел .text помещается в сегмент кода.</p><p height="1em" width="0pt">Компилируем и видим результат (при условии, что main.o, скомпилированный ранее, остался): $ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x10000</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">237</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00000 0x00000</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00010000 0x00010000 0x00010 0x00010 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">Эти 2 сегмента теперь равны NULL и LOAD вместо LOAD и GNU_STACK.</p><p height="1em" width="0pt"><b>Пример 8.2.2.</b>Мы можем добавить сколько угодно сегментов одного типа, если им даны разные имена:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">ноль1 PT_NULL;</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">ноль2 PT_NULL;</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">код1 PT_LOAD;</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">код2 PT_LOAD;</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">РАЗДЕЛЫ</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">. = 0x10000;</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">.текст : { *(.текст) } :code1</p><p height="1em" width="0pt">13</p><p height="1em" width="0pt">.eh_frame : { *(.eh_frame) } :code2</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">. = 0x8000000;</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">.данные: {*(.данные)}</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">.bss : { *(.bss) }</p><p height="1em" width="0pt">17</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">После изменения содержимого PHDRS ранее с помощью этого нового списка сегментов мы помещаем .text в сегмент code1 и .eh_frame в сегмент code2, компилируем и видим новые сегменты:</p><p height="1em" width="0pt">238</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x10000</p><p height="1em" width="0pt">Имеется 4 заголовка программы, начиная со смещения 52.</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00000 0x00000</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00000 0x00000</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00010000 0x00010000 0x00010 0x00010 ЧТ 0x1000</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001010 0x00010010 0x00010010 0x00058 0x00058 Ч</p><p height="1em" width="0pt">0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">02</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">03</p><p height="1em" width="0pt">.eh_frame</p><p height="1em" width="0pt">Теперь .text и .eh_frame находятся в разных сегментах.</p><p height="1em" width="0pt"> <i><b>ФАЙЛHDR</b></i>является необязательным ключевым словом, при добавлении указывает, что программный сегмент включает заголовок файла ELF исполняемого двоичного файла. Однако этот атрибут следует добавлять только для первого сегмента программы, так как он сильно изменяет размер и начальный адрес сегмента, поскольку заголовок ELF всегда находится в начале двоичного файла. Напомним, что сегмент начинается с адреса его первого сегмента. контент, который в большинстве случаев (за исключением этого случая, который является заголовком файла) является первым разделом.</p><p height="1em" width="0pt"><b>Пример 8.2.3.</b>Добавление ключевого слова FILEHDR изменяет размер NULL.</p><p height="1em" width="0pt">сегмент:</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">239</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">ноль PT_NULL FILEHDR;</p><p height="1em" width="0pt">код PT_LOAD;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">..... содержание такое же .....</p><p height="1em" width="0pt">Связываем его снова и видим результат:</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x10000</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00034 0x00034 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00010000 0x00010000 0x00068 0x00068 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">В предыдущих примерах размер файла и объем памяти раздела NULL всегда равны 0, теперь они оба равны 34 байтам, что соответствует размеру ELF.</p><p height="1em" width="0pt">заголовок.</p><p height="1em" width="0pt"><b>Пример 8.2.4.</b>Если мы назначим FILEHDR не начальному сегменту, его размер и начальный адрес значительно изменятся:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">ноль PT_NULL;</p><p height="1em" width="0pt">240</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">код PT_LOAD FILEHDR;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">..... содержание такое же .....</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x10000</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">НУЛЕВОЙ</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00000 0x00000</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000000 0x0000f000 0x0000f000 0x01068 0x01068 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">Размер сегмента LOAD в предыдущем примере всего 0x68, такой же размер, как и суммарные размеры разделов .text и .eh_frame в нем. Но теперь это 0x01068, увеличено на 0x1000 байт. В чем причина этих лишних байтов? Простой ответ: выравнивание сегментов. На выходе выравнивание этого сегмента равно 0x1000; это означает, что независимо от того, какой адрес является началом этого сегмента, он должен делиться на 0x1000. По этой причине начальный адрес LOAD — 0xf000, поскольку он делится на 0x1000.</p><p height="1em" width="0pt">Возникает другой вопрос: почему начальный адрес 0xf000 вместо 0x10000? .text — это первый раздел, который начинается с адреса 0x10000, поэтому сегмент должен начинаться с адреса 0x10000. Причина в том, что мы включаем FILEHDR</p><p height="1em" width="0pt">как часть сегмента, он должен расширяться, чтобы включать заголовок файла ELF, который находится в самом начале исполняемого двоичного файла ELF. Чтобы удовлетворить этому ограничению и ограничению выравнивания, ближайшим адресом является 0xf000.</p><p height="1em" width="0pt">Обратите внимание, что адреса виртуальной и физической памяти — это адреса</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">241</p><p height="1em" width="0pt">во время выполнения, а не расположение сегмента в файле на диске. Как показывает поле FileSiz, сегмент занимает на диске только 0x1068 байт.</p><p height="1em" width="0pt">Фигура<a href="#filepos710774">8.2.1</a>иллюстрирует разницу между макетами памяти с ключевым словом FILEHDR и без него.</p><a id="filepos710774" /><p height="1em" width="0pt">242</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt"><b>Рисунок 8.2.1:</b>ЗАГРУЗИТЬ сегмент</p><p height="1em" width="0pt">на</p><p height="1em" width="0pt">диске и в памяти.</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt">0x34</p><p height="1em" width="0pt">заголовок ELF</p><p height="1em" width="0pt">0x1000</p><p height="1em" width="0pt">0x10000</p><p height="1em" width="0pt">.text .eh_frame Сегмент ЗАГРУЗКИ</p><p height="1em" width="0pt">.text .eh_frame Загруженный контент</p><p height="1em" width="0pt">0x1068</p><p height="1em" width="0pt">0x10068</p><p height="1em" width="0pt">0x1590</p><p height="1em" width="0pt">Файл</p><p height="1em" width="0pt">0xFFFFFFFF</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt"><b>(а)</b>Без<b>ФАЙЛHDR</b>.</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt">0xf000</p><p height="1em" width="0pt">0x34</p><p height="1em" width="0pt">заголовок ELF</p><p height="1em" width="0pt">заголовок ELF</p><p height="1em" width="0pt">0xf034</p><p height="1em" width="0pt">.text .eh_frame Сегмент ЗАГРУЗКИ</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">Загруженный контент</p><p height="1em" width="0pt">0x1000</p><p height="1em" width="0pt">0x10000</p><p height="1em" width="0pt">0x1068</p><p height="1em" width="0pt">0x10068</p><p height="1em" width="0pt">0x1590</p><p height="1em" width="0pt">Файл</p><p height="1em" width="0pt">0xFFFFFFFF</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt"><b>(б)</b>С<b>ФАЙЛHDR</b>.</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">243</p><p height="1em" width="0pt"> <i><b>PHDRS</b></i>является необязательным ключевым словом, при добавлении указывает, что сегмент программы является таблицей заголовков сегмента программы.</p><p height="1em" width="0pt"><b>Пример 8.2.5.</b>Первый сегмент исполняемого двоичного файла по умолчанию, сгенерированный gcc, представляет собой PHDR, поскольку таблица заголовков сегментов программы появляется сразу после заголовка ELF. Это также удобный сегмент для размещения заголовка ELF с использованием ключевого слова FILEHDR. Заменяем неиспользуемый NULL</p><p height="1em" width="0pt">сегмент ранее с сегментом PHDR:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">заголовки PT_PHDR FILEHDR PHDRS;</p><p height="1em" width="0pt">код PT_LOAD FILEHDR;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">..... содержание такое же .....</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x10000</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00010000 0x00010000 0x00068 0x00068 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">Как показано в выходных данных, первый сегмент имеет тип PHDR. Его размер 0x74, который включает в себя:</p><p height="1em" width="0pt">244</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">0x34 байта для заголовка ELF.</p><p height="1em" width="0pt">0x40 байт для таблицы заголовков сегментов программы, с 2 записями, каждая имеет длину 0x20 байт (32 байта).</p><p height="1em" width="0pt">Приведенное выше число соответствует выходным данным заголовка ELF:<b>Выход</b></p><p height="1em" width="0pt">Заголовок ЭЛЬФ:</p><p height="1em" width="0pt">Магия:</p><p height="1em" width="0pt">7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">Сорт:</p><p height="1em" width="0pt">ЭЛЬФ32</p><p height="1em" width="0pt">....... вывод опущен ......</p><p height="1em" width="0pt">Размер этого заголовка:</p><p height="1em" width="0pt">52 (байта)</p><p height="1em" width="0pt"><b>--> 0x34 байта</b></p><p height="1em" width="0pt">Размер заголовков программы:</p><p height="1em" width="0pt">32 (байта)</p><p height="1em" width="0pt"><b>--> 0x20 байт каждый заголовок программы</b></p><p height="1em" width="0pt">Количество заголовков программы:</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt"><b>--> всего 0x40 байт</b></p><p height="1em" width="0pt">Размер заголовков разделов:</p><p height="1em" width="0pt">40 (байт)</p><p height="1em" width="0pt">Количество заголовков разделов:</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">Индекс таблицы строк заголовка раздела: 9</p><p height="1em" width="0pt"> <i><b>АТ (адрес)</b></i>указывает адрес загрузочной памяти, куда помещается сегмент. Каждый сегмент или раздел имеет<i>адрес виртуальной памяти</i>и<i>загрузить адрес памяти</i>:</p><p height="1em" width="0pt">А<i>адрес виртуальной памяти</i>является начальным адресом сегмента или<i>адрес виртуальной памяти</i></p><p height="1em" width="0pt">раздел, когда программа находится в памяти и работает. Адрес памяти называется виртуальным, потому что он соответствует не реальной ячейке памяти, соответствующей номеру адреса, а любой случайной ячейке памяти, которая зависит от того, как базовая операционная система преобразует адрес. Например, адрес виртуальной памяти 0x1 может отображаться на ячейку памяти с физическим адресом 0x1000.</p><p height="1em" width="0pt">А<i>загрузить адрес памяти</i>адрес физической памяти, где<i>загрузить адрес памяти</i></p><p height="1em" width="0pt">программа загружена, но еще не запущена.</p><p height="1em" width="0pt">Адрес загружаемой памяти определяется синтаксисом AT. Обычно оба типа адресов одинаковы, и физический адрес может быть другим.</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">245</p><p height="1em" width="0pt">Норд. Они различаются тем, что загрузка и выполнение намеренно разделены на две отдельные фазы, для которых требуются разные области адресов.</p><p height="1em" width="0pt">Например, программа может быть разработана для загрузки в ПЗУ17 в постоянной памяти 17.</p><p height="1em" width="0pt">фиксированный адрес. Но при загрузке в ОЗУ для использования «голого железа» или операционной системы программе требуется адрес загрузки, соответствующий схеме адресации целевого приложения или операционной системы.</p><p height="1em" width="0pt"><b>Пример 8.2.6.</b>Мы можем указать адрес загрузочной памяти для сегмента LOAD с синтаксисом AT:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">заголовки PT_PHDR FILEHDR PHDRS AT(0x500);</p><p height="1em" width="0pt">код PT_LOAD;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">..... содержание такое же .....</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x4000</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000500 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00004000 0x00002000 0x00068 0x00068 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">246</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Использовать адрес или нет, зависит от операционной системы.</p><p height="1em" width="0pt">Для нашей операционной системы адрес виртуальной памяти и загрузка совпадают, поэтому явный адрес загрузки нас не касается.</p><p height="1em" width="0pt"> <i><b>ФЛАГИ (флаги)</b></i>назначает права доступа к сегменту. Каждый флаг представляет собой целое число, представляющее разрешение, и его можно комбинировать с операциями ИЛИ. Возможные значения:</p><p height="1em" width="0pt"><b>Разрешение</b></p><p height="1em" width="0pt"><b>Ценить</b></p><p height="1em" width="0pt"><b>Описание</b></p><p height="1em" width="0pt">р</p><p height="1em" width="0pt">1</p><p height="1em" width="0pt">Удобочитаемый</p><p height="1em" width="0pt">Вт</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">Доступно для записи</p><p height="1em" width="0pt">Е</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">Исполняемый</p><p height="1em" width="0pt"><b>Пример 8.2.7.</b>Мы можем создать сегмент LOAD с включенными разрешениями на чтение, запись и выполнение:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">заголовки PT_PHDR FILEHDR PHDRS AT(0x500);</p><p height="1em" width="0pt">код PT_LOAD FILEHDR FLAGS (0x1 | 0x2 | 0x4);</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">..... содержание такое же .....</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x0</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000500 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">247</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00000000 0x00000000 0x00010 0x00010 RWE 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст .eh_frame</p><p height="1em" width="0pt">Сегмент LOAD теперь получает все разрешения RWE, как показано выше.</p><p height="1em" width="0pt">Наконец, мы хотим удалить .eh_frame или любой другой нежелательный раздел, мы добавляем специальный раздел под названием /DISCARD/:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt">... таблица заголовков программных сегментов остается прежней...</p><p height="1em" width="0pt">РАЗДЕЛЫ</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">/* . = 0x10000; */</p><p height="1em" width="0pt">.текст : { *(.текст) } :код</p><p height="1em" width="0pt">. = 0x8000000;</p><p height="1em" width="0pt">.данные: {*(.данные)}</p><p height="1em" width="0pt">.bss : { *(.bss) }</p><p height="1em" width="0pt">/DISCARD/ : { *(.eh_frame) }</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Любой раздел, содержащий /DISCARD/, исчезает в конечном исполняемом двоичном файле:</p><p height="1em" width="0pt">$ ld -m elf_i386 -o main -T main.lds main.o</p><p height="1em" width="0pt">$ readelf -l главная</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x0</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><a id="filepos723613" /><p height="1em" width="0pt">248</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000500 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00000000 0x00000000 0x00010 0x00010 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">Как видно, .eh_frame нигде нет.</p><p height="1em" width="0pt"><b>8.3</b></p><p height="1em" width="0pt"><b>Среда выполнения C: размещенная или отдельно стоящая</b></p><p height="1em" width="0pt">Разделы .init, .init_array, .fini_array и .preinit_array предназначены для инициализации среды выполнения C, которая поддерживает стандартные библиотеки C. Зачем C нужна среда выполнения, если предполагается, что это компилируемый язык? Причина в том, что многие стандартные функции зависят от базовой операционной системы, которая сама по себе является большой средой выполнения. Например, функции, связанные с вводом-выводом, такие как чтение с клавиатуры с помощью gets(), чтение из файла с помощью open(), печать на экране с помощью printf(), управление системной памятью с помощью malloc(), free() и т. д.</p><p height="1em" width="0pt">Реализация C не может предоставить такие подпрограммы без работающей операционной системы, что является<i>размещенная среда</i>. А<i>размещенная среда</i>представляет собой среду выполнения, которая:</p><p height="1em" width="0pt">предоставляет реализацию библиотек C по умолчанию, которая включает системно-зависимые данные и подпрограммы.</p><p height="1em" width="0pt">выполнять распределение ресурсов, чтобы подготовить среду для запуска программы.</p><p height="1em" width="0pt">Этот процесс аналогичен процессу инициализации оборудования: при первом включении настольный компьютер загружает свои основные системные процедуры из постоянной памяти, хранящейся на материнской плате.</p><p height="1em" width="0pt">Затем он начинает инициализировать среду, например, устанавливать значения по умолчанию для различных регистров в ЦП и устройствах перед выполнением любого</p><a id="filepos726092" /><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">249</p><p height="1em" width="0pt">код.</p><p height="1em" width="0pt">Напротив,<i>автономная среда</i>это среда, которая не предоставляет системно-зависимые данные и подпрограммы. Как следствие, почти не существует библиотеки C, и среда может запускать код, скомпилированный с использованием чистого синтаксиса C. Чтобы автономная среда стала хост-средой, в ней должны быть реализованы стандартные подпрограммы системы C. Но для<i>соответствующий</i>автономной среде нужны только эти заголовочные файлы: <float.h>, <limits.h>, <stadarg.h> и <stddef.h> (согласно руководству GCC).</p><p height="1em" width="0pt">Для типичной настольной программы x86 среда выполнения C инициализируется компилятором, поэтому программа работает нормально. Однако для встроенной платформы, где программа запускается непосредственно на ней, это не так.</p><p height="1em" width="0pt">Типичная среда выполнения C, используемая в настольных операционных системах, не может использоваться на встроенных платформах из-за архитектурных различий и ограничений ресурсов. Таким образом, разработчик программного обеспечения должен реализовать пользовательскую среду выполнения C, подходящую для целевой платформы.</p><p height="1em" width="0pt">Для встроенной платформы</p><p height="1em" width="0pt">При написании нашей операционной системы первым шагом является создание автономной среды перед созданием размещенной среды.</p><p height="1em" width="0pt"><b>8.4</b></p><p height="1em" width="0pt"><b>Отлаживаемый загрузчик на голом железе</b></p><p height="1em" width="0pt">В настоящее время загрузчик скомпилирован в виде плоского двоичного файла. Хотя gdb может отображать ассемблерный код, он не всегда совпадает с исходным кодом. В исходном коде сборки существуют имена переменных и метки. Эти символы теряются при компиляции в виде плоского двоичного файла, что затрудняет отладку. Другой проблемой является несоответствие между написанным исходным кодом сборки и отображаемым исходным кодом сборки. Написанный код может содержать синтаксис более высокого уровня, специфичный для ассемблера и сгенерированный в код ассемблера более низкого уровня, отображаемый gdb. Наконец, при наличии отладочной информации можно использовать команды next/n и prev/p вместо ni и si.</p><p height="1em" width="0pt">Чтобы включить отладочную информацию, мы модифицируем Makefile загрузчика: 1. Загрузчик должен быть скомпилирован как двоичный файл ELF. Откройте Makefile</p><p height="1em" width="0pt">250</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">в каталоге bootloader/ и измените эту строку в $(BUILD_DIR)/%.o:</p><p height="1em" width="0pt">Рецепт %.asm:</p><p height="1em" width="0pt">nasm -f бин $< -o<b>$@</b></p><p height="1em" width="0pt">к этой строке:</p><p height="1em" width="0pt">насм -f эльф $< -F карлик -g -o<b>$@</b></p><p height="1em" width="0pt">В обновленном рецепте формат bin заменен форматом elf, чтобы обеспечить правильное создание отладочной информации. Параметр -F указывает формат отладочной информации, который в данном случае является карликовым. Окончательно,</p><p height="1em" width="0pt">Параметр -g заставляет nasm фактически генерировать отладочную информацию в выбранном формате.</p><p height="1em" width="0pt">2. Затем ld использует двоичный файл загрузчика ELF и создает другой двоичный файл загрузчика ELF с правильным начальным адресом памяти в разделе .text, который соответствует фактическому адресу загрузчика во время выполнения, когда виртуальная машина QEMU загружает его по адресу 0x7c00. Нам нужен ld, потому что при компиляции nasm предполагается, что начальный адрес равен 0, а не 0x7c00.</p><p height="1em" width="0pt">3. Наконец, мы используем objcopy для отдельного извлечения только плоского двоичного содержимого в качестве исходного загрузчика, добавив эту строку в $(BUILD_DIR)/%.o:</p><p height="1em" width="0pt">%.как м:</p><p height="1em" width="0pt">objcopy -O двоичный файл $(BUILD_DIR)/bootloader.o.elf<b>$@</b></p><p height="1em" width="0pt">objcopy, как следует из названия, представляет собой программу, которая копирует и транслирует объектные файлы. Здесь мы копируем оригинальный загрузчик ELF и переводим его в плоский двоичный файл.</p><p height="1em" width="0pt">Обновленный рецепт должен выглядеть так:</p><p height="1em" width="0pt">$(BUILD_DIR)/%.o: %.asm</p><p height="1em" width="0pt">насм -f эльф $< -F карлик -g -o<b>$@</b></p><p height="1em" width="0pt">ld -m elf_i386 -T bootloader.lds<b>$@</b>-о<b>$@</b>.elf objcopy -O двоичный файл $(BUILD_DIR)/bootloader.o.elf<b>$@</b></p><a id="filepos730559" /><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">251</p><p height="1em" width="0pt">Теперь тестируем загрузчик с доступной отладочной информацией: 1. Запускаем машину QEMU:</p><p height="1em" width="0pt">$ сделать кему</p><p height="1em" width="0pt">2. Запустите gdb с отладочной информацией, хранящейся в bootloader.o.elf: $ gdb build/bootloader/bootloader.o.elf</p><p height="1em" width="0pt">После входа в gdb нажмите клавишу Enter, и, если образец раздела .gdbinit<a href="#filepos630447">7.7.3</a>используется, вывод должен выглядеть так:<b>Выход</b></p><p height="1em" width="0pt">--- Введите <return> для продолжения или q <return> для выхода---</p><p height="1em" width="0pt">[f000:fff0] 0x0000fff0 в ?? ()</p><p height="1em" width="0pt">Точка останова 1 по адресу 0x7c00: файл bootloader.asm, строка 6.</p><p height="1em" width="0pt">(ГДБ)</p><p height="1em" width="0pt">gdb теперь понимает, где находится инструкция по адресу 0x7c00 в исходном файле сборки благодаря отладочной информации.</p><p height="1em" width="0pt"><b>8,5</b></p><p height="1em" width="0pt"><b>Отлаживаемая программа на голом железе</b></p><p height="1em" width="0pt">Процесс создания готового к отладке исполняемого файла аналогичен процессу создания загрузчика, за исключением того, что он более сложный. Напомним, что для правильной работы отладчика его отладочная информация должна содержать правильные сопоставления адресов между адресами памяти и исходным кодом. gcc хранит такую ​​информацию об отображении в записях DIE, в которых он сообщает gdb, какой адрес кода соответствует строке в исходном файле, чтобы точки останова работали правильно.</p><p height="1em" width="0pt">Но сначала нам нужен образец исходного файла C, очень простой: os.c</p><p height="1em" width="0pt"><b>пустота</b>основной() {}</p><p height="1em" width="0pt">252</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Поскольку это автономная среда, стандартные библиотеки, использующие системные функции, такие как printf(), не будут работать, поскольку среды выполнения C не существует. На этом этапе цель состоит в том, чтобы правильно перейти к main с правильным отображением исходного кода в gdb, так что пока не нужен причудливый код C.</p><p height="1em" width="0pt">Следующим шагом будет обновление os/Makefile:</p><p height="1em" width="0pt">BUILD_DIR=../сборка</p><p height="1em" width="0pt">ОС=$(BUILD_DIR)/ОС</p><p height="1em" width="0pt"><b>CFLAGS+=-fавтономный -nostdlib -gdwarf-4 -m32 -ggdb3</b></p><p height="1em" width="0pt">ОС_SRCS := $(<b>подстановочный знак</b>*.с)</p><p height="1em" width="0pt">ОС_OBJS := $(<b>патсубст</b>%.c, $(BUILD_DIR)/%.o, $(OS_SRCS)) все: $(OS)</p><p height="1em" width="0pt">$(BUILD_DIR)/%.o: %.c</p><p height="1em" width="0pt">gcc $(<b>CFLAGS</b>) -с $< -о<b>$@</b></p><p height="1em" width="0pt">$(ОС): $(ОС_OBJS)</p><p height="1em" width="0pt">ld -m elf_i386 -T<b>os.lds</b>$(ОС_OBJS) -о<b>$@</b></p><p height="1em" width="0pt">чистый:</p><p height="1em" width="0pt">рм $(OS_OBJS)</p><p height="1em" width="0pt">Мы обновили Makefile со следующими изменениями:</p><p height="1em" width="0pt">Добавьте переменную CFLAGS для передачи параметров в gcc.</p><p height="1em" width="0pt">Вместо правила собирать исходный код сборки раньше, оно заменено версией C с рецептом сборки исходных файлов C. Переменная CFLAGS делает команду gcc в рецепте более аккуратной, независимо от количества добавленных опций.</p><p height="1em" width="0pt">Добавьте команду компоновки для сборки окончательного исполняемого бинарного файла операционной системы с помощью пользовательского скрипта компоновщика os.lds.</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">253</p><p height="1em" width="0pt">Все выглядит хорошо, за исключением части скрипта компоновщика. Зачем это нужно?</p><p height="1em" width="0pt">Сценарий компоновщика необходим для контроля того, по какому адресу физической памяти в памяти появляется двоичный файл операционной системы, поэтому компоновщик может перейти к коду операционной системы и выполнить его. Чтобы выполнить это требование, сценарий компоновщика по умолчанию, используемый gcc, не будет работать, поскольку он предполагает, что скомпилированный исполняемый файл работает внутри существующей операционной системы, в то время как мы пишем саму операционную систему.</p><p height="1em" width="0pt">Следующий вопрос: каким будет контент в скрипте компоновщика? Чтобы ответить на этот вопрос, мы должны понять, каких целей достичь с помощью скрипта компоновщика:</p><p height="1em" width="0pt">Чтобы загрузчик правильно переходил и выполнял код операционной системы.</p><p height="1em" width="0pt">Для правильной отладки gdb с исходным кодом операционной системы.</p><p height="1em" width="0pt">Для достижения целей мы должны разработать схему подходящей схемы памяти для операционной системы. Напомним, что загрузчик, разработанный в главе<a href="#filepos574833">7</a>уже можно загрузить простой бинарник, скомпилированный из примера ассемблерной программы sample.asm. Чтобы загрузить операционную систему, мы можем просто кинуть бинарник, скомпилированный из sample.asm, с бинарником, скомпилированным из os.c выше.</p><p height="1em" width="0pt">Если только это так просто. Мысль правильная, но недостаточно. Цели предполагают следующие ограничения:</p><p height="1em" width="0pt">1. Код операционной системы написан на C и скомпилирован как ELF</p><p height="1em" width="0pt">исполняемый двоичный файл. Это означает, что загрузчик должен получить правильный адрес входа из заголовка ELF.</p><p height="1em" width="0pt">2. Для правильной отладки с помощью gdb информация об отладке должна содержать правильные сопоставления между адресами инструкций и исходным кодом.</p><p height="1em" width="0pt">Благодаря пониманию ELF и DWARF, полученному в предыдущих главах, мы, безусловно, можем изменить загрузчик и создать исполняемый двоичный файл, удовлетворяющий вышеуказанному ограничению. Мы решим эти проблемы одну за другой.</p><p height="1em" width="0pt">254</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"> <i>8.5.1 Загрузка двоичного файла ELF из загрузчика</i></p><p height="1em" width="0pt">Ранее мы рассмотрели, что ELF-заголовок содержит адрес входа программы. Согласно man elf, эта информация находится на расстоянии 0x18 байт от начала заголовка ELF:</p><p height="1em" width="0pt"><b>структура typedef</b>{</p><p height="1em" width="0pt"><b>беззнаковый символ</b>e_ident[EI_NIDENT];</p><p height="1em" width="0pt">uint16_t e_type;</p><p height="1em" width="0pt">uint16_t e_machine;</p><p height="1em" width="0pt">uint32_t электронная_версия;</p><p height="1em" width="0pt">ElfN_Addr e_entry;</p><p height="1em" width="0pt">ЭльфN_Off e_phoff;</p><p height="1em" width="0pt">ЭльфN_Off e_shoff;</p><p height="1em" width="0pt">uint32_t e_flags;</p><p height="1em" width="0pt">uint16_t e_ehsize;</p><p height="1em" width="0pt">uint16_t e_phentsize;</p><p height="1em" width="0pt">uint16_t e_phnum;</p><p height="1em" width="0pt">uint16_t e_shentsize;</p><p height="1em" width="0pt">uint16_t e_shnum;</p><p height="1em" width="0pt">uint16_t e_shstrndx;</p><p height="1em" width="0pt">} ЭльфN_Ehdr;</p><p height="1em" width="0pt">Смещение от начала структуры до начала e_entry составляет: 16 байтов e_ident[EI_NIDENT]:</p><p height="1em" width="0pt"># определить EI_NIDENT 16</p><p height="1em" width="0pt">2 байта e_type</p><p height="1em" width="0pt">2 байта e_machine</p><p height="1em" width="0pt">4 байта e_version</p><p height="1em" width="0pt">Смещение = 16 + 2 + 2 + 4 = 24 = 0x18</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">255</p><p height="1em" width="0pt">e_entry имеет тип ElfN_Addr, где N равно 32 или 64. В данном случае мы пишем 32-битную операционную систему<i>Н</i>= 32, поэтому ElfN_Addr — это Elf32_Addr, длина которого составляет 4 байта.</p><p height="1em" width="0pt"><b>Пример 8.5.1.</b>С любой программой, такой как эта простая: hello.c</p><p height="1em" width="0pt"><b>#включать</b><stdio.h></p><p height="1em" width="0pt"><b>инт</b>основной(<b>инт</b>аргк,<b>уголь</b>*argv[])</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">printf("привет␣мир!\n");</p><p height="1em" width="0pt"><b>возвращаться</b>0;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Мы можем получить адрес входа с удобочитаемым представлением, используя readelf:</p><p height="1em" width="0pt">$ gcc hello.c -o привет</p><p height="1em" width="0pt">$ readelf -h привет</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Заголовок ЭЛЬФ:</p><p height="1em" width="0pt">Магия:</p><p height="1em" width="0pt">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">.... вывод опущен ....</p><p height="1em" width="0pt">Адрес точки входа:</p><p height="1em" width="0pt">0x400430</p><p height="1em" width="0pt">.... вывод опущен ....</p><p height="1em" width="0pt">Или в необработанном двоичном формате с hd:</p><p height="1em" width="0pt">$ hd привет | меньше</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">00000000</p><p height="1em" width="0pt">7f 45 4c 46 02 01 01 00</p><p height="1em" width="0pt">00 00 00 00 00 00 00 00</p><p height="1em" width="0pt">|.ЭЛЬФ............|</p><p height="1em" width="0pt">00000010</p><p height="1em" width="0pt">02 00 3e 00 01 00 00 00</p><p height="1em" width="0pt">30 04 40 00 00 00 00 00</p><p height="1em" width="0pt">|..>.....0.@.....|</p><p height="1em" width="0pt">.........</p><p height="1em" width="0pt">Смещение 0x18 — это начало младшего байта e_entry,</p><p height="1em" width="0pt">256</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">который равен 0x30, за которым следует 04 40 00, вместе в обратном порядке получается адрес 0x00400430.</p><p height="1em" width="0pt">Теперь, когда мы знаем, где находится адрес входа в ELF</p><p height="1em" width="0pt">шапку, легко модифицировать загрузчик сделанный в разделе<a href="#filepos594548">7.6.2</a>для извлечения и перехода по адресу:</p><p height="1em" width="0pt">загрузчик.asm</p><p height="1em" width="0pt"> <i>;*********************************************</i></p><p height="1em" width="0pt"> <i>; Загрузчик.asm</i></p><p height="1em" width="0pt"> <i>; Простой загрузчик</i></p><p height="1em" width="0pt"> <i>;*********************************************</i></p><p height="1em" width="0pt">бит 16</p><p height="1em" width="0pt">начинать:<b>джмп</b>ботинок</p><p height="1em" width="0pt"> <i>;; постоянные и переменные определения</i></p><p height="1em" width="0pt">сообщение<b>дБ</b>«Добро пожаловать в мою операционную систему!», 0<b>ах</b>, 0<b>дх</b>, 0h загрузка:</p><p height="1em" width="0pt"><b>Кли</b> <i>; без прерываний</i></p><p height="1em" width="0pt"><b>cld</b> <i>; все, что нам нужно для инициализации</i></p><p height="1em" width="0pt"><b>движение</b></p><p height="1em" width="0pt"><b>топор</b>, 50ч</p><p height="1em" width="0pt"> <i>;; установить буфер</i></p><p height="1em" width="0pt"><b>движение</b>,<b>топор</b></p><p height="1em" width="0pt"><b>xor bx</b>,<b>бх</b></p><p height="1em" width="0pt"><b>двигаться аль</b>, 2</p><p height="1em" width="0pt"> <i>; читать 2 сектора</i></p><p height="1em" width="0pt"><b>мов ч</b>, 0<i>; читаем второй сектор мимо нас,</i></p><p height="1em" width="0pt"> <i>; так что все еще на ходу</i></p><p height="1em" width="0pt"> <i>0</i></p><p height="1em" width="0pt"><b>мов кл</b>, 2</p><p height="1em" width="0pt"> <i>; сектор для чтения (второй сектор)</i></p><p height="1em" width="0pt"><b>мов дх</b>, 0</p><p height="1em" width="0pt"> <i>; главный номер</i></p><p height="1em" width="0pt"><b>мов дл</b>, 0</p><p height="1em" width="0pt"> <i>; номер привода. Помните, что диск 0 является дискетой</i></p><p height="1em" width="0pt"> <i>водить машину.</i></p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">257</p><p height="1em" width="0pt"><b>мов ах</b>, 0x02</p><p height="1em" width="0pt"> <i>; функция чтения секторов дискеты</i></p><p height="1em" width="0pt"><b>инт</b>0x13</p><p height="1em" width="0pt"> <i>; вызов биоса - прочитать сектор</i></p><p height="1em" width="0pt"><b>пмп [500ч + 18ч]</b></p><p height="1em" width="0pt"> <i>; прыгай и выполняй сектор!</i></p><p height="1em" width="0pt"><b>hlt</b> <i>; остановить систему</i></p><p height="1em" width="0pt"> <i>; У нас должно быть 512 байт. Очистить остальные байты</i> <i>с 0</i></p><p height="1em" width="0pt">раз 510 - ($-$$)<b>дБ</b>0</p><p height="1em" width="0pt"><b>дв</b>0xAA55</p><p height="1em" width="0pt"> <i>; Загрузочная подпись</i></p><p height="1em" width="0pt">Это так просто! Сначала мы загружаем двоичный файл операционной системы по адресу 0x500, затем получаем адрес входа по смещению 0x18 от 0x500, предварительно вычислив выражение 500.<i>час</i>+ 18<i>час</i>= 518<i>час</i>чтобы получить фактический адрес в памяти, а затем получить содержимое, разыменовав его.</p><p height="1em" width="0pt">Первая часть сделана. Для следующей части нам нужно создать образ операционной системы ELF для загрузки загрузчика. Первым шагом является создание скрипта компоновщика:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt"><b>ВХОД(основной);</b></p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">заголовки PT_PHDR FILEHDR PHDRS;</p><p height="1em" width="0pt">код PT_LOAD;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">РАЗДЕЛЫ</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">.текст<b>0x500</b>: { *(.текст) } :код</p><p height="1em" width="0pt">.данные: {*(.данные)}</p><p height="1em" width="0pt">.bss : { *(.bss) }</p><p height="1em" width="0pt">/DISCARD/ : { *(.eh_frame) }</p><p height="1em" width="0pt">258</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Сценарий прост и остается почти таким же, как и раньше.</p><p height="1em" width="0pt">Единственные отличия:</p><p height="1em" width="0pt">main явно указываются как точка входа, указав ENTRY(main).</p><p height="1em" width="0pt">.text явно указан с 0x500 как его<i>адрес виртуальной памяти</i>так как мы загружаем образ операционной системы по адресу 0x500.</p><p height="1em" width="0pt">После того, как поставили скрипт, компилируем make и он должен работать без сбоев: $ make clean; делать</p><p height="1em" width="0pt">$ readelf -l сборка/ОС/ОС</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x500</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000500 0x00000500 0x00000500 0x00040 0x00040 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">Все выглядит хорошо, пока мы не запустим его. Начнем с запуска виртуальной машины QEMU:</p><p height="1em" width="0pt">$ сделать кему</p><p height="1em" width="0pt">Затем запустите gdb и загрузите отладочную информацию (которая также находится в том же двоичном файле) и установите точку останова на main:</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">259</p><p height="1em" width="0pt">(gdb) файл символов build/os/os</p><p height="1em" width="0pt">Чтение символов из build/os/os... готово.</p><p height="1em" width="0pt">(gdb) б основной</p><p height="1em" width="0pt">Точка останова 2 на 0x500</p><p height="1em" width="0pt">Затем запускаем программу:</p><p height="1em" width="0pt">(gdb) файл символов build/os/os</p><p height="1em" width="0pt">Чтение символов из build/os/os... готово.</p><p height="1em" width="0pt">(gdb) б основной</p><p height="1em" width="0pt">Точка останова 2 на 0x500</p><p height="1em" width="0pt">Продолжайте программирование, пока оно не остановится на main:</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt">Продолжая.</p><p height="1em" width="0pt">[0:7c00]</p><p height="1em" width="0pt">Точка останова 1, 0x00007c00 в ?? ()</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt">Продолжая.</p><p height="1em" width="0pt">[ 0: 500]</p><p height="1em" width="0pt">Точка останова 2, main() в main.c:1</p><p height="1em" width="0pt">На этом этапе мы переключаем макет на исходный код C вместо регистров:</p><p height="1em" width="0pt">(gdb) разделение макета</p><p height="1em" width="0pt">Разделение макета создает макет, состоящий из 3 меньших окон: Исходное окно вверху.</p><p height="1em" width="0pt">Окно сборки посередине.</p><p height="1em" width="0pt">Командное окно внизу.</p><p height="1em" width="0pt">После команды макет должен выглядеть так:</p><p height="1em" width="0pt">260</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">main.c</p><p height="1em" width="0pt">В+> 1</p><p height="1em" width="0pt">пустая функция(){}</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">13</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">B+> 0x500 <основной></p><p height="1em" width="0pt">jg</p><p height="1em" width="0pt">0x547</p><p height="1em" width="0pt">0x502 <основной+2></p><p height="1em" width="0pt">декабрь</p><p height="1em" width="0pt">сп</p><p height="1em" width="0pt">0x503 <основной+3></p><p height="1em" width="0pt">вкл.</p><p height="1em" width="0pt">си</p><p height="1em" width="0pt">0x504 <основной+4></p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">СЛОВО PTR [bx+di],ax</p><p height="1em" width="0pt">0x506</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">СЛОВО PTR [bx+si],ax</p><p height="1em" width="0pt">0x508</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x50a</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x50c</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x50e</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x510</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">al,BYTE PTR [bx+si]</p><p height="1em" width="0pt">0x512</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">топор,WORD PTR [bx+si]</p><p height="1em" width="0pt">0x514</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">СЛОВО PTR [bx+si],ax</p><p height="1em" width="0pt">0x516</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x518</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [di],al</p><p height="1em" width="0pt">0x51a</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">261</p><p height="1em" width="0pt">0x51c</p><p height="1em" width="0pt">xor</p><p height="1em" width="0pt">аль, 0x0</p><p height="1em" width="0pt">0x51e</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">удаленный поток 1 В: основной</p><p height="1em" width="0pt">L1</p><p height="1em" width="0pt">ПК: 0x500</p><p height="1em" width="0pt">[f000:fff0] 0x0000fff0 в ?? ()</p><p height="1em" width="0pt">Точка останова 1 на 0x7c00</p><p height="1em" width="0pt">(gdb) файл символов build/os/os</p><p height="1em" width="0pt">Чтение символов из build/os/os... готово.</p><p height="1em" width="0pt">(gdb) б основной</p><p height="1em" width="0pt">Точка останова 2 по адресу 0x500: файл main.c, строка 1.</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt">Продолжая.</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">0:7c00]</p><p height="1em" width="0pt">Точка останова 1, 0x00007c00 в ?? ()</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt">Продолжая.</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">0: 500]</p><p height="1em" width="0pt">Точка останова 2, main() в main.c:1</p><p height="1em" width="0pt">(gdb) разделение макета</p><p height="1em" width="0pt">(ГДБ)</p><p height="1em" width="0pt">Здесь происходит что-то неправильное. Это не сгенерированный ассемблерный код для вызова функции, как это известно в разделе<a href="#filepos328376">4.9.5.</a>Это определенно неправильно, проверено с помощью objdump:</p><p height="1em" width="0pt">$ objdump -D сборка/ОС/ОС | меньше</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">/home/tuhdo/workspace/os/build/os/os:</p><p height="1em" width="0pt">формат файла elf32-i386</p><p height="1em" width="0pt">Разборка раздела .text:</p><p height="1em" width="0pt">00000500 <основной>:</p><p height="1em" width="0pt">500:</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">%ebp</p><p height="1em" width="0pt">501:</p><p height="1em" width="0pt">89 e5</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">%esp,%ebp</p><p height="1em" width="0pt">503:</p><p height="1em" width="0pt">90</p><p height="1em" width="0pt">нет</p><a id="filepos752822" /><p height="1em" width="0pt">262</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">504:</p><p height="1em" width="0pt">5д</p><p height="1em" width="0pt">поп</p><p height="1em" width="0pt">%ebp</p><p height="1em" width="0pt">505:</p><p height="1em" width="0pt">с3</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">.... остальные выходные данные опущены ....</p><p height="1em" width="0pt">Ассемблерный код main совершенно другой. Вот почему важно понимать ассемблерный код и его связь с языками высокого уровня. Без этих знаний мы бы использовали gdb как простой отладчик на уровне исходного кода, не утруждая себя просмотром ассемблерного кода из разделенного макета. Как следствие, истинная причина неработающего кода так и не была обнаружена.</p><p height="1em" width="0pt"> <i>8.5.2 Отладка схемы памяти</i></p><p height="1em" width="0pt"><b>Рисунок 8.5.1:</b>Состояние памяти после</p><p height="1em" width="0pt">загрузка 2-го сектора.</p><p height="1em" width="0pt">В чем причина неправильного кода сборки в main отображается 0x0</p><p height="1em" width="0pt">гдб? Причина может быть только одна: загрузчик перескочил на неправильный 0x500</p><p height="1em" width="0pt">заголовок ELF</p><p height="1em" width="0pt">адреса. Но почему адрес был неверным? Сделали раздел .text Загружаемый контент</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">по адресу 0x500, в котором основной код находится в первом байте для выполнения, и дает указание загрузчику получить адрес по смещению 0x18, а затем перейти к адресу записи.</p><p height="1em" width="0pt">Тогда загрузчик может загрузить адрес операционной системы по неправильному адресу. Но затем мы явно установили адрес загрузки на 50h:00, что равно 0x500, поэтому использовался правильный адрес.</p><p height="1em" width="0pt">После того, как загрузчик загрузит 2-й сектор, состояние в памяти должно выглядеть так, как показано на рисунке<a href="#filepos752822">8.5.1:</a></p><p height="1em" width="0pt">0xFFFFFFFF</p><p height="1em" width="0pt">Вот проблема: 0x500 — это начало заголовка ELF. Загрузочная память</p><p height="1em" width="0pt">загрузчик фактически загружает 2-й сектор, в котором хранится исполняемый файл целиком, в 0x500. Ясно, что раздел .text, где находится main, далек от 0x500.</p><p height="1em" width="0pt">Поскольку адрес входа исполняемого двоичного файла в память — 0x500, .text должен иметь адрес 0x500 + 0x500 = 0xa00. Однако адрес входа, записанный в заголовке ELF, остается 0x500 и в результате загрузчик перепрыгнул туда вместо 0xa00. Это одна из проблем, которые необходимо исправить.</p><p height="1em" width="0pt">Другой проблемой является сопоставление между отладочной информацией и адресом памяти. Поскольку отладочная информация компилируется с предполагаемым смещением 0x500</p><p height="1em" width="0pt">это начало раздела .text, но из-за фактической загрузки смещение увеличивается еще на 0x500 байт, в результате чего адрес фактически равен 0xa00.</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">263</p><p height="1em" width="0pt">Это несоответствие памяти делает отладочную информацию бесполезной.</p><p height="1em" width="0pt">0x0</p><p height="1em" width="0pt">Отладочная информация</p><p height="1em" width="0pt">0x500</p><p height="1em" width="0pt"><b>Рисунок 8.5.2:</b>Неправильный символ-</p><p height="1em" width="0pt">заголовок ELF</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">отображения памяти в отладочной информации.</p><p height="1em" width="0pt">Загруженный контент</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">Информация об отладке</p><p height="1em" width="0pt">должен быть здесь</p><p height="1em" width="0pt">0xFFFFFFFF</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt">В общем, у нас есть 2 проблемы, которые нужно решить:</p><p height="1em" width="0pt">Исправьте адрес входа, чтобы учесть дополнительное смещение при загрузке в память.</p><p height="1em" width="0pt">Исправьте отладочную информацию, чтобы учесть дополнительное смещение при загрузке в память.</p><p height="1em" width="0pt">Во-первых, нам нужно знать фактическую структуру скомпилированного исполняемого файла:</p><p height="1em" width="0pt">$ readelf -l сборка/ОС/ОС</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x500</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000500 0x00000500 0x00000500 0x00040 0x00040 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">264</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">Обратите внимание на поля Offset и VirtAddress: оба имеют одинаковое значение. Это проблематично, поскольку адрес входа и адреса памяти в отладочной информации зависят от поля VirtAddr, но смещение, имеющее то же значение, разрушает действительность VirtAddr18, поскольку это означает, что 18 Смещение — это расстояние в байтах.</p><p height="1em" width="0pt">между началом файла,</p><p height="1em" width="0pt">реальный адрес в памяти всегда будет больше, чем VirtAddr.</p><p height="1em" width="0pt">адрес 0, на начальный адрес</p><p height="1em" width="0pt">сегмент или раздел.</p><p height="1em" width="0pt">Если мы попытаемся настроить адрес виртуальной памяти раздела .text в скрипте компоновщика os.lds, любое значение, которое мы установим, также установит смещение на то же значение, пока мы не установим его на некоторое значение, равное или превышающее 0x1074:<b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x1074</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000074 0x00001074 0x00001074 0x00006 0x00006 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">Если мы настроим виртуальный адрес на 0x1073, и Offset, и VirtAddr по-прежнему будут иметь одно и то же значение:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x1073</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001073 0x00001073 0x00001073 0x00006 0x00006 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">265</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">Ключ к ответу на такой феномен находится в поле Align. Значение 0x1000 указывает, что адрес смещения сегмента должен делиться на 0x1000, или, если расстояние между сегментами делится на 0x1000, компоновщик удаляет такое расстояние, чтобы сохранить двоичный размер. Мы можем провести несколько экспериментов, чтобы проверить это утверждение19:</p><p height="1em" width="0pt">19 Все выходы производятся</p><p height="1em" width="0pt">команда:</p><p height="1em" width="0pt">$ readelf -l сборка/ОС/ОС</p><p height="1em" width="0pt">Установив виртуальный адрес .text от 0x0 до 0x73 (в os.lds), смещение начинается с 0x1000 до 0x1073 соответственно. Например, установив его на 0x0:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x0</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x001000 0x00000000 0x00000000 0x00006 0x00006 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">По умолчанию, если мы не указываем никакого виртуального адреса, смещение остается равным 0x1000, потому что 0x1000 — идеальное смещение для удовлетворения ограничения выравнивания. Любое добавление от 0x1 до 0x73 приводит к смещению сегмента, но компоновщик все равно сохраняет его, потому что ему так сказано.</p><p height="1em" width="0pt">Установив виртуальный адрес .text на 0x74 (в os.lds):<b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x74</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">266</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000074 0x00000074 0x00000074 0x00006 0x00006 ЧТ 0x1000</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">PHDR имеет размер 0x74 байта, поэтому, если LOAD начинается с 0x1074, расстояние между сегментом PHDR и сегментом LOAD равно 0x1074 - 0x74 = 0x1000.</p><p height="1em" width="0pt">байт. Для экономии места он удаляет лишние 0x1000 байт.</p><p height="1em" width="0pt">При установке виртуального адреса .text на любое значение от 0x75 до 0x1073 (в os.lds) смещение принимает точные указанные значения, как это видно в случае установки 0x1073 выше.</p><p height="1em" width="0pt">Установив виртуальный адрес .text на любое значение, равное или большее 0x1074: все начинается сначала с 0x74, где расстояние равно 0x1000 байт.</p><p height="1em" width="0pt">Теперь мы получаем подсказку, как управлять значениями Offset и VirtAddr для получения желаемого двоичного макета. Что нам нужно, так это изменить поле Align на значение с меньшим значением для более точного контроля зернистости. Это может сработать с двоичным макетом следующим образом:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x600</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000100 0x00000600 0x00000600 0x00006 0x00006 ЧТ 0x100</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><a id="filepos766602" /><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">267</p><p height="1em" width="0pt">Двоичный файл будет выглядеть как рисунок<a href="#filepos766602">8.5.3</a>в памяти: 0x0</p><p height="1em" width="0pt">0x500</p><p height="1em" width="0pt"><b>Рисунок 8.5.3:</b>Хороший</p><p height="1em" width="0pt">бинарный</p><p height="1em" width="0pt">заголовок ELF</p><p height="1em" width="0pt">Отладочная информация</p><p height="1em" width="0pt">макет.</p><p height="1em" width="0pt">0x100</p><p height="1em" width="0pt">0x600</p><p height="1em" width="0pt">Загруженный контент</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt">0xFFFFFFFF</p><p height="1em" width="0pt">Память</p><p height="1em" width="0pt">Если мы установим поле Offset в 0x100 от начала файла и VirtAddr в 0x600, при загрузке в память фактическая память</p><p height="1em" width="0pt">.текст 0x500 + 0x100 = 0x600; 0x500 — это место в памяти, где загрузчик загружается в физическую память, а 0x100 — это смещение от конца заголовка ELF до .text. Адрес входа и отладочная информация примут значение 0x600 из поля VirtAddr выше, что полностью соответствует фактическому физическому расположению. Мы можем сделать это, изменив os.lds следующим образом:</p><p height="1em" width="0pt">main.lds</p><p height="1em" width="0pt"><b>ВХОД(основной);</b></p><p height="1em" width="0pt">PHDRS</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">заголовки PT_PHDR FILEHDR PHDRS;</p><p height="1em" width="0pt">код PT_LOAD;</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">РАЗДЕЛЫ</p><p height="1em" width="0pt">{</p><p height="1em" width="0pt">.текст<b>0x600</b>: ВЫРАВНИВАНИЕ(0x100) { *(.текст) } :код</p><p height="1em" width="0pt">268</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">.данные: {*(.данные)}</p><p height="1em" width="0pt">.bss : { *(.bss) }</p><p height="1em" width="0pt">/DISCARD/ : { *(.eh_frame) }</p><p height="1em" width="0pt">}</p><p height="1em" width="0pt">Ключевое слово ALIGN, как оно подразумевает, указывает компоновщику выровнять раздел, то есть сегмент, содержащий его. Однако, чтобы ключевое слово ALIGN имело какой-либо эффект, автоматическое выравнивание должно быть отключено. По словам человека ld:<b>Выход</b></p><p height="1em" width="0pt">-н</p><p height="1em" width="0pt">--nmagic</p><p height="1em" width="0pt">Отключите выравнивание страниц разделов и отключите связывание с общими библиотеками.</p><p height="1em" width="0pt">Если выходной формат поддерживает магические числа в стиле Unix, пометьте вывод как «NMAGIC».</p><p height="1em" width="0pt">То есть по умолчанию каждый раздел выравнивается по странице операционной системы, которая имеет размер 4096 или 0x1000 байт. Параметр -n или -nmagic отключает это поведение, которое необходимо. Изменяем команду ld, используемую в os/Makefile: os/Makefile</p><p height="1em" width="0pt">..... содержание выше опущено ....</p><p height="1em" width="0pt">$(ОС): $(ОС_OBJS)</p><p height="1em" width="0pt">ld -m elf_i386<b>-нмагия</b>-Tos.lds $(OS_OBJS) -o<b>$@</b></p><p height="1em" width="0pt">Наконец, нам также необходимо обновить Makefile верхнего уровня, чтобы записать более одного сектора в образ диска для двоичного файла операционной системы, так как его размер превышает один сектор:</p><p height="1em" width="0pt">$ ls -l сборка/ОС/ОС</p><p height="1em" width="0pt">-rwxrwxr-x 1 tuhdo tuhdo 9060 13 фев 21:37 build/os/os Обновляем правило, чтобы сектора вычислялись автоматически: os/Makefile</p><p height="1em" width="0pt">..... содержание выше опущено ....</p><p height="1em" width="0pt">загрузочный диск: ОС загрузчика</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">269</p><p height="1em" width="0pt">dd if=/dev/zero of=$(DISK_IMG) bs=512 count=2880</p><p height="1em" width="0pt">dd conv=notrunc if=$(BOOTLOADER) of=$(DISK_IMG) bs=512</p><p height="1em" width="0pt">количество = 1 поиск = 0</p><p height="1em" width="0pt">dd conv=notrunc if=$(OS) of=$(DISK_IMG) bs=512 count=$$</p><p height="1em" width="0pt">(($(<b>оболочка</b>stat --printf="%s" $(OS))/512)) seek=1</p><p height="1em" width="0pt">Обновляем все, перекомпилируем исполняемый бинарник и получаем нужное смещение и виртуальную память по 0x100 и 0x600 соответственно:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">Тип файла Elf - EXEC (исполняемый файл)</p><p height="1em" width="0pt">Точка входа 0x600</p><p height="1em" width="0pt">Есть 2 заголовка программы, начиная со смещения 52</p><p height="1em" width="0pt">Заголовки программы:</p><p height="1em" width="0pt">Тип</p><p height="1em" width="0pt">Компенсировать</p><p height="1em" width="0pt">VirtAddr</p><p height="1em" width="0pt">PhysAddr</p><p height="1em" width="0pt">FileSiz MemSiz</p><p height="1em" width="0pt">Флг Выровнять</p><p height="1em" width="0pt">ФДР</p><p height="1em" width="0pt">0x000000 0x00000000 0x00000000 0x00074 0x00074 Ч</p><p height="1em" width="0pt">0x4</p><p height="1em" width="0pt">НАГРУЗКА</p><p height="1em" width="0pt">0x000100 0x00000600 0x00000600 0x00006 0x00006 ЧТ 0x100</p><p height="1em" width="0pt">Сопоставление раздела с сегментом:</p><p height="1em" width="0pt">Разделы сегмента...</p><p height="1em" width="0pt">00</p><p height="1em" width="0pt">01</p><p height="1em" width="0pt">.текст</p><p height="1em" width="0pt"> <i>8.5.3 Тестирование нового двоичного файла</i></p><p height="1em" width="0pt">Сначала запускаем машину QEMU:</p><p height="1em" width="0pt">$ сделать кему</p><p height="1em" width="0pt">В другом терминале запускаем gdb, загружаем отладочную информацию и устанавливаем точку останова на main:</p><p height="1em" width="0pt">$ gdb</p><p height="1em" width="0pt">Должен быть получен следующий вывод:</p><p height="1em" width="0pt">270</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">--- Введите <return> для продолжения или q <return> для выхода---</p><p height="1em" width="0pt">[f000:fff0] 0x0000fff0 в ?? ()</p><p height="1em" width="0pt">Точка останова 1 на 0x7c00</p><p height="1em" width="0pt">Точка останова 2 по адресу 0x600: файл main.c, строка 1.</p><p height="1em" width="0pt">Затем пусть gdb работает до тех пор, пока он не достигнет основной функции, затем мы переходим к разделенному макету между исходным кодом и сборкой:</p><p height="1em" width="0pt">(gdb) разделение макета</p><p height="1em" width="0pt">Окончательный вывод терминала должен выглядеть так:</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">main.c</p><p height="1em" width="0pt">В+> 1</p><p height="1em" width="0pt">пустая функция(){}</p><p height="1em" width="0pt">2</p><p height="1em" width="0pt">3</p><p height="1em" width="0pt">4</p><p height="1em" width="0pt">5</p><p height="1em" width="0pt">6</p><p height="1em" width="0pt">7</p><p height="1em" width="0pt">8</p><p height="1em" width="0pt">9</p><p height="1em" width="0pt">10</p><p height="1em" width="0pt">11</p><p height="1em" width="0pt">12</p><p height="1em" width="0pt">13</p><p height="1em" width="0pt">14</p><p height="1em" width="0pt">15</p><p height="1em" width="0pt">16</p><p height="1em" width="0pt">B+> 0x600 <основной></p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">бп</p><p height="1em" width="0pt">0x601 <основной+1></p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">бп, сп</p><p height="1em" width="0pt">0x603 <основной+3></p><p height="1em" width="0pt">нет</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">271</p><p height="1em" width="0pt">0x604 <основной+4></p><p height="1em" width="0pt">поп</p><p height="1em" width="0pt">бп</p><p height="1em" width="0pt">0x605 <основной+5></p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">0x606</p><p height="1em" width="0pt">ааа</p><p height="1em" width="0pt">0x607</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x609</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [si],al</p><p height="1em" width="0pt">0x60b</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x60d</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x60f</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [si],al</p><p height="1em" width="0pt">0x611</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">топор, бп</p><p height="1em" width="0pt">0x613</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">SS</p><p height="1em" width="0pt">0x614</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si],al</p><p height="1em" width="0pt">0x616</p><p height="1em" width="0pt">или</p><p height="1em" width="0pt">ал, 0x67</p><p height="1em" width="0pt">0x618</p><p height="1em" width="0pt">адк</p><p height="1em" width="0pt">al,BYTE PTR [bx+si]</p><p height="1em" width="0pt">0x61a</p><p height="1em" width="0pt">добавлять</p><p height="1em" width="0pt">БАЙТ PTR [bx+si+0x2],al</p><p height="1em" width="0pt">удаленный поток 1 В: основной</p><p height="1em" width="0pt">L1</p><p height="1em" width="0pt">ПК: 0x600</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt">Продолжая.</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">0:7c00]</p><p height="1em" width="0pt">Точка останова 1, 0x00007c00 в ?? ()</p><p height="1em" width="0pt">(гдб) с</p><p height="1em" width="0pt">Продолжая.</p><p height="1em" width="0pt">[</p><p height="1em" width="0pt">0: 600]</p><p height="1em" width="0pt">Точка останова 2, main() в main.c:1</p><p height="1em" width="0pt">(gdb) разделение макета</p><p height="1em" width="0pt">Теперь отображаемая сборка такая же, как и в objdump, за исключением того, что регистры 16-битные. Это нормально, так как gdb работает в 16-битном режиме, а objdump отображает код в 32-битном режиме. Чтобы убедиться, мы проверяем необработанный код операции с помощью команды x:</p><p height="1em" width="0pt">(гдб) х/16хб 0x600</p><p height="1em" width="0pt">272</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">0x600 <основной>:</p><p height="1em" width="0pt">0x55</p><p height="1em" width="0pt">0x89</p><p height="1em" width="0pt">0xe5</p><p height="1em" width="0pt">0x90</p><p height="1em" width="0pt">0x5d</p><p height="1em" width="0pt">0xc3</p><p height="1em" width="0pt">0x37</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">0x608:</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">0x04</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">0x00</p><p height="1em" width="0pt">Из окна сборки main останавливается на адресе 0x605. Таким образом, соответствующие байты от 0x600 до 0x605 выделены красным цветом в выводе команды x/16xb 0x600. Затем необработанный код операции из вывода objdump:</p><p height="1em" width="0pt">$ objdump -z -M intel -S -D сборка/ОС/ОС | меньше</p><p height="1em" width="0pt"><b>Выход</b></p><p height="1em" width="0pt">сборка/ОС/ОС:</p><p height="1em" width="0pt">формат файла elf32-i386</p><p height="1em" width="0pt">Разборка раздела .text:</p><p height="1em" width="0pt">00000600 <основной>:</p><p height="1em" width="0pt">пустая функция(){}</p><p height="1em" width="0pt">600:</p><p height="1em" width="0pt">55</p><p height="1em" width="0pt">толкать</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">601:</p><p height="1em" width="0pt">89 e5</p><p height="1em" width="0pt">движение</p><p height="1em" width="0pt">е.и.п., особенно</p><p height="1em" width="0pt">603:</p><p height="1em" width="0pt">90</p><p height="1em" width="0pt">нет</p><p height="1em" width="0pt">604:</p><p height="1em" width="0pt">5д</p><p height="1em" width="0pt">поп</p><p height="1em" width="0pt">ebp</p><p height="1em" width="0pt">605:</p><p height="1em" width="0pt">с3</p><p height="1em" width="0pt">рет</p><p height="1em" width="0pt">Разборка раздела .debug_info:</p><p height="1em" width="0pt">...... вывод опущен ......</p><p height="1em" width="0pt">Оба необработанных кода операции, отображаемые двумя программами, одинаковы. В данном случае было доказано, что gdb правильно перешел на адрес в main для корректной отладки. Это чрезвычайно важная веха. Возможность отладки на «голом железе» очень поможет при написании операционной системы, так как отладчик позволяет программисту проверять внутреннее состояние работающей машины на каждом этапе, чтобы шаг за шагом проверять свой код, чтобы постепенно достичь четкого понимания. . Некоторым профессиональным программистам не нравятся отладчики, но это потому, что они достаточно глубоко понимают свою предметную область, чтобы не полагаться на отладчик для проверки своего кода. При столкновении с новыми доменами отладчик является незаменимым инструментом обучения из-за его проверяемости.</p><p height="1em" width="0pt">линковка и загрузка на голое железо</p><p height="1em" width="0pt">273</p><p height="1em" width="0pt">Однако даже с помощью отладчика написание операционной системы все равно не является легкой прогулкой. Отладчик может дать доступ к машине в какой-то момент времени, но не дает причину. Выяснить первопричину, зависит от способностей программиста. Далее в книге мы узнаем, как использовать другие методы отладки, такие как использование QEMU.</p><p height="1em" width="0pt">средство ведения журнала для отладки исключений ЦП.</p><p height="1em" width="0pt"> <a id="filepos780273" /><b>Часть 3</b></p><p height="1em" width="0pt"><b>Программирование ядра</b></p><p height="1em" width="0pt"> <a id="filepos780385" /><b>9</b></p><p height="1em" width="0pt">x86-дескрипторы</p><p height="1em" width="0pt"><b>9.1</b></p><p height="1em" width="0pt"><b>Основные понятия операционной системы</b></p><p height="1em" width="0pt">В первую очередь ОС управляет аппаратными ресурсами. Основные функции ОС легко увидеть на основе диаграммы фон Неймана:<i>Управление процессором:</i>позволяет программам совместно использовать процессор для многозадачности.</p><p height="1em" width="0pt"> <i>Управление памятью:</i>выделяет достаточно памяти для запуска программ.</p><p height="1em" width="0pt"> <i>Управление устройствами:</i>обнаруживает различные устройства и взаимодействует с ними Любая ОС должна хорошо справляться с перечисленными выше базовыми задачами.</p><p height="1em" width="0pt">Еще одной важной особенностью ОС является предоставление слоя программного интерфейса, скрывающего аппаратные интерфейсы, для взаимодействия с приложениями, работающими поверх этой ОС. Преимущества такого уровня: повторное использование: то есть один и тот же программный API можно повторно использовать в разных программах, что упрощает процесс разработки программного обеспечения.</p><p height="1em" width="0pt">разделение проблем: баги появляются либо в прикладных программах, либо в ОС; программист должен изолировать, где находятся ошибки.</p><p height="1em" width="0pt">упростить процесс разработки программного обеспечения: обеспечивает более простой в использовании уровень программного интерфейса с унифицированным доступом к аппаратным ресурсам через</p><p height="1em" width="0pt">278</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">устройств вместо прямого использования аппаратного интерфейса конкретного устройства.</p><p height="1em" width="0pt"> <i>9.1.1 Уровень аппаратной абстракции</i></p><p height="1em" width="0pt">Существует так много аппаратных устройств, поэтому лучше оставить инженерам аппаратного обеспечения то, как устройства взаимодействуют с ОС. Для достижения этой цели ОС предоставляет только набор согласованных программных интерфейсов между собой и авторами драйверов устройств и называется<i>Уровень аппаратной абстракции</i>.</p><p height="1em" width="0pt">В C этот программный интерфейс реализован через указатели функций структуры.</p><p height="1em" width="0pt">[показать на примере Linux]</p><p height="1em" width="0pt"> <i>9.1.2 Интерфейс системного программирования</i></p><p height="1em" width="0pt"> <i>Интерфейсы системного программирования</i>являются стандартными интерфейсами, которые операционная система предоставляет прикладным программам для использования своих служб. Например, если программа хочет прочитать файл на диске, она должна вызвать такую ​​функцию, как<i>открыть()</i>и пусть ОС обрабатывает детали разговора с жестким диском для извлечения файла.</p><p height="1em" width="0pt"> <i>9.1.3 Потребность в операционной системе</i></p><p height="1em" width="0pt">В каком-то смысле ОС — это накладные расходы, но они необходимы для того, чтобы пользователь говорил компьютеру, что делать. Когда ресурсы в компьютерной системе (процессор, графический процессор, память, жесткий диск...) стали большими и сложными, вручную управлять всеми ресурсами становится утомительно.</p><p height="1em" width="0pt">Представьте, что нам нужно вручную загружать программы на компьютер с 3 ГБ памяти.</p><p height="1em" width="0pt">оперативной памяти. Нам пришлось бы загружать программы по разным адресам исправлений, и для каждой программы размер должен быть рассчитан вручную, чтобы не тратить ресурсы памяти, и достаточно, чтобы программы не переопределяли друг друга.</p><p height="1em" width="0pt">Или, когда мы хотим дать компьютеру ввод с клавиатуры без ОС, приложение также должно содержать код для облегчения связи с аппаратной клавиатурой; затем каждое приложение самостоятельно обрабатывает такое взаимодействие с клавиатурой. Почему должно быть такое дублирование в приложениях для такой стандартной функции? Если вы пишете ак-</p><a id="filepos784047" /><p height="1em" width="0pt">дескрипторы x86</p><p height="1em" width="0pt">279</p><p height="1em" width="0pt">считая программное обеспечение, почему программист должен заниматься написанием драйвера клавиатуры, совершенно не относящегося к предметной области?</p><p height="1em" width="0pt">Вот почему важной задачей ОС является скрытие сложности аппаратных устройств, поэтому программа освобождается от бремени поддержки собственного кода для аппаратной связи благодаря стандартизированному набору интерфейсов и, таким образом, уменьшает количество потенциальных ошибок и ускоряет разработку. время.</p><p height="1em" width="0pt">Чтобы эффективно написать ОС, программист должен хорошо понимать базовую архитектуру компьютера, на которой программист пишет ОС.</p><p height="1em" width="0pt">для. Первая причина заключается в том, что многие концепции ОС поддерживаются архитектурой, например. концепции виртуальной памяти хорошо поддерживаются архитектурой x86. Если базовая компьютерная архитектура недостаточно хорошо изучена, разработчики ОС обречены заново изобретать ее в вашей ОС, и такие программно-реализованные решения работают медленнее, чем аппаратная версия.</p><p height="1em" width="0pt"><b>9.2</b></p><p height="1em" width="0pt"><b>Драйверы</b></p><p height="1em" width="0pt">Драйверы — это программы, которые позволяют ОС обмениваться данными и использовать функции аппаратных устройств. Например, драйвер клавиатуры позволяет ОС получать ввод с клавиатуры; или сетевой драйвер позволяет сетевой карте отправлять и получать пакеты данных в Интернет и из Интернета.</p><p height="1em" width="0pt">Если вы пишете только прикладные программы, вы можете задаться вопросом, как программное обеспечение может управлять аппаратными устройствами? Как упоминалось в главе 2, через аппаратно-программный интерфейс: путем записи в регистры устройства или записи в порты устройства с помощью инструкций ЦП.</p><p height="1em" width="0pt"><b>9.3</b></p><p height="1em" width="0pt"><b>Пользовательское пространство и пространство ядра</b></p><p height="1em" width="0pt"> <i>Пространство ядра</i>относится к рабочей среде ОС, к которой может получить доступ только ядро. Пространство ядра включает прямую связь с оборудованием или управление привилегированными областями памяти (такими как код ядра и данные).</p><p height="1em" width="0pt">В отличие,<i>пользовательское пространство</i>относится к менее привилегированным процессам, которые выполняются поверх ОС и контролируются ОС. Чтобы получить доступ к средствам ядра, пользователь</p><a id="filepos786399" /><p height="1em" width="0pt">280</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">программа должна пройти через стандартизированные интерфейсы системного программирования, предоставляемые ОС.</p><p height="1em" width="0pt"><b>9.4</b></p><p height="1em" width="0pt"><b>Сегмент памяти</b></p><p height="1em" width="0pt"><b>9,5</b></p><p height="1em" width="0pt"><b>Дескриптор сегмента</b></p><p height="1em" width="0pt"><b>9,6</b></p><p height="1em" width="0pt"><b>Типы дескрипторов сегментов</b></p><p height="1em" width="0pt"> <i>9.6.1 Дескрипторы кода и данных</i></p><p height="1em" width="0pt"> <i>9.6.2 Дескриптор задачи</i></p><p height="1em" width="0pt"> <i>9.6.3 Дескриптор прерывания</i></p><p height="1em" width="0pt"><b>9,7</b></p><p height="1em" width="0pt"><b>Область дескриптора</b></p><p height="1em" width="0pt"> <i>9.7.1 Глобальный дескриптор</i></p><p height="1em" width="0pt"> <i>9.7.2 Локальный дескриптор</i></p><p height="1em" width="0pt"><b>9,8</b></p><p height="1em" width="0pt"><b>Выбор сегмента</b></p><p height="1em" width="0pt"><b>9,9</b></p><p height="1em" width="0pt"><b>Улучшение: загрузчик с дескрипторами</b></p><a id="filepos787560" /><p height="1em" width="0pt"><b>10</b></p><p height="1em" width="0pt">Процесс</p><p height="1em" width="0pt"><b>10.1</b></p><p height="1em" width="0pt"><b>Концепции</b></p><p height="1em" width="0pt"><b>10.2</b></p><p height="1em" width="0pt"><b>Процесс</b></p><p height="1em" width="0pt"> <i>10.2.1 Задача</i></p><p height="1em" width="0pt">А<i>задача</i>это единица работы, которую должна выполнять ОС, подобно тому, как люди выполняют ежедневные задачи. С точки зрения пользователя задачей компьютера может быть просмотр веб-страниц, редактирование документов, игры, отправка и получение электронной почты и т. д. Поскольку ЦП может выполнять только последовательно одну инструкцию за другой (выборка из основной памяти), должен быть какой-то способ выполнять много значимых задач одновременно. По этой причине компьютер должен совместно использовать ресурсы, например. регистры, стек, память и т. д. между задачами, поскольку у нас много задач, но единственные и ограниченные ресурсы.</p><p height="1em" width="0pt"> <i>10.2.2 Процесс</i></p><p height="1em" width="0pt"> <i>Процесс</i>это структура данных, которая отслеживает состояние выполнения задачи. Задача — это общее понятие, а процесс — реализация задачи. В ОС общего назначения задача обычно представляет собой программу. Например, когда вы запускаете Firefox, создается структура процесса, чтобы отслеживать, где находятся стек и куча, выделенные для firefox, где Firefox</p><p height="1em" width="0pt">282</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">область кода и какую инструкцию EIP удерживает для выполнения следующей и т. д.</p><p height="1em" width="0pt">Типичная структура процесса выглядит так:</p><p height="1em" width="0pt">[вставить изображение процесса]</p><p height="1em" width="0pt">Процесс — это виртуальный компьютер, но гораздо более примитивный, чем виртуальная машина в программном обеспечении для виртуализации, таком как Virtual Box, и это хорошо. Представьте, что вам нужно запускать полноценную виртуальную машину для каждой задачи; насколько это было бы расточительно для машинных ресурсов. С точки зрения запущенного процесса его код выполняется так, как если бы он выполнялся непосредственно на оборудовании. Каждый процесс имеет свой собственный набор значений регистров, которые отслеживаются операционной системой, и собственное непрерывное пространство виртуальной памяти (которое не является непрерывным в реальной физической памяти). Код в процессе получает адреса виртуальной памяти для чтения и записи.</p><p height="1em" width="0pt">[иллюстрация: - процесс выглядит как мини-фон Нейман - с непрерывной памятью, каждый со своим цветом; каждая ячейка процесса сопоставляется с удаленной ячейкой памяти в физической памяти]</p><p height="1em" width="0pt">Процесс может работать так долго, пока ОС не сообщит ему о временной остановке, чтобы другие задачи могли использовать аппаратные ресурсы. Затем приостановленный процесс может ждать дальнейшего уведомления от ОС. Весь этот процесс переключения настолько быстр, что пользователь компьютера думает, что его компьютер на самом деле выполняет задачи параллельно. Программа, выполняющая переключение между задачами, называется *планировщиком*.</p><p height="1em" width="0pt"> <i>10.2.3 Планировщик</i></p><p height="1em" width="0pt">ОС должна выполнять широкий спектр различных функций, например. просмотр веб-страниц, редактирование документов, игры и т. д. A<i>планировщик</i>решает, какие задачи должны выполняться раньше других и как долго эффективно. Планировщик позволяет вашему компьютеру стать<i>система разделения времени</i>, потому что задачи разделяют время выполнения ЦП, и ни один процесс не может монополизировать ЦП.</p><p height="1em" width="0pt">(на практике это до сих пор случается регулярно). Без планировщика одновременно может выполняться только одна задача.</p><p height="1em" width="0pt"> <i>10.2.4 Переключение контекста</i></p><p height="1em" width="0pt">Когда процесс готовится к переключению, чтобы другой процесс занял его место, определенные аппаратные ресурсы, т. е. текущие открытые файлы, текущая регистрация,</p><a id="filepos791371" /><p height="1em" width="0pt">процесс</p><p height="1em" width="0pt">283</p><p height="1em" width="0pt">значения ter и т. д. должны быть скопированы для последующего возобновления выполнения этого процесса.</p><p height="1em" width="0pt"> <i>10.2.5 Приоритет</i></p><p height="1em" width="0pt"> <i>приоритет</i>является важным показателем для ОС, чтобы решить, какая задача должна быть запущена раньше других, чтобы выделить соответствующее время выполнения ЦП для каждой задачи.</p><p height="1em" width="0pt"> <i>10.2.6 Упреждающий и неупреждающий</i></p><p height="1em" width="0pt">А<i>превентивный</i>ОС может прервать выполняющийся процесс и переключиться на другой процесс.</p><p height="1em" width="0pt">А<i>неупреждающий</i>ОС задача выполняется до своего завершения.</p><p height="1em" width="0pt"> <i>10.2.7 Состояния процесса</i></p><p height="1em" width="0pt"> <i>Состояние</i>это особое состояние процесса, запускаемое действием планировщика. Процесс проходит через различные состояния в течение своего жизненного цикла. Процесс обычно имеет следующие состояния:</p><p height="1em" width="0pt"> <i>Бегать</i>указывает, что ЦП выполняет код в этом процессе.</p><p height="1em" width="0pt"> <i>Спать</i>(или приостановлено): указывает, что ЦП выполняет какой-то другой процесс.</p><p height="1em" width="0pt"> <i>Уничтожено:</i>процесс завершен и ожидает полного уничтожения.</p><p height="1em" width="0pt"> <i>10.2.8 процедур</i></p><p height="1em" width="0pt"><b>10.3</b></p><p height="1em" width="0pt"><b>Потоки</b></p><p height="1em" width="0pt"> <i>Потоки</i>единицы работы внутри процесса, который разделяет среду выполнения. Процесс создает совершенно новую среду выполнения с собственным кодом:</p><p height="1em" width="0pt">[Иллюстрация между процессом и потоком, где каждый процесс представляет собой большой прямоугольник, а вложенные блоки потоков указывают на разные области кода]</p><p height="1em" width="0pt">Вместо создания в памяти совершенно новой структуры процесса ОС</p><p height="1em" width="0pt">просто позвольте потоку использовать некоторые ресурсы родительского процесса, который его создал. Поток имеет свои регистры, счетчик команд, стек.</p><a id="filepos793483" /><p height="1em" width="0pt">284</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">указатель и собственный стек вызовов. Все остальное совместно используется потоками, например, адресное пространство, куча, статические данные и сегменты кода, а также файловые дескрипторы. Поскольку поток просто повторно использует существующие ресурсы и не требует переключения контекста, гораздо быстрее создавать процессы и переключаться между ними.</p><p height="1em" width="0pt">Однако обратите внимание, что приведенная выше схема является всего лишь реализацией концепции потока. Вы можете полностью рассматривать поток так же, как процесс (следовательно, вы можете называть все процессы потоками и наоборот). Или вы можете просто создать резервную копию некоторых ресурсов, оставив некоторые ресурсы общими. Это зависит от ОС</p><p height="1em" width="0pt">Designer различать потоки и процессы. Потоки обычно реализуются как компонент процесса.</p><p height="1em" width="0pt">В Linux поток — это просто процесс, который совместно использует ресурсы со своим родительским процессом; по этой причине поток Linux также называется *облегченным процессом*. Или, другими словами, поток в Linux — это просто реализация однопоточного процесса, выполняющего основной программный код. Многопоточная программа в Linux — это просто процесс, совместно используемый с его однопоточными дочерними процессами, каждый из которых указывает на другую область кода своего родительского процесса.</p><p height="1em" width="0pt">[TODO: превратить приведенную выше таблицу в диаграмму]</p><p height="1em" width="0pt">В Windows потоки и процессы — это две отдельные сущности, поэтому приведенное выше описание для Linux неприменимо. Однако общая идея: поток разделяет среду выполнения, сохраняется.</p><p height="1em" width="0pt"><b>10.4</b></p><p height="1em" width="0pt"><b>Задача: x86 концепция процесса</b></p><p height="1em" width="0pt"><b>10,5</b></p><p height="1em" width="0pt"><b>Структура данных задачи</b></p><p height="1em" width="0pt"> <i>10.5.1 Сегмент состояния задачи</i></p><p height="1em" width="0pt"> <i>10.5.2 Дескриптор задачи</i></p><p height="1em" width="0pt"><b>10,6</b></p><p height="1em" width="0pt"><b>Реализация процесса</b></p><p height="1em" width="0pt"> <i>10.6.1 Требования</i></p><a id="filepos795678" /><p height="1em" width="0pt">процесс</p><p height="1em" width="0pt">285</p><p height="1em" width="0pt"> <i>10.6.2 Основной план</i></p><p height="1em" width="0pt"> <i>10.6.3 Этап 1: Переключиться на задачу из загрузчика</i></p><p height="1em" width="0pt"> <i>10.6.4 Этап 2: Переключиться на задачу с одной функцией из ядра</i> <i>10.6.5 Этап 3: Переключиться на задачу с большим количеством функций из ядра</i>Чтобы реализовать концепцию процесса, ядро ​​должно иметь возможность сохранять и восстанавливать состояния своей машины для различных задач.</p><p height="1em" width="0pt"> <i>Описание</i>[Опишите механизм переключения задач с использованием LDT и GDT]</p><p height="1em" width="0pt">qasdfasdf asd</p><p height="1em" width="0pt"> <i>Ограничения</i></p><p height="1em" width="0pt"> <i>Дизайн</i></p><p height="1em" width="0pt"> <i>План реализации</i></p><p height="1em" width="0pt"><b>10,7</b></p><p height="1em" width="0pt"><b>Веха: рефакторинг кода</b></p><p height="1em" width="0pt"> <a id="filepos796642" /><b>11</b></p><p height="1em" width="0pt">Прерывать</p><p height="1em" width="0pt"> <a id="filepos796732" /><b>12</b></p><p height="1em" width="0pt">Управление памятью</p><p height="1em" width="0pt"> <i>12.0.1 Адресное пространство</i></p><p height="1em" width="0pt"> <i>Адресное пространство</i>это набор всех адресуемых ячеек памяти. В адресе физической памяти есть 2 типа адресных пространств: Одно для памяти:</p><p height="1em" width="0pt">Один для ввода/вывода:</p><p height="1em" width="0pt">У каждого процесса есть собственное адресное пространство, и он может делать все, что захочет, пока не исчерпана физическая память. Это адресное пространство называется<i>виртуальная память</i>.</p><p height="1em" width="0pt"> <i>12.0.2 Виртуальная память</i></p><p height="1em" width="0pt">Физическая память — это заразные ячейки памяти, которые имеют простое сопоставление между адресом физической памяти и соответствующей ячейкой памяти, декодируемой контроллером памяти. С другой стороны, *виртуальная память* не имеет прямого соответствия между адресом памяти и соответствующей ячейкой физической памяти, даже если это кажется заразным с точки зрения программы пользовательского пространства. Вместо этого адрес виртуальной памяти преобразуется ОС в фактический адрес физической памяти. По этой причине даже адреса появляются рядом друг с другом в пространстве виртуальной памяти, они разбросаны по физической памяти.</p><p height="1em" width="0pt">290</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">Зачем нужна виртуальная память? Потому что виртуальная память снижает сложность программирования, создавая у каждой программы иллюзию того, что у нее есть собственная отдельная «физическая» память для работы. Без виртуальной памяти программы должны знать и согласовывать друг с другом свои области памяти, чтобы случайно не уничтожить друг друга.</p><p height="1em" width="0pt">[иллюстрация мира без виртуальной памяти]</p><p height="1em" width="0pt">Виртуальная память также обеспечивает более безопасную ОС, поскольку прикладные программы не могут напрямую манипулировать основной памятью, поэтому вредоносные программы не будут причинять вред, уничтожая основную память и, возможно, аппаратные устройства, получая доступ к аппаратным портам ввода-вывода.</p><p height="1em" width="0pt">Еще одним преимуществом является то, что виртуальная память может выходить за пределы физической памяти, сохраняя свои данные на жестком диске. Заменяя часть неиспользуемой памяти (т. е. неактивной памяти спящего процесса), система получает часть свободной памяти для продолжения работы, поэтому никакие данные не уничтожаются. В противном случае ОС будет вынуждена убить случайный пользовательский процесс, чтобы освободить часть памяти, и вы можете потерять несохраненную работу, принадлежащую убитому процессу. Однако этот процесс может значительно замедлить работу всей системы из-за узкого места фон Неймана. В старые времена, когда памяти было мало, она была полезна.</p><a id="filepos799414" /><p height="1em" width="0pt"><b>13</b></p><p height="1em" width="0pt">Файловая система</p><p height="1em" width="0pt"> <i>Файловая система</i>представляет собой механизм осмысленного управления необработанными байтами на устройстве хранения. То есть группа байтов в определенных местах на устройстве хранения может быть выделена для цели, например. сохранение необработанного документа ASCII, а затем точные фрагменты байтов могут быть извлечены правильно.</p><p height="1em" width="0pt">Файловая система управляет многими такими группами байтов. Полезно рассматривать файловую систему как базу данных, которая сопоставляет высокоуровневую информацию с конкретными местами на жестком диске, подобно тому, как бизнес-информация сопоставляется с определенной строкой в ​​таблице. Информация высокого уровня, относящаяся к файловой системе, организована как *файлы* и *каталоги*.</p><p height="1em" width="0pt">[иллюстрация между файловой системой и таблицей базы данных, чтобы увидеть, как они похожи]</p><p height="1em" width="0pt"> <i>Файл</i>представляет собой объект, который включает в себя два компонента: метаданные и фактические необработанные данные.<i>Метаданные</i>информация описывает свойства необработанных данных, связанных с файлом; необработанные данные являются реальным содержимым файла.</p><p height="1em" width="0pt"> <i>Каталог</i>это файл, который содержит группу файлов, а также дочерние каталоги. Вместе они создают систему файловой иерархии, которую обычно можно увидеть в Windows или Linux.</p><p height="1em" width="0pt"> <i>13.0.1 Пример: файловая система Ex2</i></p><p height="1em" width="0pt"> <a id="filepos800899" />Индекс</p><p height="1em" width="0pt">Абстракция, 26</p><p height="1em" width="0pt">Заголовок ELF, 108</p><p height="1em" width="0pt">Интегрированный для конкретного приложения</p><p height="1em" width="0pt">встроенный компьютер, 36</p><p height="1em" width="0pt">Автодром, 39</p><p height="1em" width="0pt">встроенное программирование, 37</p><p height="1em" width="0pt">АСИК, 39 лет</p><p height="1em" width="0pt">исполняемый двоичный файл, 107</p><p height="1em" width="0pt">монтажник, 22 года</p><p height="1em" width="0pt">среда исполнения, 47</p><p height="1em" width="0pt">обратная связь, 175</p><p height="1em" width="0pt">выборка — декодирование — выполнение, 41</p><p height="1em" width="0pt">битовое поле, 78</p><p height="1em" width="0pt">выборка – декодирование – выполнение, 23</p><p height="1em" width="0pt">Автобус, 41, 44</p><p height="1em" width="0pt">Программируемый полевой шлюз</p><p height="1em" width="0pt">ширина шины, 44</p><p height="1em" width="0pt">Массив, 37</p><p height="1em" width="0pt">ПЛИС, 37</p><p height="1em" width="0pt">конденсатор, 43</p><p height="1em" width="0pt">автономная среда, 249</p><p height="1em" width="0pt">Центральный процессор, 41</p><p height="1em" width="0pt">атрибут функции, 128</p><p height="1em" width="0pt">чип, 15</p><p height="1em" width="0pt">функционально завершен, 13</p><p height="1em" width="0pt">чипсет, 44</p><p height="1em" width="0pt"> <i>КМОП</i>, 13</p><p height="1em" width="0pt">Описание оборудования</p><p height="1em" width="0pt"> <i>компилятор</i>, 24</p><p height="1em" width="0pt">Язык, 38</p><p height="1em" width="0pt">компьютер, 33</p><p height="1em" width="0pt">размещенная среда, 248</p><p height="1em" width="0pt">Компьютерная организация, 40</p><p height="1em" width="0pt">ЦП, 40, 41</p><p height="1em" width="0pt">Устройства ввода/вывода, 41</p><p height="1em" width="0pt">набор инструкций, 40</p><p height="1em" width="0pt">отладчик, 151</p><p height="1em" width="0pt">Архитектура набора инструкций, 40</p><p height="1em" width="0pt"> <i>Ввод отладочной информации</i>,</p><p height="1em" width="0pt">ИСА, 40 лет</p><p height="1em" width="0pt">181</p><p height="1em" width="0pt">настольный компьютер, 34</p><p height="1em" width="0pt">линкер, 227</p><p height="1em" width="0pt">доменный эксперт, 4</p><p height="1em" width="0pt">скрипт компоновщика, 227</p><p height="1em" width="0pt">294</p><p height="1em" width="0pt">операционные системы: от 0 до 1</p><p height="1em" width="0pt">адрес памяти загрузки, 244</p><p height="1em" width="0pt">Таблица заголовка программы, 108</p><p height="1em" width="0pt">логический элемент, 12</p><p height="1em" width="0pt">таблица заголовка программы, 141</p><p height="1em" width="0pt">программный сегмент, 141</p><p height="1em" width="0pt">Машинный язык, 17</p><p height="1em" width="0pt">Память, 41, 42</p><p height="1em" width="0pt">Регистры, 42</p><p height="1em" width="0pt">контроллер памяти, 43</p><p height="1em" width="0pt">Переезд, 217</p><p height="1em" width="0pt">Хаб контроллера памяти, 43</p><p height="1em" width="0pt">требования, 3</p><p height="1em" width="0pt">Микроконтроллер, 36</p><p height="1em" width="0pt">мобильный компьютер, 35</p><p height="1em" width="0pt">участок, 50, 108</p><p height="1em" width="0pt">МОП-транзистор, 12</p><p height="1em" width="0pt">Таблица заголовка раздела, 108</p><p height="1em" width="0pt">материнская плата, 44</p><p height="1em" width="0pt">сектор, 202</p><p height="1em" width="0pt">сегмент, 108</p><p height="1em" width="0pt">нетлист, 38</p><p height="1em" width="0pt">Сегменты и секции, 108</p><p height="1em" width="0pt">сервер, 34</p><p height="1em" width="0pt">обждамп, 50</p><p height="1em" width="0pt">Требования к программному обеспечению</p><p height="1em" width="0pt">объектный файл, 107</p><p height="1em" width="0pt">документ, 6</p><p height="1em" width="0pt">смещение, 117, 219</p><p height="1em" width="0pt">Спецификация программного обеспечения, 8</p><p height="1em" width="0pt">запоминающее устройство, 22</p><p height="1em" width="0pt">байты заполнения, 75</p><p height="1em" width="0pt">система-на-чипе, 36</p><p height="1em" width="0pt">печатная плата, 36</p><p height="1em" width="0pt">постоянное запоминающее устройство, 202</p><p height="1em" width="0pt">трасса, 202</p><p height="1em" width="0pt">Портовая, 42</p><p height="1em" width="0pt">транзистор, 12</p><p height="1em" width="0pt">Печатная плата, 36</p><p height="1em" width="0pt">проблемный домен, 3</p><p height="1em" width="0pt">адрес виртуальной памяти, 228,</p><p height="1em" width="0pt">заголовок программы, 141</p><p height="1em" width="0pt">244</p><a id="filepos805320" /><p height="1em" width="0pt">Библиография</p><p height="1em" width="0pt">Г. Х. Харди.</p><p height="1em" width="0pt"> <i>Апология математика</i>, глава 10, стр. 13.</p><p height="1em" width="0pt">Общество математических наук Университета Альберты, 2005 г.</p><p height="1em" width="0pt">Интел.</p><p height="1em" width="0pt"> <i>Справочник по оптимизации архитектур Intel® 64 и IA-32</i> <i>Руководство</i>. Интел, 2016b.</p><p height="1em" width="0pt">Бенджамин Л. Ковиц.</p><p height="1em" width="0pt"> <i>Практические требования к программному обеспечению</i>,Глава 3,</p><p height="1em" width="0pt">стр. 53. Мэннинг, 1999.</p><p height="1em" width="0pt">Чарльз Сандерс Пирс.</p><p height="1em" width="0pt"> <i>Сборник статей т. 4</i>,глава Булево значение</p><p height="1em" width="0pt">Алгебра с одной константой. 1933 год.</p><p height="1em" width="0pt">Джон Ф. Уокерли.<i>Цифровой дизайн: принципы и практика</i>, глава 3, стр. 86. Prentice Hall, 1999.</p><p height="1em" width="0pt"></p><mbp:pagebreak></mbp:pagebreak><p height="1em" width="0pt"><font size="7"><b>Структура документа</b></font></p><div height="1em"></div><ul width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos301">Содержание</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos19159">Предисловие</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos32544">я предварительный</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos32647">1 Документы домена</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos32647">1.1 Проблемные области</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos39218">1.2 Документы для реализации предметной области</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos46844">1.3 Документы для написания операционной системы x86</a></li></ul></li><li value="2" height="0pt" width="0pt"><a href="#filepos49797">2. От аппаратного обеспечения к программному: уровни абстракции</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos49797">2.1 Физическая реализация бита</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos51195">2.2 Помимо транзисторов: цифровые логические элементы</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos67491">2.3 За пределами логических вентилей: машинный язык</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos96782">2.4 Абстракция</a></li></ul></li><li value="3" height="0pt" width="0pt"><a href="#filepos108871">3 Архитектура компьютера</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos108871">3.1 Что такое компьютер?</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos127840">3.2 Архитектура компьютера</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos140936">Архитектура 3.3 x86</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos147832">3.4 Чипсет Intel Q35</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos147832">3.5 Среда выполнения x86</a></li></ul></li><li value="4" height="0pt" width="0pt"><a href="#filepos149943">4 x86 Сборка и C</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos151594">4.1 обждамп</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos153494">4.2 Чтение вывода</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos157688">4.3 Руководства Intel</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos160699">4.4 Эксперимент с ассемблерным кодом</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos166809">4.5 Структура инструкции по сборке</a></li><li value="6" height="0pt" width="0pt"><a href="#filepos225809">4.6 Подробное понимание инструкции</a></li><li value="7" height="0pt" width="0pt"><a href="#filepos233869">4.7 Пример: инструкция jmp</a></li><li value="8" height="0pt" width="0pt"><a href="#filepos245992">4.8 Изучение скомпилированных данных</a></li><li value="9" height="0pt" width="0pt"><a href="#filepos283477">4.9 Изучите скомпилированный код</a></li></ul></li><li value="5" height="0pt" width="0pt"><a href="#filepos344661">5 Анатомия программы</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos348998">5.1 Справочные документы:</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos348998">5.2 ELF-заголовок</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos360914">5.3 Таблица заголовка раздела</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos384929">5.4 Подробное понимание раздела</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos444786">5.5 Таблица заголовка программы</a></li><li value="6" height="0pt" width="0pt"><a href="#filepos454498">5.6 Сегменты и разделы</a></li></ul></li><li value="6" height="0pt" width="0pt"><a href="#filepos481111">6 Проверка и отладка во время выполнения</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos481111">6.1 Пример программы</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos482462">6.2 Статическая проверка программы</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos510333">6.3 Проверка программы во время выполнения</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos540659">6.4 Как работают отладчики: краткое введение</a></li></ul></li></ul></li><li value="4" height="0pt" width="0pt"><a href="#filepos574709">II Основа</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos574833">7 Загрузчик</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos574833">7.1 Процесс загрузки x86</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos576886">7.2 Использование служб BIOS</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos579975">7.3 Процесс загрузки</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos579975">7.4 Пример загрузчика</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos582270">7.5 Компиляция и загрузка</a></li><li value="6" height="0pt" width="0pt"><a href="#filepos592594">7.6 Загрузка программы из загрузчика</a></li><li value="7" height="0pt" width="0pt"><a href="#filepos604179">7.7 Повышение производительности с помощью сценариев</a></li></ul></li><li value="2" height="0pt" width="0pt"><a href="#filepos635813">8 Связывание и загрузка на голое железо</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos637501">8.1 Понимание перемещений с помощью readelf</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos672464">8.2 Создание двоичного файла ELF с помощью скриптов компоновщика</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos723613">8.3 Среда выполнения C: размещенная и отдельно стоящая</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos726092">8.4 Отлаживаемый загрузчик на голом железе</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos730559">8.5 Отлаживаемая программа на «голом железе»</a></li></ul></li></ul></li><li value="5" height="0pt" width="0pt"><a href="#filepos780273">III Программирование ядра</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos780385">9 x86 дескрипторов</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos780385">9.1 Основные понятия операционной системы</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos784047">9.2 Драйверы</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos784047">9.3 Пространство пользователя и пространство ядра</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos786399">9.4 Сегмент памяти</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos786399">9.5 Дескриптор сегмента</a></li><li value="6" height="0pt" width="0pt"><a href="#filepos786399">9.6 Типы дескрипторов сегментов</a></li><li value="7" height="0pt" width="0pt"><a href="#filepos786399">9.7 Область действия дескриптора</a></li><li value="8" height="0pt" width="0pt"><a href="#filepos786399">9.8 Селектор сегментов</a></li><li value="9" height="0pt" width="0pt"><a href="#filepos786399">9.9 Улучшение: загрузчик с дескрипторами</a></li></ul></li><li value="2" height="0pt" width="0pt"><a href="#filepos787560">10 Процесс</a> <ul height="0pt" width="0pt"><li value="1" height="0pt" width="0pt"><a href="#filepos787560">10.1 Понятия</a></li><li value="2" height="0pt" width="0pt"><a href="#filepos787560">10.2 Процесс</a></li><li value="3" height="0pt" width="0pt"><a href="#filepos791371">10.3 Потоки</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos793483">10.4 Задача: концепция процесса x86</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos793483">10.5 Структура данных задачи</a></li><li value="6" height="0pt" width="0pt"><a href="#filepos793483">10.6 Реализация процесса</a></li><li value="7" height="0pt" width="0pt"><a href="#filepos795678">10.7 Веха: рефакторинг кода</a></li></ul></li><li value="3" height="0pt" width="0pt"><a href="#filepos796642">11 Прерывание</a></li><li value="4" height="0pt" width="0pt"><a href="#filepos796732">12 Управление памятью</a></li><li value="5" height="0pt" width="0pt"><a href="#filepos799414">13 Файловая система</a></li></ul></li><li value="6" height="0pt" width="0pt"><a href="#filepos800899">Индекс</a></li><li value="7" height="0pt" width="0pt"><a href="#filepos805320">Библиография</a></li></ul><mbp:pagebreak/><a id="filepos814478" /><p height="1em" width="0pt" align="center"><font size="5"><b>Оглавление</b></font></p><p height="1em" width="-14pt"><a href="#filepos301">Содержание</a></p><p height="0pt" width="-14pt"><a href="#filepos19159">Предисловие</a></p><p height="0pt" width="-14pt"><a href="#filepos32544">я предварительный</a></p><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos32647">1 Документы домена</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos32647">1.1 Проблемные области</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos39218">1.2 Документы для реализации предметной области</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos46844">1.3 Документы для написания операционной системы x86</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos49797">2. От аппаратного обеспечения к программному: уровни абстракции</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos49797">2.1 Физическая реализация бита</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos51195">2.2 Помимо транзисторов: цифровые логические элементы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos67491">2.3 За пределами логических вентилей: машинный язык</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos96782">2.4 Абстракция</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos108871">3 Архитектура компьютера</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos108871">3.1 Что такое компьютер?</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos127840">3.2 Архитектура компьютера</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos140936">Архитектура 3.3 x86</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos147832">3.4 Чипсет Intel Q35</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos147832">3.5 Среда выполнения x86</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos149943">4 x86 Сборка и C</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos151594">4.1 обждамп</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos153494">4.2 Чтение вывода</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos157688">4.3 Руководства Intel</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos160699">4.4 Эксперимент с ассемблерным кодом</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos166809">4.5 Структура инструкции по сборке</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos225809">4.6 Подробное понимание инструкции</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos233869">4.7 Пример: инструкция jmp</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos245992">4.8 Изучение скомпилированных данных</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos283477">4.9 Изучите скомпилированный код</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos344661">5 Анатомия программы</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos348998">5.1 Справочные документы:</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos348998">5.2 ELF-заголовок</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos360914">5.3 Таблица заголовка раздела</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos384929">5.4 Подробное понимание раздела</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos444786">5.5 Таблица заголовка программы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos454498">5.6 Сегменты и разделы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos481111">6 Проверка и отладка во время выполнения</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos481111">6.1 Пример программы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos482462">6.2 Статическая проверка программы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos510333">6.3 Проверка программы во время выполнения</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos540659">6.4 Как работают отладчики: краткое введение</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p height="0pt" width="-14pt"><a href="#filepos574709">II Основа</a></p><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos574833">7 Загрузчик</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos574833">7.1 Процесс загрузки x86</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos576886">7.2 Использование служб BIOS</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos579975">7.3 Процесс загрузки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos579975">7.4 Пример загрузчика</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos582270">7.5 Компиляция и загрузка</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos592594">7.6 Загрузка программы из загрузчика</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos604179">7.7 Повышение производительности с помощью сценариев</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos635813">8 Связывание и загрузка на голое железо</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos637501">8.1 Понимание перемещений с помощью readelf</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos672464">8.2 Создание двоичного файла ELF с помощью скриптов компоновщика</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos723613">8.3 Среда выполнения C: размещенная и отдельно стоящая</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos726092">8.4 Отлаживаемый загрузчик на голом железе</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos730559">8.5 Отлаживаемая программа на «голом железе»</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p height="0pt" width="-14pt"><a href="#filepos780273">III Программирование ядра</a></p><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos780385">9 x86 дескрипторов</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos780385">9.1 Основные понятия операционной системы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos784047">9.2 Драйверы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos784047">9.3 Пространство пользователя и пространство ядра</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos786399">9.4 Сегмент памяти</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos786399">9.5 Дескриптор сегмента</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos786399">9.6 Типы дескрипторов сегментов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos786399">9.7 Область действия дескриптора</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos786399">9.8 Селектор сегментов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos786399">9.9 Улучшение: загрузчик с дескрипторами</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos787560">10 Процесс</a></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos787560">10.1 Понятия</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos787560">10.2 Процесс</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos791371">10.3 Потоки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos793483">10.4 Задача: концепция процесса x86</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos793483">10.5 Структура данных задачи</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos793483">10.6 Реализация процесса</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote><blockquote><blockquote><blockquote><blockquote width="0pt"><a href="#filepos795678">10.7 Веха: рефакторинг кода</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos796642">11 Прерывание</a></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos796732">12 Управление памятью</a></blockquote></blockquote><blockquote height="0pt"><blockquote width="0pt"><a href="#filepos799414">13 Файловая система</a></blockquote></blockquote><p height="0pt" width="-14pt"><a href="#filepos800899">Индекс</a></p><p height="0pt" width="-14pt"><a href="#filepos805320">Библиография</a></p><mbp:pagebreak/>  </body></html>